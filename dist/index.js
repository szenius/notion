/******/ (() => {
    // webpackBootstrap
    /******/ var __webpack_modules__ = {
        /***/ 7351: /***/ function (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) {
            "use strict";

            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          Object.defineProperty(o, k2, {
                              enumerable: true,
                              get: function () {
                                  return m[k];
                              },
                          });
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                    ? function (o, v) {
                          Object.defineProperty(o, "default", {
                              enumerable: true,
                              value: v,
                          });
                      }
                    : function (o, v) {
                          o["default"] = v;
                      });
            var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                    if (mod && mod.__esModule) return mod;
                    var result = {};
                    if (mod != null)
                        for (var k in mod)
                            if (
                                k !== "default" &&
                                Object.hasOwnProperty.call(mod, k)
                            )
                                __createBinding(result, mod, k);
                    __setModuleDefault(result, mod);
                    return result;
                };
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.issue = exports.issueCommand = void 0;
            const os = __importStar(__nccwpck_require__(2087));
            const utils_1 = __nccwpck_require__(5278);
            /**
             * Commands
             *
             * Command Format:
             *   ::name key=value,key=value::message
             *
             * Examples:
             *   ::warning::This is the message
             *   ::set-env name=MY_VAR::some value
             */
            function issueCommand(command, properties, message) {
                const cmd = new Command(command, properties, message);
                process.stdout.write(cmd.toString() + os.EOL);
            }
            exports.issueCommand = issueCommand;
            function issue(name, message = "") {
                issueCommand(name, {}, message);
            }
            exports.issue = issue;
            const CMD_STRING = "::";
            class Command {
                constructor(command, properties, message) {
                    if (!command) {
                        command = "missing.command";
                    }
                    this.command = command;
                    this.properties = properties;
                    this.message = message;
                }
                toString() {
                    let cmdStr = CMD_STRING + this.command;
                    if (
                        this.properties &&
                        Object.keys(this.properties).length > 0
                    ) {
                        cmdStr += " ";
                        let first = true;
                        for (const key in this.properties) {
                            if (this.properties.hasOwnProperty(key)) {
                                const val = this.properties[key];
                                if (val) {
                                    if (first) {
                                        first = false;
                                    } else {
                                        cmdStr += ",";
                                    }
                                    cmdStr += `${key}=${escapeProperty(val)}`;
                                }
                            }
                        }
                    }
                    cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
                    return cmdStr;
                }
            }
            function escapeData(s) {
                return utils_1
                    .toCommandValue(s)
                    .replace(/%/g, "%25")
                    .replace(/\r/g, "%0D")
                    .replace(/\n/g, "%0A");
            }
            function escapeProperty(s) {
                return utils_1
                    .toCommandValue(s)
                    .replace(/%/g, "%25")
                    .replace(/\r/g, "%0D")
                    .replace(/\n/g, "%0A")
                    .replace(/:/g, "%3A")
                    .replace(/,/g, "%2C");
            }
            //# sourceMappingURL=command.js.map

            /***/
        },

        /***/ 2186: /***/ function (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) {
            "use strict";

            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          Object.defineProperty(o, k2, {
                              enumerable: true,
                              get: function () {
                                  return m[k];
                              },
                          });
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                    ? function (o, v) {
                          Object.defineProperty(o, "default", {
                              enumerable: true,
                              value: v,
                          });
                      }
                    : function (o, v) {
                          o["default"] = v;
                      });
            var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                    if (mod && mod.__esModule) return mod;
                    var result = {};
                    if (mod != null)
                        for (var k in mod)
                            if (
                                k !== "default" &&
                                Object.hasOwnProperty.call(mod, k)
                            )
                                __createBinding(result, mod, k);
                    __setModuleDefault(result, mod);
                    return result;
                };
            var __awaiter =
                (this && this.__awaiter) ||
                function (thisArg, _arguments, P, generator) {
                    function adopt(value) {
                        return value instanceof P
                            ? value
                            : new P(function (resolve) {
                                  resolve(value);
                              });
                    }
                    return new (P || (P = Promise))(function (resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator["throw"](value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function step(result) {
                            result.done
                                ? resolve(result.value)
                                : adopt(result.value).then(fulfilled, rejected);
                        }
                        step(
                            (generator = generator.apply(
                                thisArg,
                                _arguments || []
                            )).next()
                        );
                    });
                };
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.getState =
                exports.saveState =
                exports.group =
                exports.endGroup =
                exports.startGroup =
                exports.info =
                exports.notice =
                exports.warning =
                exports.error =
                exports.debug =
                exports.isDebug =
                exports.setFailed =
                exports.setCommandEcho =
                exports.setOutput =
                exports.getBooleanInput =
                exports.getMultilineInput =
                exports.getInput =
                exports.addPath =
                exports.setSecret =
                exports.exportVariable =
                exports.ExitCode =
                    void 0;
            const command_1 = __nccwpck_require__(7351);
            const file_command_1 = __nccwpck_require__(717);
            const utils_1 = __nccwpck_require__(5278);
            const os = __importStar(__nccwpck_require__(2087));
            const path = __importStar(__nccwpck_require__(5622));
            /**
             * The code to exit an action
             */
            var ExitCode;
            (function (ExitCode) {
                /**
                 * A code indicating that the action was successful
                 */
                ExitCode[(ExitCode["Success"] = 0)] = "Success";
                /**
                 * A code indicating that the action was a failure
                 */
                ExitCode[(ExitCode["Failure"] = 1)] = "Failure";
            })((ExitCode = exports.ExitCode || (exports.ExitCode = {})));
            //-----------------------------------------------------------------------
            // Variables
            //-----------------------------------------------------------------------
            /**
             * Sets env variable for this action and future actions in the job
             * @param name the name of the variable to set
             * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
             */
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            function exportVariable(name, val) {
                const convertedVal = utils_1.toCommandValue(val);
                process.env[name] = convertedVal;
                const filePath = process.env["GITHUB_ENV"] || "";
                if (filePath) {
                    const delimiter = "_GitHubActionsFileCommandDelimeter_";
                    const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;
                    file_command_1.issueCommand("ENV", commandValue);
                } else {
                    command_1.issueCommand("set-env", { name }, convertedVal);
                }
            }
            exports.exportVariable = exportVariable;
            /**
             * Registers a secret which will get masked from logs
             * @param secret value of the secret
             */
            function setSecret(secret) {
                command_1.issueCommand("add-mask", {}, secret);
            }
            exports.setSecret = setSecret;
            /**
             * Prepends inputPath to the PATH (for this action and future actions)
             * @param inputPath
             */
            function addPath(inputPath) {
                const filePath = process.env["GITHUB_PATH"] || "";
                if (filePath) {
                    file_command_1.issueCommand("PATH", inputPath);
                } else {
                    command_1.issueCommand("add-path", {}, inputPath);
                }
                process.env[
                    "PATH"
                ] = `${inputPath}${path.delimiter}${process.env["PATH"]}`;
            }
            exports.addPath = addPath;
            /**
             * Gets the value of an input.
             * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
             * Returns an empty string if the value is not defined.
             *
             * @param     name     name of the input to get
             * @param     options  optional. See InputOptions.
             * @returns   string
             */
            function getInput(name, options) {
                const val =
                    process.env[
                        `INPUT_${name.replace(/ /g, "_").toUpperCase()}`
                    ] || "";
                if (options && options.required && !val) {
                    throw new Error(`Input required and not supplied: ${name}`);
                }
                if (options && options.trimWhitespace === false) {
                    return val;
                }
                return val.trim();
            }
            exports.getInput = getInput;
            /**
             * Gets the values of an multiline input.  Each value is also trimmed.
             *
             * @param     name     name of the input to get
             * @param     options  optional. See InputOptions.
             * @returns   string[]
             *
             */
            function getMultilineInput(name, options) {
                const inputs = getInput(name, options)
                    .split("\n")
                    .filter((x) => x !== "");
                return inputs;
            }
            exports.getMultilineInput = getMultilineInput;
            /**
             * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
             * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
             * The return value is also in boolean type.
             * ref: https://yaml.org/spec/1.2/spec.html#id2804923
             *
             * @param     name     name of the input to get
             * @param     options  optional. See InputOptions.
             * @returns   boolean
             */
            function getBooleanInput(name, options) {
                const trueValue = ["true", "True", "TRUE"];
                const falseValue = ["false", "False", "FALSE"];
                const val = getInput(name, options);
                if (trueValue.includes(val)) return true;
                if (falseValue.includes(val)) return false;
                throw new TypeError(
                    `Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
                        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``
                );
            }
            exports.getBooleanInput = getBooleanInput;
            /**
             * Sets the value of an output.
             *
             * @param     name     name of the output to set
             * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
             */
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            function setOutput(name, value) {
                process.stdout.write(os.EOL);
                command_1.issueCommand("set-output", { name }, value);
            }
            exports.setOutput = setOutput;
            /**
             * Enables or disables the echoing of commands into stdout for the rest of the step.
             * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
             *
             */
            function setCommandEcho(enabled) {
                command_1.issue("echo", enabled ? "on" : "off");
            }
            exports.setCommandEcho = setCommandEcho;
            //-----------------------------------------------------------------------
            // Results
            //-----------------------------------------------------------------------
            /**
             * Sets the action status to failed.
             * When the action exits it will be with an exit code of 1
             * @param message add error issue message
             */
            function setFailed(message) {
                process.exitCode = ExitCode.Failure;
                error(message);
            }
            exports.setFailed = setFailed;
            //-----------------------------------------------------------------------
            // Logging Commands
            //-----------------------------------------------------------------------
            /**
             * Gets whether Actions Step Debug is on or not
             */
            function isDebug() {
                return process.env["RUNNER_DEBUG"] === "1";
            }
            exports.isDebug = isDebug;
            /**
             * Writes debug message to user log
             * @param message debug message
             */
            function debug(message) {
                command_1.issueCommand("debug", {}, message);
            }
            exports.debug = debug;
            /**
             * Adds an error issue
             * @param message error issue message. Errors will be converted to string via toString()
             * @param properties optional properties to add to the annotation.
             */
            function error(message, properties = {}) {
                command_1.issueCommand(
                    "error",
                    utils_1.toCommandProperties(properties),
                    message instanceof Error ? message.toString() : message
                );
            }
            exports.error = error;
            /**
             * Adds a warning issue
             * @param message warning issue message. Errors will be converted to string via toString()
             * @param properties optional properties to add to the annotation.
             */
            function warning(message, properties = {}) {
                command_1.issueCommand(
                    "warning",
                    utils_1.toCommandProperties(properties),
                    message instanceof Error ? message.toString() : message
                );
            }
            exports.warning = warning;
            /**
             * Adds a notice issue
             * @param message notice issue message. Errors will be converted to string via toString()
             * @param properties optional properties to add to the annotation.
             */
            function notice(message, properties = {}) {
                command_1.issueCommand(
                    "notice",
                    utils_1.toCommandProperties(properties),
                    message instanceof Error ? message.toString() : message
                );
            }
            exports.notice = notice;
            /**
             * Writes info to log with console.log.
             * @param message info message
             */
            function info(message) {
                process.stdout.write(message + os.EOL);
            }
            exports.info = info;
            /**
             * Begin an output group.
             *
             * Output until the next `groupEnd` will be foldable in this group
             *
             * @param name The name of the output group
             */
            function startGroup(name) {
                command_1.issue("group", name);
            }
            exports.startGroup = startGroup;
            /**
             * End an output group.
             */
            function endGroup() {
                command_1.issue("endgroup");
            }
            exports.endGroup = endGroup;
            /**
             * Wrap an asynchronous function call in a group.
             *
             * Returns the same type as the function itself.
             *
             * @param name The name of the group
             * @param fn The function to wrap in the group
             */
            function group(name, fn) {
                return __awaiter(this, void 0, void 0, function* () {
                    startGroup(name);
                    let result;
                    try {
                        result = yield fn();
                    } finally {
                        endGroup();
                    }
                    return result;
                });
            }
            exports.group = group;
            //-----------------------------------------------------------------------
            // Wrapper action state
            //-----------------------------------------------------------------------
            /**
             * Saves state for current action, the state can only be retrieved by this action's post job execution.
             *
             * @param     name     name of the state to store
             * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
             */
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            function saveState(name, value) {
                command_1.issueCommand("save-state", { name }, value);
            }
            exports.saveState = saveState;
            /**
             * Gets the value of an state set by this action's main execution.
             *
             * @param     name     name of the state to get
             * @returns   string
             */
            function getState(name) {
                return process.env[`STATE_${name}`] || "";
            }
            exports.getState = getState;
            //# sourceMappingURL=core.js.map

            /***/
        },

        /***/ 717: /***/ function (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) {
            "use strict";

            // For internal use, subject to change.
            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          Object.defineProperty(o, k2, {
                              enumerable: true,
                              get: function () {
                                  return m[k];
                              },
                          });
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                    ? function (o, v) {
                          Object.defineProperty(o, "default", {
                              enumerable: true,
                              value: v,
                          });
                      }
                    : function (o, v) {
                          o["default"] = v;
                      });
            var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                    if (mod && mod.__esModule) return mod;
                    var result = {};
                    if (mod != null)
                        for (var k in mod)
                            if (
                                k !== "default" &&
                                Object.hasOwnProperty.call(mod, k)
                            )
                                __createBinding(result, mod, k);
                    __setModuleDefault(result, mod);
                    return result;
                };
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.issueCommand = void 0;
            // We use any as a valid input type
            /* eslint-disable @typescript-eslint/no-explicit-any */
            const fs = __importStar(__nccwpck_require__(5747));
            const os = __importStar(__nccwpck_require__(2087));
            const utils_1 = __nccwpck_require__(5278);
            function issueCommand(command, message) {
                const filePath = process.env[`GITHUB_${command}`];
                if (!filePath) {
                    throw new Error(
                        `Unable to find environment variable for file command ${command}`
                    );
                }
                if (!fs.existsSync(filePath)) {
                    throw new Error(`Missing file at path: ${filePath}`);
                }
                fs.appendFileSync(
                    filePath,
                    `${utils_1.toCommandValue(message)}${os.EOL}`,
                    {
                        encoding: "utf8",
                    }
                );
            }
            exports.issueCommand = issueCommand;
            //# sourceMappingURL=file-command.js.map

            /***/
        },

        /***/ 5278: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            // We use any as a valid input type
            /* eslint-disable @typescript-eslint/no-explicit-any */
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.toCommandProperties = exports.toCommandValue = void 0;
            /**
             * Sanitizes an input into a string so it can be passed into issueCommand safely
             * @param input input to sanitize into a string
             */
            function toCommandValue(input) {
                if (input === null || input === undefined) {
                    return "";
                } else if (
                    typeof input === "string" ||
                    input instanceof String
                ) {
                    return input;
                }
                return JSON.stringify(input);
            }
            exports.toCommandValue = toCommandValue;
            /**
             *
             * @param annotationProperties
             * @returns The command properties to send with the actual annotation command
             * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
             */
            function toCommandProperties(annotationProperties) {
                if (!Object.keys(annotationProperties).length) {
                    return {};
                }
                return {
                    title: annotationProperties.title,
                    line: annotationProperties.startLine,
                    endLine: annotationProperties.endLine,
                    col: annotationProperties.startColumn,
                    endColumn: annotationProperties.endColumn,
                };
            }
            exports.toCommandProperties = toCommandProperties;
            //# sourceMappingURL=utils.js.map

            /***/
        },

        /***/ 4087: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            exports.Context = void 0;
            const fs_1 = __nccwpck_require__(5747);
            const os_1 = __nccwpck_require__(2087);
            class Context {
                /**
                 * Hydrate the context from the environment
                 */
                constructor() {
                    var _a, _b, _c;
                    this.payload = {};
                    if (process.env.GITHUB_EVENT_PATH) {
                        if (fs_1.existsSync(process.env.GITHUB_EVENT_PATH)) {
                            this.payload = JSON.parse(
                                fs_1.readFileSync(
                                    process.env.GITHUB_EVENT_PATH,
                                    { encoding: "utf8" }
                                )
                            );
                        } else {
                            const path = process.env.GITHUB_EVENT_PATH;
                            process.stdout.write(
                                `GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`
                            );
                        }
                    }
                    this.eventName = process.env.GITHUB_EVENT_NAME;
                    this.sha = process.env.GITHUB_SHA;
                    this.ref = process.env.GITHUB_REF;
                    this.workflow = process.env.GITHUB_WORKFLOW;
                    this.action = process.env.GITHUB_ACTION;
                    this.actor = process.env.GITHUB_ACTOR;
                    this.job = process.env.GITHUB_JOB;
                    this.runNumber = parseInt(
                        process.env.GITHUB_RUN_NUMBER,
                        10
                    );
                    this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
                    this.apiUrl =
                        (_a = process.env.GITHUB_API_URL) !== null &&
                        _a !== void 0
                            ? _a
                            : `https://api.github.com`;
                    this.serverUrl =
                        (_b = process.env.GITHUB_SERVER_URL) !== null &&
                        _b !== void 0
                            ? _b
                            : `https://github.com`;
                    this.graphqlUrl =
                        (_c = process.env.GITHUB_GRAPHQL_URL) !== null &&
                        _c !== void 0
                            ? _c
                            : `https://api.github.com/graphql`;
                }
                get issue() {
                    const payload = this.payload;
                    return Object.assign(Object.assign({}, this.repo), {
                        number: (
                            payload.issue ||
                            payload.pull_request ||
                            payload
                        ).number,
                    });
                }
                get repo() {
                    if (process.env.GITHUB_REPOSITORY) {
                        const [owner, repo] =
                            process.env.GITHUB_REPOSITORY.split("/");
                        return { owner, repo };
                    }
                    if (this.payload.repository) {
                        return {
                            owner: this.payload.repository.owner.login,
                            repo: this.payload.repository.name,
                        };
                    }
                    throw new Error(
                        "context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'"
                    );
                }
            }
            exports.Context = Context;
            //# sourceMappingURL=context.js.map

            /***/
        },

        /***/ 5438: /***/ function (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) {
            "use strict";

            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          Object.defineProperty(o, k2, {
                              enumerable: true,
                              get: function () {
                                  return m[k];
                              },
                          });
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                    ? function (o, v) {
                          Object.defineProperty(o, "default", {
                              enumerable: true,
                              value: v,
                          });
                      }
                    : function (o, v) {
                          o["default"] = v;
                      });
            var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                    if (mod && mod.__esModule) return mod;
                    var result = {};
                    if (mod != null)
                        for (var k in mod)
                            if (
                                k !== "default" &&
                                Object.hasOwnProperty.call(mod, k)
                            )
                                __createBinding(result, mod, k);
                    __setModuleDefault(result, mod);
                    return result;
                };
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.getOctokit = exports.context = void 0;
            const Context = __importStar(__nccwpck_require__(4087));
            const utils_1 = __nccwpck_require__(3030);
            exports.context = new Context.Context();
            /**
             * Returns a hydrated octokit ready to use for GitHub Actions
             *
             * @param     token    the repo PAT or GITHUB_TOKEN
             * @param     options  other options to set
             */
            function getOctokit(token, options) {
                return new utils_1.GitHub(
                    utils_1.getOctokitOptions(token, options)
                );
            }
            exports.getOctokit = getOctokit;
            //# sourceMappingURL=github.js.map

            /***/
        },

        /***/ 7914: /***/ function (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) {
            "use strict";

            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          Object.defineProperty(o, k2, {
                              enumerable: true,
                              get: function () {
                                  return m[k];
                              },
                          });
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                    ? function (o, v) {
                          Object.defineProperty(o, "default", {
                              enumerable: true,
                              value: v,
                          });
                      }
                    : function (o, v) {
                          o["default"] = v;
                      });
            var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                    if (mod && mod.__esModule) return mod;
                    var result = {};
                    if (mod != null)
                        for (var k in mod)
                            if (
                                k !== "default" &&
                                Object.hasOwnProperty.call(mod, k)
                            )
                                __createBinding(result, mod, k);
                    __setModuleDefault(result, mod);
                    return result;
                };
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.getApiBaseUrl =
                exports.getProxyAgent =
                exports.getAuthString =
                    void 0;
            const httpClient = __importStar(__nccwpck_require__(9925));
            function getAuthString(token, options) {
                if (!token && !options.auth) {
                    throw new Error("Parameter token or opts.auth is required");
                } else if (token && options.auth) {
                    throw new Error(
                        "Parameters token and opts.auth may not both be specified"
                    );
                }
                return typeof options.auth === "string"
                    ? options.auth
                    : `token ${token}`;
            }
            exports.getAuthString = getAuthString;
            function getProxyAgent(destinationUrl) {
                const hc = new httpClient.HttpClient();
                return hc.getAgent(destinationUrl);
            }
            exports.getProxyAgent = getProxyAgent;
            function getApiBaseUrl() {
                return (
                    process.env["GITHUB_API_URL"] || "https://api.github.com"
                );
            }
            exports.getApiBaseUrl = getApiBaseUrl;
            //# sourceMappingURL=utils.js.map

            /***/
        },

        /***/ 3030: /***/ function (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) {
            "use strict";

            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          Object.defineProperty(o, k2, {
                              enumerable: true,
                              get: function () {
                                  return m[k];
                              },
                          });
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                    ? function (o, v) {
                          Object.defineProperty(o, "default", {
                              enumerable: true,
                              value: v,
                          });
                      }
                    : function (o, v) {
                          o["default"] = v;
                      });
            var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                    if (mod && mod.__esModule) return mod;
                    var result = {};
                    if (mod != null)
                        for (var k in mod)
                            if (
                                k !== "default" &&
                                Object.hasOwnProperty.call(mod, k)
                            )
                                __createBinding(result, mod, k);
                    __setModuleDefault(result, mod);
                    return result;
                };
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.getOctokitOptions =
                exports.GitHub =
                exports.context =
                    void 0;
            const Context = __importStar(__nccwpck_require__(4087));
            const Utils = __importStar(__nccwpck_require__(7914));
            // octokit + plugins
            const core_1 = __nccwpck_require__(6762);
            const plugin_rest_endpoint_methods_1 = __nccwpck_require__(3044);
            const plugin_paginate_rest_1 = __nccwpck_require__(4193);
            exports.context = new Context.Context();
            const baseUrl = Utils.getApiBaseUrl();
            const defaults = {
                baseUrl,
                request: {
                    agent: Utils.getProxyAgent(baseUrl),
                },
            };
            exports.GitHub = core_1.Octokit.plugin(
                plugin_rest_endpoint_methods_1.restEndpointMethods,
                plugin_paginate_rest_1.paginateRest
            ).defaults(defaults);
            /**
             * Convience function to correctly format Octokit Options to pass into the constructor.
             *
             * @param     token    the repo PAT or GITHUB_TOKEN
             * @param     options  other options to set
             */
            function getOctokitOptions(token, options) {
                const opts = Object.assign({}, options || {}); // Shallow clone - don't mutate the object provided by the caller
                // Auth
                const auth = Utils.getAuthString(token, opts);
                if (auth) {
                    opts.auth = auth;
                }
                return opts;
            }
            exports.getOctokitOptions = getOctokitOptions;
            //# sourceMappingURL=utils.js.map

            /***/
        },

        /***/ 9925: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            const http = __nccwpck_require__(8605);
            const https = __nccwpck_require__(7211);
            const pm = __nccwpck_require__(6443);
            let tunnel;
            var HttpCodes;
            (function (HttpCodes) {
                HttpCodes[(HttpCodes["OK"] = 200)] = "OK";
                HttpCodes[(HttpCodes["MultipleChoices"] = 300)] =
                    "MultipleChoices";
                HttpCodes[(HttpCodes["MovedPermanently"] = 301)] =
                    "MovedPermanently";
                HttpCodes[(HttpCodes["ResourceMoved"] = 302)] = "ResourceMoved";
                HttpCodes[(HttpCodes["SeeOther"] = 303)] = "SeeOther";
                HttpCodes[(HttpCodes["NotModified"] = 304)] = "NotModified";
                HttpCodes[(HttpCodes["UseProxy"] = 305)] = "UseProxy";
                HttpCodes[(HttpCodes["SwitchProxy"] = 306)] = "SwitchProxy";
                HttpCodes[(HttpCodes["TemporaryRedirect"] = 307)] =
                    "TemporaryRedirect";
                HttpCodes[(HttpCodes["PermanentRedirect"] = 308)] =
                    "PermanentRedirect";
                HttpCodes[(HttpCodes["BadRequest"] = 400)] = "BadRequest";
                HttpCodes[(HttpCodes["Unauthorized"] = 401)] = "Unauthorized";
                HttpCodes[(HttpCodes["PaymentRequired"] = 402)] =
                    "PaymentRequired";
                HttpCodes[(HttpCodes["Forbidden"] = 403)] = "Forbidden";
                HttpCodes[(HttpCodes["NotFound"] = 404)] = "NotFound";
                HttpCodes[(HttpCodes["MethodNotAllowed"] = 405)] =
                    "MethodNotAllowed";
                HttpCodes[(HttpCodes["NotAcceptable"] = 406)] = "NotAcceptable";
                HttpCodes[(HttpCodes["ProxyAuthenticationRequired"] = 407)] =
                    "ProxyAuthenticationRequired";
                HttpCodes[(HttpCodes["RequestTimeout"] = 408)] =
                    "RequestTimeout";
                HttpCodes[(HttpCodes["Conflict"] = 409)] = "Conflict";
                HttpCodes[(HttpCodes["Gone"] = 410)] = "Gone";
                HttpCodes[(HttpCodes["TooManyRequests"] = 429)] =
                    "TooManyRequests";
                HttpCodes[(HttpCodes["InternalServerError"] = 500)] =
                    "InternalServerError";
                HttpCodes[(HttpCodes["NotImplemented"] = 501)] =
                    "NotImplemented";
                HttpCodes[(HttpCodes["BadGateway"] = 502)] = "BadGateway";
                HttpCodes[(HttpCodes["ServiceUnavailable"] = 503)] =
                    "ServiceUnavailable";
                HttpCodes[(HttpCodes["GatewayTimeout"] = 504)] =
                    "GatewayTimeout";
            })((HttpCodes = exports.HttpCodes || (exports.HttpCodes = {})));
            var Headers;
            (function (Headers) {
                Headers["Accept"] = "accept";
                Headers["ContentType"] = "content-type";
            })((Headers = exports.Headers || (exports.Headers = {})));
            var MediaTypes;
            (function (MediaTypes) {
                MediaTypes["ApplicationJson"] = "application/json";
            })((MediaTypes = exports.MediaTypes || (exports.MediaTypes = {})));
            /**
             * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
             * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
             */
            function getProxyUrl(serverUrl) {
                let proxyUrl = pm.getProxyUrl(new URL(serverUrl));
                return proxyUrl ? proxyUrl.href : "";
            }
            exports.getProxyUrl = getProxyUrl;
            const HttpRedirectCodes = [
                HttpCodes.MovedPermanently,
                HttpCodes.ResourceMoved,
                HttpCodes.SeeOther,
                HttpCodes.TemporaryRedirect,
                HttpCodes.PermanentRedirect,
            ];
            const HttpResponseRetryCodes = [
                HttpCodes.BadGateway,
                HttpCodes.ServiceUnavailable,
                HttpCodes.GatewayTimeout,
            ];
            const RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
            const ExponentialBackoffCeiling = 10;
            const ExponentialBackoffTimeSlice = 5;
            class HttpClientError extends Error {
                constructor(message, statusCode) {
                    super(message);
                    this.name = "HttpClientError";
                    this.statusCode = statusCode;
                    Object.setPrototypeOf(this, HttpClientError.prototype);
                }
            }
            exports.HttpClientError = HttpClientError;
            class HttpClientResponse {
                constructor(message) {
                    this.message = message;
                }
                readBody() {
                    return new Promise(async (resolve, reject) => {
                        let output = Buffer.alloc(0);
                        this.message.on("data", (chunk) => {
                            output = Buffer.concat([output, chunk]);
                        });
                        this.message.on("end", () => {
                            resolve(output.toString());
                        });
                    });
                }
            }
            exports.HttpClientResponse = HttpClientResponse;
            function isHttps(requestUrl) {
                let parsedUrl = new URL(requestUrl);
                return parsedUrl.protocol === "https:";
            }
            exports.isHttps = isHttps;
            class HttpClient {
                constructor(userAgent, handlers, requestOptions) {
                    this._ignoreSslError = false;
                    this._allowRedirects = true;
                    this._allowRedirectDowngrade = false;
                    this._maxRedirects = 50;
                    this._allowRetries = false;
                    this._maxRetries = 1;
                    this._keepAlive = false;
                    this._disposed = false;
                    this.userAgent = userAgent;
                    this.handlers = handlers || [];
                    this.requestOptions = requestOptions;
                    if (requestOptions) {
                        if (requestOptions.ignoreSslError != null) {
                            this._ignoreSslError =
                                requestOptions.ignoreSslError;
                        }
                        this._socketTimeout = requestOptions.socketTimeout;
                        if (requestOptions.allowRedirects != null) {
                            this._allowRedirects =
                                requestOptions.allowRedirects;
                        }
                        if (requestOptions.allowRedirectDowngrade != null) {
                            this._allowRedirectDowngrade =
                                requestOptions.allowRedirectDowngrade;
                        }
                        if (requestOptions.maxRedirects != null) {
                            this._maxRedirects = Math.max(
                                requestOptions.maxRedirects,
                                0
                            );
                        }
                        if (requestOptions.keepAlive != null) {
                            this._keepAlive = requestOptions.keepAlive;
                        }
                        if (requestOptions.allowRetries != null) {
                            this._allowRetries = requestOptions.allowRetries;
                        }
                        if (requestOptions.maxRetries != null) {
                            this._maxRetries = requestOptions.maxRetries;
                        }
                    }
                }
                options(requestUrl, additionalHeaders) {
                    return this.request(
                        "OPTIONS",
                        requestUrl,
                        null,
                        additionalHeaders || {}
                    );
                }
                get(requestUrl, additionalHeaders) {
                    return this.request(
                        "GET",
                        requestUrl,
                        null,
                        additionalHeaders || {}
                    );
                }
                del(requestUrl, additionalHeaders) {
                    return this.request(
                        "DELETE",
                        requestUrl,
                        null,
                        additionalHeaders || {}
                    );
                }
                post(requestUrl, data, additionalHeaders) {
                    return this.request(
                        "POST",
                        requestUrl,
                        data,
                        additionalHeaders || {}
                    );
                }
                patch(requestUrl, data, additionalHeaders) {
                    return this.request(
                        "PATCH",
                        requestUrl,
                        data,
                        additionalHeaders || {}
                    );
                }
                put(requestUrl, data, additionalHeaders) {
                    return this.request(
                        "PUT",
                        requestUrl,
                        data,
                        additionalHeaders || {}
                    );
                }
                head(requestUrl, additionalHeaders) {
                    return this.request(
                        "HEAD",
                        requestUrl,
                        null,
                        additionalHeaders || {}
                    );
                }
                sendStream(verb, requestUrl, stream, additionalHeaders) {
                    return this.request(
                        verb,
                        requestUrl,
                        stream,
                        additionalHeaders
                    );
                }
                /**
                 * Gets a typed object from an endpoint
                 * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
                 */
                async getJson(requestUrl, additionalHeaders = {}) {
                    additionalHeaders[Headers.Accept] =
                        this._getExistingOrDefaultHeader(
                            additionalHeaders,
                            Headers.Accept,
                            MediaTypes.ApplicationJson
                        );
                    let res = await this.get(requestUrl, additionalHeaders);
                    return this._processResponse(res, this.requestOptions);
                }
                async postJson(requestUrl, obj, additionalHeaders = {}) {
                    let data = JSON.stringify(obj, null, 2);
                    additionalHeaders[Headers.Accept] =
                        this._getExistingOrDefaultHeader(
                            additionalHeaders,
                            Headers.Accept,
                            MediaTypes.ApplicationJson
                        );
                    additionalHeaders[Headers.ContentType] =
                        this._getExistingOrDefaultHeader(
                            additionalHeaders,
                            Headers.ContentType,
                            MediaTypes.ApplicationJson
                        );
                    let res = await this.post(
                        requestUrl,
                        data,
                        additionalHeaders
                    );
                    return this._processResponse(res, this.requestOptions);
                }
                async putJson(requestUrl, obj, additionalHeaders = {}) {
                    let data = JSON.stringify(obj, null, 2);
                    additionalHeaders[Headers.Accept] =
                        this._getExistingOrDefaultHeader(
                            additionalHeaders,
                            Headers.Accept,
                            MediaTypes.ApplicationJson
                        );
                    additionalHeaders[Headers.ContentType] =
                        this._getExistingOrDefaultHeader(
                            additionalHeaders,
                            Headers.ContentType,
                            MediaTypes.ApplicationJson
                        );
                    let res = await this.put(
                        requestUrl,
                        data,
                        additionalHeaders
                    );
                    return this._processResponse(res, this.requestOptions);
                }
                async patchJson(requestUrl, obj, additionalHeaders = {}) {
                    let data = JSON.stringify(obj, null, 2);
                    additionalHeaders[Headers.Accept] =
                        this._getExistingOrDefaultHeader(
                            additionalHeaders,
                            Headers.Accept,
                            MediaTypes.ApplicationJson
                        );
                    additionalHeaders[Headers.ContentType] =
                        this._getExistingOrDefaultHeader(
                            additionalHeaders,
                            Headers.ContentType,
                            MediaTypes.ApplicationJson
                        );
                    let res = await this.patch(
                        requestUrl,
                        data,
                        additionalHeaders
                    );
                    return this._processResponse(res, this.requestOptions);
                }
                /**
                 * Makes a raw http request.
                 * All other methods such as get, post, patch, and request ultimately call this.
                 * Prefer get, del, post and patch
                 */
                async request(verb, requestUrl, data, headers) {
                    if (this._disposed) {
                        throw new Error("Client has already been disposed.");
                    }
                    let parsedUrl = new URL(requestUrl);
                    let info = this._prepareRequest(verb, parsedUrl, headers);
                    // Only perform retries on reads since writes may not be idempotent.
                    let maxTries =
                        this._allowRetries &&
                        RetryableHttpVerbs.indexOf(verb) != -1
                            ? this._maxRetries + 1
                            : 1;
                    let numTries = 0;
                    let response;
                    while (numTries < maxTries) {
                        response = await this.requestRaw(info, data);
                        // Check if it's an authentication challenge
                        if (
                            response &&
                            response.message &&
                            response.message.statusCode ===
                                HttpCodes.Unauthorized
                        ) {
                            let authenticationHandler;
                            for (let i = 0; i < this.handlers.length; i++) {
                                if (
                                    this.handlers[i].canHandleAuthentication(
                                        response
                                    )
                                ) {
                                    authenticationHandler = this.handlers[i];
                                    break;
                                }
                            }
                            if (authenticationHandler) {
                                return authenticationHandler.handleAuthentication(
                                    this,
                                    info,
                                    data
                                );
                            } else {
                                // We have received an unauthorized response but have no handlers to handle it.
                                // Let the response return to the caller.
                                return response;
                            }
                        }
                        let redirectsRemaining = this._maxRedirects;
                        while (
                            HttpRedirectCodes.indexOf(
                                response.message.statusCode
                            ) != -1 &&
                            this._allowRedirects &&
                            redirectsRemaining > 0
                        ) {
                            const redirectUrl =
                                response.message.headers["location"];
                            if (!redirectUrl) {
                                // if there's no location to redirect to, we won't
                                break;
                            }
                            let parsedRedirectUrl = new URL(redirectUrl);
                            if (
                                parsedUrl.protocol == "https:" &&
                                parsedUrl.protocol !=
                                    parsedRedirectUrl.protocol &&
                                !this._allowRedirectDowngrade
                            ) {
                                throw new Error(
                                    "Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true."
                                );
                            }
                            // we need to finish reading the response before reassigning response
                            // which will leak the open socket.
                            await response.readBody();
                            // strip authorization header if redirected to a different hostname
                            if (
                                parsedRedirectUrl.hostname !==
                                parsedUrl.hostname
                            ) {
                                for (let header in headers) {
                                    // header names are case insensitive
                                    if (
                                        header.toLowerCase() === "authorization"
                                    ) {
                                        delete headers[header];
                                    }
                                }
                            }
                            // let's make the request with the new redirectUrl
                            info = this._prepareRequest(
                                verb,
                                parsedRedirectUrl,
                                headers
                            );
                            response = await this.requestRaw(info, data);
                            redirectsRemaining--;
                        }
                        if (
                            HttpResponseRetryCodes.indexOf(
                                response.message.statusCode
                            ) == -1
                        ) {
                            // If not a retry code, return immediately instead of retrying
                            return response;
                        }
                        numTries += 1;
                        if (numTries < maxTries) {
                            await response.readBody();
                            await this._performExponentialBackoff(numTries);
                        }
                    }
                    return response;
                }
                /**
                 * Needs to be called if keepAlive is set to true in request options.
                 */
                dispose() {
                    if (this._agent) {
                        this._agent.destroy();
                    }
                    this._disposed = true;
                }
                /**
                 * Raw request.
                 * @param info
                 * @param data
                 */
                requestRaw(info, data) {
                    return new Promise((resolve, reject) => {
                        let callbackForResult = function (err, res) {
                            if (err) {
                                reject(err);
                            }
                            resolve(res);
                        };
                        this.requestRawWithCallback(
                            info,
                            data,
                            callbackForResult
                        );
                    });
                }
                /**
                 * Raw request with callback.
                 * @param info
                 * @param data
                 * @param onResult
                 */
                requestRawWithCallback(info, data, onResult) {
                    let socket;
                    if (typeof data === "string") {
                        info.options.headers["Content-Length"] =
                            Buffer.byteLength(data, "utf8");
                    }
                    let callbackCalled = false;
                    let handleResult = (err, res) => {
                        if (!callbackCalled) {
                            callbackCalled = true;
                            onResult(err, res);
                        }
                    };
                    let req = info.httpModule.request(info.options, (msg) => {
                        let res = new HttpClientResponse(msg);
                        handleResult(null, res);
                    });
                    req.on("socket", (sock) => {
                        socket = sock;
                    });
                    // If we ever get disconnected, we want the socket to timeout eventually
                    req.setTimeout(this._socketTimeout || 3 * 60000, () => {
                        if (socket) {
                            socket.end();
                        }
                        handleResult(
                            new Error("Request timeout: " + info.options.path),
                            null
                        );
                    });
                    req.on("error", function (err) {
                        // err has statusCode property
                        // res should have headers
                        handleResult(err, null);
                    });
                    if (data && typeof data === "string") {
                        req.write(data, "utf8");
                    }
                    if (data && typeof data !== "string") {
                        data.on("close", function () {
                            req.end();
                        });
                        data.pipe(req);
                    } else {
                        req.end();
                    }
                }
                /**
                 * Gets an http agent. This function is useful when you need an http agent that handles
                 * routing through a proxy server - depending upon the url and proxy environment variables.
                 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
                 */
                getAgent(serverUrl) {
                    let parsedUrl = new URL(serverUrl);
                    return this._getAgent(parsedUrl);
                }
                _prepareRequest(method, requestUrl, headers) {
                    const info = {};
                    info.parsedUrl = requestUrl;
                    const usingSsl = info.parsedUrl.protocol === "https:";
                    info.httpModule = usingSsl ? https : http;
                    const defaultPort = usingSsl ? 443 : 80;
                    info.options = {};
                    info.options.host = info.parsedUrl.hostname;
                    info.options.port = info.parsedUrl.port
                        ? parseInt(info.parsedUrl.port)
                        : defaultPort;
                    info.options.path =
                        (info.parsedUrl.pathname || "") +
                        (info.parsedUrl.search || "");
                    info.options.method = method;
                    info.options.headers = this._mergeHeaders(headers);
                    if (this.userAgent != null) {
                        info.options.headers["user-agent"] = this.userAgent;
                    }
                    info.options.agent = this._getAgent(info.parsedUrl);
                    // gives handlers an opportunity to participate
                    if (this.handlers) {
                        this.handlers.forEach((handler) => {
                            handler.prepareRequest(info.options);
                        });
                    }
                    return info;
                }
                _mergeHeaders(headers) {
                    const lowercaseKeys = (obj) =>
                        Object.keys(obj).reduce(
                            (c, k) => ((c[k.toLowerCase()] = obj[k]), c),
                            {}
                        );
                    if (this.requestOptions && this.requestOptions.headers) {
                        return Object.assign(
                            {},
                            lowercaseKeys(this.requestOptions.headers),
                            lowercaseKeys(headers)
                        );
                    }
                    return lowercaseKeys(headers || {});
                }
                _getExistingOrDefaultHeader(
                    additionalHeaders,
                    header,
                    _default
                ) {
                    const lowercaseKeys = (obj) =>
                        Object.keys(obj).reduce(
                            (c, k) => ((c[k.toLowerCase()] = obj[k]), c),
                            {}
                        );
                    let clientHeader;
                    if (this.requestOptions && this.requestOptions.headers) {
                        clientHeader = lowercaseKeys(
                            this.requestOptions.headers
                        )[header];
                    }
                    return (
                        additionalHeaders[header] || clientHeader || _default
                    );
                }
                _getAgent(parsedUrl) {
                    let agent;
                    let proxyUrl = pm.getProxyUrl(parsedUrl);
                    let useProxy = proxyUrl && proxyUrl.hostname;
                    if (this._keepAlive && useProxy) {
                        agent = this._proxyAgent;
                    }
                    if (this._keepAlive && !useProxy) {
                        agent = this._agent;
                    }
                    // if agent is already assigned use that agent.
                    if (!!agent) {
                        return agent;
                    }
                    const usingSsl = parsedUrl.protocol === "https:";
                    let maxSockets = 100;
                    if (!!this.requestOptions) {
                        maxSockets =
                            this.requestOptions.maxSockets ||
                            http.globalAgent.maxSockets;
                    }
                    if (useProxy) {
                        // If using proxy, need tunnel
                        if (!tunnel) {
                            tunnel = __nccwpck_require__(4294);
                        }
                        const agentOptions = {
                            maxSockets: maxSockets,
                            keepAlive: this._keepAlive,
                            proxy: {
                                ...((proxyUrl.username ||
                                    proxyUrl.password) && {
                                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`,
                                }),
                                host: proxyUrl.hostname,
                                port: proxyUrl.port,
                            },
                        };
                        let tunnelAgent;
                        const overHttps = proxyUrl.protocol === "https:";
                        if (usingSsl) {
                            tunnelAgent = overHttps
                                ? tunnel.httpsOverHttps
                                : tunnel.httpsOverHttp;
                        } else {
                            tunnelAgent = overHttps
                                ? tunnel.httpOverHttps
                                : tunnel.httpOverHttp;
                        }
                        agent = tunnelAgent(agentOptions);
                        this._proxyAgent = agent;
                    }
                    // if reusing agent across request and tunneling agent isn't assigned create a new agent
                    if (this._keepAlive && !agent) {
                        const options = {
                            keepAlive: this._keepAlive,
                            maxSockets: maxSockets,
                        };
                        agent = usingSsl
                            ? new https.Agent(options)
                            : new http.Agent(options);
                        this._agent = agent;
                    }
                    // if not using private agent and tunnel agent isn't setup then use global agent
                    if (!agent) {
                        agent = usingSsl ? https.globalAgent : http.globalAgent;
                    }
                    if (usingSsl && this._ignoreSslError) {
                        // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
                        // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
                        // we have to cast it to any and change it directly
                        agent.options = Object.assign(agent.options || {}, {
                            rejectUnauthorized: false,
                        });
                    }
                    return agent;
                }
                _performExponentialBackoff(retryNumber) {
                    retryNumber = Math.min(
                        ExponentialBackoffCeiling,
                        retryNumber
                    );
                    const ms =
                        ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
                    return new Promise((resolve) =>
                        setTimeout(() => resolve(), ms)
                    );
                }
                static dateTimeDeserializer(key, value) {
                    if (typeof value === "string") {
                        let a = new Date(value);
                        if (!isNaN(a.valueOf())) {
                            return a;
                        }
                    }
                    return value;
                }
                async _processResponse(res, options) {
                    return new Promise(async (resolve, reject) => {
                        const statusCode = res.message.statusCode;
                        const response = {
                            statusCode: statusCode,
                            result: null,
                            headers: {},
                        };
                        // not found leads to null obj returned
                        if (statusCode == HttpCodes.NotFound) {
                            resolve(response);
                        }
                        let obj;
                        let contents;
                        // get the result from the body
                        try {
                            contents = await res.readBody();
                            if (contents && contents.length > 0) {
                                if (options && options.deserializeDates) {
                                    obj = JSON.parse(
                                        contents,
                                        HttpClient.dateTimeDeserializer
                                    );
                                } else {
                                    obj = JSON.parse(contents);
                                }
                                response.result = obj;
                            }
                            response.headers = res.message.headers;
                        } catch (err) {
                            // Invalid resource (contents not json);  leaving result obj null
                        }
                        // note that 3xx redirects are handled by the http layer.
                        if (statusCode > 299) {
                            let msg;
                            // if exception/error in body, attempt to get better error
                            if (obj && obj.message) {
                                msg = obj.message;
                            } else if (contents && contents.length > 0) {
                                // it may be the case that the exception is in the body message as string
                                msg = contents;
                            } else {
                                msg = "Failed request: (" + statusCode + ")";
                            }
                            let err = new HttpClientError(msg, statusCode);
                            err.result = response.result;
                            reject(err);
                        } else {
                            resolve(response);
                        }
                    });
                }
            }
            exports.HttpClient = HttpClient;

            /***/
        },

        /***/ 6443: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            function getProxyUrl(reqUrl) {
                let usingSsl = reqUrl.protocol === "https:";
                let proxyUrl;
                if (checkBypass(reqUrl)) {
                    return proxyUrl;
                }
                let proxyVar;
                if (usingSsl) {
                    proxyVar =
                        process.env["https_proxy"] ||
                        process.env["HTTPS_PROXY"];
                } else {
                    proxyVar =
                        process.env["http_proxy"] || process.env["HTTP_PROXY"];
                }
                if (proxyVar) {
                    proxyUrl = new URL(proxyVar);
                }
                return proxyUrl;
            }
            exports.getProxyUrl = getProxyUrl;
            function checkBypass(reqUrl) {
                if (!reqUrl.hostname) {
                    return false;
                }
                let noProxy =
                    process.env["no_proxy"] || process.env["NO_PROXY"] || "";
                if (!noProxy) {
                    return false;
                }
                // Determine the request port
                let reqPort;
                if (reqUrl.port) {
                    reqPort = Number(reqUrl.port);
                } else if (reqUrl.protocol === "http:") {
                    reqPort = 80;
                } else if (reqUrl.protocol === "https:") {
                    reqPort = 443;
                }
                // Format the request hostname and hostname with port
                let upperReqHosts = [reqUrl.hostname.toUpperCase()];
                if (typeof reqPort === "number") {
                    upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
                }
                // Compare request host against noproxy
                for (let upperNoProxyItem of noProxy
                    .split(",")
                    .map((x) => x.trim().toUpperCase())
                    .filter((x) => x)) {
                    if (upperReqHosts.some((x) => x === upperNoProxyItem)) {
                        return true;
                    }
                }
                return false;
            }
            exports.checkBypass = checkBypass;

            /***/
        },

        /***/ 6492: /***/ function (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) {
            "use strict";

            var __classPrivateFieldSet =
                (this && this.__classPrivateFieldSet) ||
                function (receiver, state, value, kind, f) {
                    if (kind === "m")
                        throw new TypeError("Private method is not writable");
                    if (kind === "a" && !f)
                        throw new TypeError(
                            "Private accessor was defined without a setter"
                        );
                    if (
                        typeof state === "function"
                            ? receiver !== state || !f
                            : !state.has(receiver)
                    )
                        throw new TypeError(
                            "Cannot write private member to an object whose class did not declare it"
                        );
                    return (
                        kind === "a"
                            ? f.call(receiver, value)
                            : f
                            ? (f.value = value)
                            : state.set(receiver, value),
                        value
                    );
                };
            var __classPrivateFieldGet =
                (this && this.__classPrivateFieldGet) ||
                function (receiver, state, kind, f) {
                    if (kind === "a" && !f)
                        throw new TypeError(
                            "Private accessor was defined without a getter"
                        );
                    if (
                        typeof state === "function"
                            ? receiver !== state || !f
                            : !state.has(receiver)
                    )
                        throw new TypeError(
                            "Cannot read private member from an object whose class did not declare it"
                        );
                    return kind === "m"
                        ? f
                        : kind === "a"
                        ? f.call(receiver)
                        : f
                        ? f.value
                        : state.get(receiver);
                };
            var _Client_auth, _Client_logLevel, _Client_logger, _Client_got;
            Object.defineProperty(exports, "__esModule", { value: true });
            const url_1 = __nccwpck_require__(8835);
            const logging_1 = __nccwpck_require__(2096);
            const errors_1 = __nccwpck_require__(8259);
            const helpers_1 = __nccwpck_require__(5682);
            const api_endpoints_1 = __nccwpck_require__(1605);
            const got_1 = __nccwpck_require__(3061);
            class Client {
                constructor(options) {
                    var _a, _b, _c, _d, _e;
                    _Client_auth.set(this, void 0);
                    _Client_logLevel.set(this, void 0);
                    _Client_logger.set(this, void 0);
                    _Client_got.set(this, void 0);
                    /*
                     * Notion API endpoints
                     */
                    this.blocks = {
                        children: {
                            /**
                             * Append block children
                             */
                            append: (args) => {
                                return this.request({
                                    path: api_endpoints_1.blocksChildrenAppend.path(
                                        args
                                    ),
                                    method: api_endpoints_1.blocksChildrenAppend
                                        .method,
                                    query: helpers_1.pick(
                                        args,
                                        api_endpoints_1.blocksChildrenAppend
                                            .queryParams
                                    ),
                                    body: helpers_1.pick(
                                        args,
                                        api_endpoints_1.blocksChildrenAppend
                                            .bodyParams
                                    ),
                                    auth:
                                        args === null || args === void 0
                                            ? void 0
                                            : args.auth,
                                });
                            },
                            /**
                             * Retrieve block children
                             */
                            list: (args) => {
                                return this.request({
                                    path: api_endpoints_1.blocksChildrenList.path(
                                        args
                                    ),
                                    method: api_endpoints_1.blocksChildrenList
                                        .method,
                                    query: helpers_1.pick(
                                        args,
                                        api_endpoints_1.blocksChildrenList
                                            .queryParams
                                    ),
                                    body: helpers_1.pick(
                                        args,
                                        api_endpoints_1.blocksChildrenList
                                            .bodyParams
                                    ),
                                    auth:
                                        args === null || args === void 0
                                            ? void 0
                                            : args.auth,
                                });
                            },
                        },
                    };
                    this.databases = {
                        /**
                         * List databases
                         *
                         * @deprecated Please use `search`
                         */
                        list: (args = {}) => {
                            return this.request({
                                path: api_endpoints_1.databasesList.path(),
                                method: api_endpoints_1.databasesList.method,
                                query: helpers_1.pick(
                                    args,
                                    api_endpoints_1.databasesList.queryParams
                                ),
                                body: helpers_1.pick(
                                    args,
                                    api_endpoints_1.databasesList.bodyParams
                                ),
                                auth:
                                    args === null || args === void 0
                                        ? void 0
                                        : args.auth,
                            });
                        },
                        /**
                         * Retrieve a database
                         */
                        retrieve: (args) => {
                            return this.request({
                                path: api_endpoints_1.databasesRetrieve.path(
                                    args
                                ),
                                method: api_endpoints_1.databasesRetrieve
                                    .method,
                                query: helpers_1.pick(
                                    args,
                                    api_endpoints_1.databasesRetrieve
                                        .queryParams
                                ),
                                body: helpers_1.pick(
                                    args,
                                    api_endpoints_1.databasesRetrieve.bodyParams
                                ),
                                auth:
                                    args === null || args === void 0
                                        ? void 0
                                        : args.auth,
                            });
                        },
                        /**
                         * Query a database
                         */
                        query: (args) => {
                            return this.request({
                                path: api_endpoints_1.databasesQuery.path(args),
                                method: api_endpoints_1.databasesQuery.method,
                                query: helpers_1.pick(
                                    args,
                                    api_endpoints_1.databasesQuery.queryParams
                                ),
                                body: helpers_1.pick(
                                    args,
                                    api_endpoints_1.databasesQuery.bodyParams
                                ),
                                auth:
                                    args === null || args === void 0
                                        ? void 0
                                        : args.auth,
                            });
                        },
                    };
                    this.pages = {
                        /**
                         * Create a page
                         */
                        create: (args) => {
                            return this.request({
                                path: api_endpoints_1.pagesCreate.path(),
                                method: api_endpoints_1.pagesCreate.method,
                                query: helpers_1.pick(
                                    args,
                                    api_endpoints_1.pagesCreate.queryParams
                                ),
                                body: helpers_1.pick(
                                    args,
                                    api_endpoints_1.pagesCreate.bodyParams
                                ),
                                auth:
                                    args === null || args === void 0
                                        ? void 0
                                        : args.auth,
                            });
                        },
                        /**
                         * Retrieve a page
                         */
                        retrieve: (args) => {
                            return this.request({
                                path: api_endpoints_1.pagesRetrieve.path(args),
                                method: api_endpoints_1.pagesRetrieve.method,
                                query: helpers_1.pick(
                                    args,
                                    api_endpoints_1.pagesRetrieve.queryParams
                                ),
                                body: helpers_1.pick(
                                    args,
                                    api_endpoints_1.pagesRetrieve.bodyParams
                                ),
                                auth:
                                    args === null || args === void 0
                                        ? void 0
                                        : args.auth,
                            });
                        },
                        /**
                         * Update page properties
                         */
                        update: (args) => {
                            return this.request({
                                path: api_endpoints_1.pagesUpdate.path(args),
                                method: api_endpoints_1.pagesUpdate.method,
                                query: helpers_1.pick(
                                    args,
                                    api_endpoints_1.pagesUpdate.queryParams
                                ),
                                body: helpers_1.pick(
                                    args,
                                    api_endpoints_1.pagesUpdate.bodyParams
                                ),
                                auth:
                                    args === null || args === void 0
                                        ? void 0
                                        : args.auth,
                            });
                        },
                    };
                    this.users = {
                        /**
                         * Retrieve a user
                         */
                        retrieve: (args) => {
                            return this.request({
                                path: api_endpoints_1.usersRetrieve.path(args),
                                method: api_endpoints_1.usersRetrieve.method,
                                query: helpers_1.pick(
                                    args,
                                    api_endpoints_1.usersRetrieve.queryParams
                                ),
                                body: helpers_1.pick(
                                    args,
                                    api_endpoints_1.usersRetrieve.bodyParams
                                ),
                                auth:
                                    args === null || args === void 0
                                        ? void 0
                                        : args.auth,
                            });
                        },
                        /**
                         * List all users
                         */
                        list: (args = {}) => {
                            return this.request({
                                path: api_endpoints_1.usersList.path(),
                                method: api_endpoints_1.usersList.method,
                                query: helpers_1.pick(
                                    args,
                                    api_endpoints_1.usersList.queryParams
                                ),
                                body: helpers_1.pick(
                                    args,
                                    api_endpoints_1.usersList.bodyParams
                                ),
                                auth:
                                    args === null || args === void 0
                                        ? void 0
                                        : args.auth,
                            });
                        },
                    };
                    __classPrivateFieldSet(
                        this,
                        _Client_auth,
                        options === null || options === void 0
                            ? void 0
                            : options.auth,
                        "f"
                    );
                    __classPrivateFieldSet(
                        this,
                        _Client_logLevel,
                        (_a =
                            options === null || options === void 0
                                ? void 0
                                : options.logLevel) !== null && _a !== void 0
                            ? _a
                            : logging_1.LogLevel.WARN,
                        "f"
                    );
                    __classPrivateFieldSet(
                        this,
                        _Client_logger,
                        (_b =
                            options === null || options === void 0
                                ? void 0
                                : options.logger) !== null && _b !== void 0
                            ? _b
                            : logging_1.makeConsoleLogger(
                                  this.constructor.name
                              ),
                        "f"
                    );
                    const prefixUrl =
                        ((_c =
                            options === null || options === void 0
                                ? void 0
                                : options.baseUrl) !== null && _c !== void 0
                            ? _c
                            : "https://api.notion.com") + "/v1/";
                    const timeout =
                        (_d =
                            options === null || options === void 0
                                ? void 0
                                : options.timeoutMs) !== null && _d !== void 0
                            ? _d
                            : 60000;
                    const notionVersion =
                        (_e =
                            options === null || options === void 0
                                ? void 0
                                : options.notionVersion) !== null &&
                        _e !== void 0
                            ? _e
                            : Client.defaultNotionVersion;
                    __classPrivateFieldSet(
                        this,
                        _Client_got,
                        got_1.default.extend({
                            prefixUrl,
                            timeout,
                            headers: {
                                "Notion-Version": notionVersion,
                                // TODO: update with format appropriate for telemetry, use version from package.json
                                "user-agent": "notionhq-client/0.1.0",
                            },
                            retry: 0,
                            agent: makeAgentOption(
                                prefixUrl,
                                options === null || options === void 0
                                    ? void 0
                                    : options.agent
                            ),
                        }),
                        "f"
                    );
                }
                /**
                 * Sends a request.
                 *
                 * @param path
                 * @param method
                 * @param query
                 * @param body
                 * @returns
                 */
                async request({ path, method, query, body, auth }) {
                    this.log(logging_1.LogLevel.INFO, "request start", {
                        method,
                        path,
                    });
                    // If the body is empty, don't send the body in the HTTP request
                    const json =
                        body !== undefined && Object.entries(body).length === 0
                            ? undefined
                            : body;
                    try {
                        const response = await __classPrivateFieldGet(
                            this,
                            _Client_got,
                            "f"
                        )
                            .call(this, path, {
                                method,
                                searchParams: query,
                                json,
                                headers: this.authAsHeaders(auth),
                            })
                            .json();
                        this.log(logging_1.LogLevel.INFO, `request success`, {
                            method,
                            path,
                        });
                        return response;
                    } catch (error) {
                        // Build an error of a known type, otherwise throw unexpected errors
                        const requestError = errors_1.buildRequestError(error);
                        if (requestError === undefined) {
                            throw error;
                        }
                        this.log(logging_1.LogLevel.WARN, `request fail`, {
                            code: requestError.code,
                            message: requestError.message,
                        });
                        if (
                            errors_1.HTTPResponseError.isHTTPResponseError(
                                requestError
                            )
                        ) {
                            // The response body may contain sensitive information so it is logged separately at the DEBUG level
                            this.log(
                                logging_1.LogLevel.DEBUG,
                                `failed response body`,
                                {
                                    body: requestError.body,
                                }
                            );
                        }
                        // Throw as a known error type
                        throw requestError;
                    }
                }
                /**
                 * Search
                 */
                search(args) {
                    return this.request({
                        path: api_endpoints_1.search.path(),
                        method: api_endpoints_1.search.method,
                        query: helpers_1.pick(
                            args,
                            api_endpoints_1.search.queryParams
                        ),
                        body: helpers_1.pick(
                            args,
                            api_endpoints_1.search.bodyParams
                        ),
                        auth:
                            args === null || args === void 0
                                ? void 0
                                : args.auth,
                    });
                }
                /**
                 * Emits a log message to the console.
                 *
                 * @param level The level for this message
                 * @param args Arguments to send to the console
                 */
                log(level, message, extraInfo) {
                    if (
                        logging_1.logLevelSeverity(level) >=
                        logging_1.logLevelSeverity(
                            __classPrivateFieldGet(this, _Client_logLevel, "f")
                        )
                    ) {
                        __classPrivateFieldGet(this, _Client_logger, "f").call(
                            this,
                            level,
                            message,
                            extraInfo
                        );
                    }
                }
                /**
                 * Transforms an API key or access token into a headers object suitable for an HTTP request.
                 *
                 * This method uses the instance's value as the default when the input is undefined. If neither are defined, it returns
                 * an empty object
                 *
                 * @param auth API key or access token
                 * @returns headers key-value object
                 */
                authAsHeaders(auth) {
                    const headers = {};
                    const authHeaderValue =
                        auth !== null && auth !== void 0
                            ? auth
                            : __classPrivateFieldGet(this, _Client_auth, "f");
                    if (authHeaderValue !== undefined) {
                        headers["authorization"] = `Bearer ${authHeaderValue}`;
                    }
                    return headers;
                }
            }
            exports.default = Client;
            (_Client_auth = new WeakMap()),
                (_Client_logLevel = new WeakMap()),
                (_Client_logger = new WeakMap()),
                (_Client_got = new WeakMap());
            Client.defaultNotionVersion = "2021-05-13";
            /*
             * Helper functions
             */
            function makeAgentOption(prefixUrl, agent) {
                if (agent === undefined) {
                    return undefined;
                }
                return {
                    [selectProtocol(prefixUrl)]: agent,
                };
            }
            function selectProtocol(prefixUrl) {
                const url = new url_1.URL(prefixUrl);
                if (url.protocol === "https:") {
                    return "https";
                } else if (url.protocol === "http:") {
                    return "http";
                }
                throw new TypeError(
                    `baseUrl option must begin with "https://" or "http://"`
                );
            }
            //# sourceMappingURL=Client.js.map

            /***/
        },

        /***/ 1605: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            /* eslint-disable @typescript-eslint/no-empty-interface */
            /**
             * Notion API Endpoints
             *
             * This file contains metadata about each of the API endpoints such as the HTTP method, the parameters, and the types.
             * In the future, the contents of this file will be generated from an API definition.
             */
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.search =
                exports.usersList =
                exports.usersRetrieve =
                exports.pagesUpdate =
                exports.pagesRetrieve =
                exports.pagesCreate =
                exports.databasesRetrieve =
                exports.databasesQuery =
                exports.databasesList =
                exports.blocksChildrenList =
                exports.blocksChildrenAppend =
                    void 0;
            exports.blocksChildrenAppend = {
                method: "patch",
                pathParams: ["block_id"],
                queryParams: [],
                bodyParams: ["children"],
                path: (p) => `blocks/${p.block_id}/children`,
            };
            exports.blocksChildrenList = {
                method: "get",
                pathParams: ["block_id"],
                queryParams: ["start_cursor", "page_size"],
                bodyParams: [],
                path: (p) => `blocks/${p.block_id}/children`,
            };
            exports.databasesList = {
                method: "get",
                pathParams: [],
                queryParams: ["start_cursor", "page_size"],
                bodyParams: [],
                path: () => `databases`,
            };
            exports.databasesQuery = {
                method: "post",
                pathParams: ["database_id"],
                queryParams: [],
                bodyParams: ["filter", "sorts", "start_cursor", "page_size"],
                path: (p) => `databases/${p.database_id}/query`,
            };
            exports.databasesRetrieve = {
                method: "get",
                pathParams: ["database_id"],
                queryParams: [],
                bodyParams: [],
                path: (p) => `databases/${p.database_id}`,
            };
            exports.pagesCreate = {
                method: "post",
                pathParams: [],
                queryParams: [],
                bodyParams: ["parent", "properties", "children"],
                path: () => `pages`,
            };
            exports.pagesRetrieve = {
                method: "get",
                pathParams: ["page_id"],
                queryParams: [],
                bodyParams: [],
                path: (p) => `pages/${p.page_id}`,
            };
            exports.pagesUpdate = {
                method: "patch",
                pathParams: ["page_id"],
                queryParams: [],
                bodyParams: ["properties"],
                path: (p) => `pages/${p.page_id}`,
            };
            exports.usersRetrieve = {
                method: "get",
                pathParams: ["user_id"],
                queryParams: [],
                bodyParams: [],
                path: (p) => `users/${p.user_id}`,
            };
            exports.usersList = {
                method: "get",
                pathParams: [],
                queryParams: ["start_cursor", "page_size"],
                bodyParams: [],
                path: () => `users`,
            };
            exports.search = {
                method: "post",
                pathParams: [],
                queryParams: [],
                bodyParams: [
                    "query",
                    "sort",
                    "filter",
                    "start_cursor",
                    "page_size",
                ],
                path: () => `search`,
            };
            //# sourceMappingURL=api-endpoints.js.map

            /***/
        },

        /***/ 8259: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            exports.buildRequestError =
                exports.APIResponseError =
                exports.APIErrorCode =
                exports.HTTPResponseError =
                exports.RequestTimeoutError =
                    void 0;
            const helpers_1 = __nccwpck_require__(5682);
            class RequestTimeoutError extends Error {
                constructor(message = "Request to Notion API has timed out") {
                    super(message);
                    this.code = "notionhq_client_request_timeout";
                    this.name = "RequestTimeoutError";
                }
                static isRequestTimeoutError(error) {
                    return (
                        error instanceof Error &&
                        error.name === "RequestTimeoutError" &&
                        "code" in error &&
                        error["code"] === RequestTimeoutError.prototype.code
                    );
                }
            }
            exports.RequestTimeoutError = RequestTimeoutError;
            class HTTPResponseError extends Error {
                constructor(response, message) {
                    super(
                        message !== null && message !== void 0
                            ? message
                            : `Request to Notion API failed with status: ${response.statusCode}`
                    );
                    this.code = "notionhq_client_response_error";
                    this.name = "HTTPResponseError";
                    this.status = response.statusCode;
                    this.headers = response.headers;
                    this.body = response.rawBody.toString();
                }
                static isHTTPResponseError(error) {
                    return (
                        error instanceof Error &&
                        error.name === "HTTPResponseError" &&
                        "code" in error &&
                        error["code"] === HTTPResponseError.prototype.code
                    );
                }
            }
            exports.HTTPResponseError = HTTPResponseError;
            /**
             * Error codes for responses from the API.
             */
            var APIErrorCode;
            (function (APIErrorCode) {
                APIErrorCode["Unauthorized"] = "unauthorized";
                APIErrorCode["RestrictedResource"] = "restricted_resource";
                APIErrorCode["ObjectNotFound"] = "object_not_found";
                APIErrorCode["RateLimited"] = "rate_limited";
                APIErrorCode["InvalidJSON"] = "invalid_json";
                APIErrorCode["InvalidRequestURL"] = "invalid_request_url";
                APIErrorCode["InvalidRequest"] = "invalid_request";
                APIErrorCode["ValidationError"] = "validation_error";
                APIErrorCode["ConflictError"] = "conflict_error";
                APIErrorCode["InternalServerError"] = "internal_server_error";
                APIErrorCode["ServiceUnavailable"] = "service_unavailable";
            })(
                (APIErrorCode =
                    exports.APIErrorCode || (exports.APIErrorCode = {}))
            );
            /**
             * A response from the API indicating a problem.
             *
             * Use the `code` property to handle various kinds of errors. All its possible values are in `APIErrorCode`.
             */
            class APIResponseError extends HTTPResponseError {
                constructor(response, body) {
                    super(response, body.message);
                    this.name = "APIResponseError";
                    this.code = body.code;
                }
                static isAPIResponseError(error) {
                    return (
                        error instanceof Error &&
                        error.name === "APIResponseError" &&
                        "code" in error &&
                        isAPIErrorCode(error["code"])
                    );
                }
            }
            exports.APIResponseError = APIResponseError;
            function buildRequestError(error) {
                if (isGotTimeoutError(error)) {
                    return new RequestTimeoutError();
                }
                if (isGotHTTPError(error)) {
                    const apiErrorResponseBody = parseAPIErrorResponseBody(
                        error.response.body
                    );
                    if (apiErrorResponseBody !== undefined) {
                        return new APIResponseError(
                            error.response,
                            apiErrorResponseBody
                        );
                    }
                    return new HTTPResponseError(error.response);
                }
                return;
            }
            exports.buildRequestError = buildRequestError;
            function parseAPIErrorResponseBody(body) {
                if (typeof body !== "string") {
                    return;
                }
                let parsed;
                try {
                    parsed = JSON.parse(body);
                } catch (parseError) {
                    return;
                }
                if (
                    !helpers_1.isObject(parsed) ||
                    typeof parsed["message"] !== "string" ||
                    !isAPIErrorCode(parsed["code"])
                ) {
                    return;
                }
                return {
                    ...parsed,
                    code: parsed["code"],
                    message: parsed["message"],
                };
            }
            /*
             * Type guards
             */
            function isAPIErrorCode(code) {
                return (
                    typeof code === "string" &&
                    Object.values(APIErrorCode).includes(code)
                );
            }
            function isGotTimeoutError(error) {
                return (
                    error instanceof Error &&
                    error.name === "TimeoutError" &&
                    "event" in error &&
                    typeof error["event"] === "string" &&
                    helpers_1.isObject(error["request"]) &&
                    helpers_1.isObject(error["timings"])
                );
            }
            function isGotHTTPError(error) {
                return (
                    error instanceof Error &&
                    error.name === "HTTPError" &&
                    "request" in error &&
                    helpers_1.isObject(error["request"]) &&
                    "response" in error &&
                    helpers_1.isObject(error["response"]) &&
                    "timings" in error &&
                    helpers_1.isObject(error["timings"])
                );
            }
            //# sourceMappingURL=errors.js.map

            /***/
        },

        /***/ 5682: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            exports.isObject = exports.pick = exports.assertNever = void 0;
            /**
             * Utility for enforcing exhaustiveness checks in the type system.
             *
             * @see https://basarat.gitbook.io/typescript/type-system/discriminated-unions#throw-in-exhaustive-checks
             *
             * @param _x The variable with no remaining values
             */
            function assertNever(_x) {
                throw new Error("Unexpected value. Should have been never.");
            }
            exports.assertNever = assertNever;
            function pick(base, keys) {
                const entries = keys.map((key) => [
                    key,
                    base === null || base === void 0 ? void 0 : base[key],
                ]);
                return Object.fromEntries(entries);
            }
            exports.pick = pick;
            function isObject(o) {
                return typeof o === "object" && o !== null;
            }
            exports.isObject = isObject;
            //# sourceMappingURL=helpers.js.map

            /***/
        },

        /***/ 324: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            exports.RequestTimeoutError =
                exports.HTTPResponseError =
                exports.APIResponseError =
                exports.APIErrorCode =
                exports.LogLevel =
                exports.Client =
                    void 0;
            var Client_1 = __nccwpck_require__(6492);
            Object.defineProperty(exports, "Client", {
                enumerable: true,
                get: function () {
                    return Client_1.default;
                },
            });
            var logging_1 = __nccwpck_require__(2096);
            Object.defineProperty(exports, "LogLevel", {
                enumerable: true,
                get: function () {
                    return logging_1.LogLevel;
                },
            });
            var errors_1 = __nccwpck_require__(8259);
            Object.defineProperty(exports, "APIErrorCode", {
                enumerable: true,
                get: function () {
                    return errors_1.APIErrorCode;
                },
            });
            Object.defineProperty(exports, "APIResponseError", {
                enumerable: true,
                get: function () {
                    return errors_1.APIResponseError;
                },
            });
            Object.defineProperty(exports, "HTTPResponseError", {
                enumerable: true,
                get: function () {
                    return errors_1.HTTPResponseError;
                },
            });
            Object.defineProperty(exports, "RequestTimeoutError", {
                enumerable: true,
                get: function () {
                    return errors_1.RequestTimeoutError;
                },
            });
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ 2096: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            exports.logLevelSeverity =
                exports.makeConsoleLogger =
                exports.LogLevel =
                    void 0;
            const helpers_1 = __nccwpck_require__(5682);
            var LogLevel;
            (function (LogLevel) {
                LogLevel["DEBUG"] = "debug";
                LogLevel["INFO"] = "info";
                LogLevel["WARN"] = "warn";
                LogLevel["ERROR"] = "error";
            })((LogLevel = exports.LogLevel || (exports.LogLevel = {})));
            function makeConsoleLogger(name) {
                return (level, message, extraInfo) => {
                    console[level](`${name} ${level}:`, message, extraInfo);
                };
            }
            exports.makeConsoleLogger = makeConsoleLogger;
            /**
             * Transforms a log level into a comparable (numerical) value ordered by severity.
             */
            function logLevelSeverity(level) {
                switch (level) {
                    case LogLevel.DEBUG:
                        return 20;
                    case LogLevel.INFO:
                        return 40;
                    case LogLevel.WARN:
                        return 60;
                    case LogLevel.ERROR:
                        return 80;
                    default:
                        return helpers_1.assertNever(level);
                }
            }
            exports.logLevelSeverity = logLevelSeverity;
            //# sourceMappingURL=logging.js.map

            /***/
        },

        /***/ 334: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });

            const REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
            const REGEX_IS_INSTALLATION = /^ghs_/;
            const REGEX_IS_USER_TO_SERVER = /^ghu_/;
            async function auth(token) {
                const isApp = token.split(/\./).length === 3;
                const isInstallation =
                    REGEX_IS_INSTALLATION_LEGACY.test(token) ||
                    REGEX_IS_INSTALLATION.test(token);
                const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
                const tokenType = isApp
                    ? "app"
                    : isInstallation
                    ? "installation"
                    : isUserToServer
                    ? "user-to-server"
                    : "oauth";
                return {
                    type: "token",
                    token: token,
                    tokenType,
                };
            }

            /**
             * Prefix token for usage in the Authorization header
             *
             * @param token OAuth token or JSON Web Token
             */
            function withAuthorizationPrefix(token) {
                if (token.split(/\./).length === 3) {
                    return `bearer ${token}`;
                }

                return `token ${token}`;
            }

            async function hook(token, request, route, parameters) {
                const endpoint = request.endpoint.merge(route, parameters);
                endpoint.headers.authorization = withAuthorizationPrefix(token);
                return request(endpoint);
            }

            const createTokenAuth = function createTokenAuth(token) {
                if (!token) {
                    throw new Error(
                        "[@octokit/auth-token] No token passed to createTokenAuth"
                    );
                }

                if (typeof token !== "string") {
                    throw new Error(
                        "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
                    );
                }

                token = token.replace(/^(token|bearer) +/i, "");
                return Object.assign(auth.bind(null, token), {
                    hook: hook.bind(null, token),
                });
            };

            exports.createTokenAuth = createTokenAuth;
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ 6762: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });

            var universalUserAgent = __nccwpck_require__(5030);
            var beforeAfterHook = __nccwpck_require__(3682);
            var request = __nccwpck_require__(6234);
            var graphql = __nccwpck_require__(8467);
            var authToken = __nccwpck_require__(334);

            function _objectWithoutPropertiesLoose(source, excluded) {
                if (source == null) return {};
                var target = {};
                var sourceKeys = Object.keys(source);
                var key, i;

                for (i = 0; i < sourceKeys.length; i++) {
                    key = sourceKeys[i];
                    if (excluded.indexOf(key) >= 0) continue;
                    target[key] = source[key];
                }

                return target;
            }

            function _objectWithoutProperties(source, excluded) {
                if (source == null) return {};

                var target = _objectWithoutPropertiesLoose(source, excluded);

                var key, i;

                if (Object.getOwnPropertySymbols) {
                    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

                    for (i = 0; i < sourceSymbolKeys.length; i++) {
                        key = sourceSymbolKeys[i];
                        if (excluded.indexOf(key) >= 0) continue;
                        if (
                            !Object.prototype.propertyIsEnumerable.call(
                                source,
                                key
                            )
                        )
                            continue;
                        target[key] = source[key];
                    }
                }

                return target;
            }

            const VERSION = "3.5.1";

            const _excluded = ["authStrategy"];
            class Octokit {
                constructor(options = {}) {
                    const hook = new beforeAfterHook.Collection();
                    const requestDefaults = {
                        baseUrl: request.request.endpoint.DEFAULTS.baseUrl,
                        headers: {},
                        request: Object.assign({}, options.request, {
                            // @ts-ignore internal usage only, no need to type
                            hook: hook.bind(null, "request"),
                        }),
                        mediaType: {
                            previews: [],
                            format: "",
                        },
                    }; // prepend default user agent with `options.userAgent` if set

                    requestDefaults.headers["user-agent"] = [
                        options.userAgent,
                        `octokit-core.js/${VERSION} ${universalUserAgent.getUserAgent()}`,
                    ]
                        .filter(Boolean)
                        .join(" ");

                    if (options.baseUrl) {
                        requestDefaults.baseUrl = options.baseUrl;
                    }

                    if (options.previews) {
                        requestDefaults.mediaType.previews = options.previews;
                    }

                    if (options.timeZone) {
                        requestDefaults.headers["time-zone"] = options.timeZone;
                    }

                    this.request = request.request.defaults(requestDefaults);
                    this.graphql = graphql
                        .withCustomRequest(this.request)
                        .defaults(requestDefaults);
                    this.log = Object.assign(
                        {
                            debug: () => {},
                            info: () => {},
                            warn: console.warn.bind(console),
                            error: console.error.bind(console),
                        },
                        options.log
                    );
                    this.hook = hook; // (1) If neither `options.authStrategy` nor `options.auth` are set, the `octokit` instance
                    //     is unauthenticated. The `this.auth()` method is a no-op and no request hook is registered.
                    // (2) If only `options.auth` is set, use the default token authentication strategy.
                    // (3) If `options.authStrategy` is set then use it and pass in `options.auth`. Always pass own request as many strategies accept a custom request instance.
                    // TODO: type `options.auth` based on `options.authStrategy`.

                    if (!options.authStrategy) {
                        if (!options.auth) {
                            // (1)
                            this.auth = async () => ({
                                type: "unauthenticated",
                            });
                        } else {
                            // (2)
                            const auth = authToken.createTokenAuth(
                                options.auth
                            ); // @ts-ignore  ¯\_(ツ)_/¯

                            hook.wrap("request", auth.hook);
                            this.auth = auth;
                        }
                    } else {
                        const { authStrategy } = options,
                            otherOptions = _objectWithoutProperties(
                                options,
                                _excluded
                            );

                        const auth = authStrategy(
                            Object.assign(
                                {
                                    request: this.request,
                                    log: this.log,
                                    // we pass the current octokit instance as well as its constructor options
                                    // to allow for authentication strategies that return a new octokit instance
                                    // that shares the same internal state as the current one. The original
                                    // requirement for this was the "event-octokit" authentication strategy
                                    // of https://github.com/probot/octokit-auth-probot.
                                    octokit: this,
                                    octokitOptions: otherOptions,
                                },
                                options.auth
                            )
                        ); // @ts-ignore  ¯\_(ツ)_/¯

                        hook.wrap("request", auth.hook);
                        this.auth = auth;
                    } // apply plugins
                    // https://stackoverflow.com/a/16345172

                    const classConstructor = this.constructor;
                    classConstructor.plugins.forEach((plugin) => {
                        Object.assign(this, plugin(this, options));
                    });
                }

                static defaults(defaults) {
                    const OctokitWithDefaults = class extends this {
                        constructor(...args) {
                            const options = args[0] || {};

                            if (typeof defaults === "function") {
                                super(defaults(options));
                                return;
                            }

                            super(
                                Object.assign(
                                    {},
                                    defaults,
                                    options,
                                    options.userAgent && defaults.userAgent
                                        ? {
                                              userAgent: `${options.userAgent} ${defaults.userAgent}`,
                                          }
                                        : null
                                )
                            );
                        }
                    };
                    return OctokitWithDefaults;
                }
                /**
                 * Attach a plugin (or many) to your Octokit instance.
                 *
                 * @example
                 * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
                 */

                static plugin(...newPlugins) {
                    var _a;

                    const currentPlugins = this.plugins;
                    const NewOctokit =
                        ((_a = class extends this {}),
                        (_a.plugins = currentPlugins.concat(
                            newPlugins.filter(
                                (plugin) => !currentPlugins.includes(plugin)
                            )
                        )),
                        _a);
                    return NewOctokit;
                }
            }
            Octokit.VERSION = VERSION;
            Octokit.plugins = [];

            exports.Octokit = Octokit;
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ 9440: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });

            var isPlainObject = __nccwpck_require__(3287);
            var universalUserAgent = __nccwpck_require__(5030);

            function lowercaseKeys(object) {
                if (!object) {
                    return {};
                }

                return Object.keys(object).reduce((newObj, key) => {
                    newObj[key.toLowerCase()] = object[key];
                    return newObj;
                }, {});
            }

            function mergeDeep(defaults, options) {
                const result = Object.assign({}, defaults);
                Object.keys(options).forEach((key) => {
                    if (isPlainObject.isPlainObject(options[key])) {
                        if (!(key in defaults))
                            Object.assign(result, {
                                [key]: options[key],
                            });
                        else
                            result[key] = mergeDeep(
                                defaults[key],
                                options[key]
                            );
                    } else {
                        Object.assign(result, {
                            [key]: options[key],
                        });
                    }
                });
                return result;
            }

            function removeUndefinedProperties(obj) {
                for (const key in obj) {
                    if (obj[key] === undefined) {
                        delete obj[key];
                    }
                }

                return obj;
            }

            function merge(defaults, route, options) {
                if (typeof route === "string") {
                    let [method, url] = route.split(" ");
                    options = Object.assign(
                        url
                            ? {
                                  method,
                                  url,
                              }
                            : {
                                  url: method,
                              },
                        options
                    );
                } else {
                    options = Object.assign({}, route);
                } // lowercase header names before merging with defaults to avoid duplicates

                options.headers = lowercaseKeys(options.headers); // remove properties with undefined values before merging

                removeUndefinedProperties(options);
                removeUndefinedProperties(options.headers);
                const mergedOptions = mergeDeep(defaults || {}, options); // mediaType.previews arrays are merged, instead of overwritten

                if (defaults && defaults.mediaType.previews.length) {
                    mergedOptions.mediaType.previews =
                        defaults.mediaType.previews
                            .filter(
                                (preview) =>
                                    !mergedOptions.mediaType.previews.includes(
                                        preview
                                    )
                            )
                            .concat(mergedOptions.mediaType.previews);
                }

                mergedOptions.mediaType.previews =
                    mergedOptions.mediaType.previews.map((preview) =>
                        preview.replace(/-preview/, "")
                    );
                return mergedOptions;
            }

            function addQueryParameters(url, parameters) {
                const separator = /\?/.test(url) ? "&" : "?";
                const names = Object.keys(parameters);

                if (names.length === 0) {
                    return url;
                }

                return (
                    url +
                    separator +
                    names
                        .map((name) => {
                            if (name === "q") {
                                return (
                                    "q=" +
                                    parameters.q
                                        .split("+")
                                        .map(encodeURIComponent)
                                        .join("+")
                                );
                            }

                            return `${name}=${encodeURIComponent(
                                parameters[name]
                            )}`;
                        })
                        .join("&")
                );
            }

            const urlVariableRegex = /\{[^}]+\}/g;

            function removeNonChars(variableName) {
                return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
            }

            function extractUrlVariableNames(url) {
                const matches = url.match(urlVariableRegex);

                if (!matches) {
                    return [];
                }

                return matches
                    .map(removeNonChars)
                    .reduce((a, b) => a.concat(b), []);
            }

            function omit(object, keysToOmit) {
                return Object.keys(object)
                    .filter((option) => !keysToOmit.includes(option))
                    .reduce((obj, key) => {
                        obj[key] = object[key];
                        return obj;
                    }, {});
            }

            // Based on https://github.com/bramstein/url-template, licensed under BSD
            // TODO: create separate package.
            //
            // Copyright (c) 2012-2014, Bram Stein
            // All rights reserved.
            // Redistribution and use in source and binary forms, with or without
            // modification, are permitted provided that the following conditions
            // are met:
            //  1. Redistributions of source code must retain the above copyright
            //     notice, this list of conditions and the following disclaimer.
            //  2. Redistributions in binary form must reproduce the above copyright
            //     notice, this list of conditions and the following disclaimer in the
            //     documentation and/or other materials provided with the distribution.
            //  3. The name of the author may not be used to endorse or promote products
            //     derived from this software without specific prior written permission.
            // THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
            // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
            // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
            // EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
            // INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
            // BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
            // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
            // OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
            // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
            // EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

            /* istanbul ignore file */
            function encodeReserved(str) {
                return str
                    .split(/(%[0-9A-Fa-f]{2})/g)
                    .map(function (part) {
                        if (!/%[0-9A-Fa-f]/.test(part)) {
                            part = encodeURI(part)
                                .replace(/%5B/g, "[")
                                .replace(/%5D/g, "]");
                        }

                        return part;
                    })
                    .join("");
            }

            function encodeUnreserved(str) {
                return encodeURIComponent(str).replace(
                    /[!'()*]/g,
                    function (c) {
                        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
                    }
                );
            }

            function encodeValue(operator, value, key) {
                value =
                    operator === "+" || operator === "#"
                        ? encodeReserved(value)
                        : encodeUnreserved(value);

                if (key) {
                    return encodeUnreserved(key) + "=" + value;
                } else {
                    return value;
                }
            }

            function isDefined(value) {
                return value !== undefined && value !== null;
            }

            function isKeyOperator(operator) {
                return operator === ";" || operator === "&" || operator === "?";
            }

            function getValues(context, operator, key, modifier) {
                var value = context[key],
                    result = [];

                if (isDefined(value) && value !== "") {
                    if (
                        typeof value === "string" ||
                        typeof value === "number" ||
                        typeof value === "boolean"
                    ) {
                        value = value.toString();

                        if (modifier && modifier !== "*") {
                            value = value.substring(0, parseInt(modifier, 10));
                        }

                        result.push(
                            encodeValue(
                                operator,
                                value,
                                isKeyOperator(operator) ? key : ""
                            )
                        );
                    } else {
                        if (modifier === "*") {
                            if (Array.isArray(value)) {
                                value
                                    .filter(isDefined)
                                    .forEach(function (value) {
                                        result.push(
                                            encodeValue(
                                                operator,
                                                value,
                                                isKeyOperator(operator)
                                                    ? key
                                                    : ""
                                            )
                                        );
                                    });
                            } else {
                                Object.keys(value).forEach(function (k) {
                                    if (isDefined(value[k])) {
                                        result.push(
                                            encodeValue(operator, value[k], k)
                                        );
                                    }
                                });
                            }
                        } else {
                            const tmp = [];

                            if (Array.isArray(value)) {
                                value
                                    .filter(isDefined)
                                    .forEach(function (value) {
                                        tmp.push(encodeValue(operator, value));
                                    });
                            } else {
                                Object.keys(value).forEach(function (k) {
                                    if (isDefined(value[k])) {
                                        tmp.push(encodeUnreserved(k));
                                        tmp.push(
                                            encodeValue(
                                                operator,
                                                value[k].toString()
                                            )
                                        );
                                    }
                                });
                            }

                            if (isKeyOperator(operator)) {
                                result.push(
                                    encodeUnreserved(key) + "=" + tmp.join(",")
                                );
                            } else if (tmp.length !== 0) {
                                result.push(tmp.join(","));
                            }
                        }
                    }
                } else {
                    if (operator === ";") {
                        if (isDefined(value)) {
                            result.push(encodeUnreserved(key));
                        }
                    } else if (
                        value === "" &&
                        (operator === "&" || operator === "?")
                    ) {
                        result.push(encodeUnreserved(key) + "=");
                    } else if (value === "") {
                        result.push("");
                    }
                }

                return result;
            }

            function parseUrl(template) {
                return {
                    expand: expand.bind(null, template),
                };
            }

            function expand(template, context) {
                var operators = ["+", "#", ".", "/", ";", "?", "&"];
                return template.replace(
                    /\{([^\{\}]+)\}|([^\{\}]+)/g,
                    function (_, expression, literal) {
                        if (expression) {
                            let operator = "";
                            const values = [];

                            if (
                                operators.indexOf(expression.charAt(0)) !== -1
                            ) {
                                operator = expression.charAt(0);
                                expression = expression.substr(1);
                            }

                            expression.split(/,/g).forEach(function (variable) {
                                var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(
                                    variable
                                );
                                values.push(
                                    getValues(
                                        context,
                                        operator,
                                        tmp[1],
                                        tmp[2] || tmp[3]
                                    )
                                );
                            });

                            if (operator && operator !== "+") {
                                var separator = ",";

                                if (operator === "?") {
                                    separator = "&";
                                } else if (operator !== "#") {
                                    separator = operator;
                                }

                                return (
                                    (values.length !== 0 ? operator : "") +
                                    values.join(separator)
                                );
                            } else {
                                return values.join(",");
                            }
                        } else {
                            return encodeReserved(literal);
                        }
                    }
                );
            }

            function parse(options) {
                // https://fetch.spec.whatwg.org/#methods
                let method = options.method.toUpperCase(); // replace :varname with {varname} to make it RFC 6570 compatible

                let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
                let headers = Object.assign({}, options.headers);
                let body;
                let parameters = omit(options, [
                    "method",
                    "baseUrl",
                    "url",
                    "headers",
                    "request",
                    "mediaType",
                ]); // extract variable names from URL to calculate remaining variables later

                const urlVariableNames = extractUrlVariableNames(url);
                url = parseUrl(url).expand(parameters);

                if (!/^http/.test(url)) {
                    url = options.baseUrl + url;
                }

                const omittedParameters = Object.keys(options)
                    .filter((option) => urlVariableNames.includes(option))
                    .concat("baseUrl");
                const remainingParameters = omit(parameters, omittedParameters);
                const isBinaryRequest = /application\/octet-stream/i.test(
                    headers.accept
                );

                if (!isBinaryRequest) {
                    if (options.mediaType.format) {
                        // e.g. application/vnd.github.v3+json => application/vnd.github.v3.raw
                        headers.accept = headers.accept
                            .split(/,/)
                            .map((preview) =>
                                preview.replace(
                                    /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
                                    `application/vnd$1$2.${options.mediaType.format}`
                                )
                            )
                            .join(",");
                    }

                    if (options.mediaType.previews.length) {
                        const previewsFromAcceptHeader =
                            headers.accept.match(/[\w-]+(?=-preview)/g) || [];
                        headers.accept = previewsFromAcceptHeader
                            .concat(options.mediaType.previews)
                            .map((preview) => {
                                const format = options.mediaType.format
                                    ? `.${options.mediaType.format}`
                                    : "+json";
                                return `application/vnd.github.${preview}-preview${format}`;
                            })
                            .join(",");
                    }
                } // for GET/HEAD requests, set URL query parameters from remaining parameters
                // for PATCH/POST/PUT/DELETE requests, set request body from remaining parameters

                if (["GET", "HEAD"].includes(method)) {
                    url = addQueryParameters(url, remainingParameters);
                } else {
                    if ("data" in remainingParameters) {
                        body = remainingParameters.data;
                    } else {
                        if (Object.keys(remainingParameters).length) {
                            body = remainingParameters;
                        } else {
                            headers["content-length"] = 0;
                        }
                    }
                } // default content-type for JSON if body is set

                if (!headers["content-type"] && typeof body !== "undefined") {
                    headers["content-type"] = "application/json; charset=utf-8";
                } // GitHub expects 'content-length: 0' header for PUT/PATCH requests without body.
                // fetch does not allow to set `content-length` header, but we can set body to an empty string

                if (
                    ["PATCH", "PUT"].includes(method) &&
                    typeof body === "undefined"
                ) {
                    body = "";
                } // Only return body/request keys if present

                return Object.assign(
                    {
                        method,
                        url,
                        headers,
                    },
                    typeof body !== "undefined"
                        ? {
                              body,
                          }
                        : null,
                    options.request
                        ? {
                              request: options.request,
                          }
                        : null
                );
            }

            function endpointWithDefaults(defaults, route, options) {
                return parse(merge(defaults, route, options));
            }

            function withDefaults(oldDefaults, newDefaults) {
                const DEFAULTS = merge(oldDefaults, newDefaults);
                const endpoint = endpointWithDefaults.bind(null, DEFAULTS);
                return Object.assign(endpoint, {
                    DEFAULTS,
                    defaults: withDefaults.bind(null, DEFAULTS),
                    merge: merge.bind(null, DEFAULTS),
                    parse,
                });
            }

            const VERSION = "6.0.12";

            const userAgent = `octokit-endpoint.js/${VERSION} ${universalUserAgent.getUserAgent()}`; // DEFAULTS has all properties set that EndpointOptions has, except url.
            // So we use RequestParameters and add method as additional required property.

            const DEFAULTS = {
                method: "GET",
                baseUrl: "https://api.github.com",
                headers: {
                    accept: "application/vnd.github.v3+json",
                    "user-agent": userAgent,
                },
                mediaType: {
                    format: "",
                    previews: [],
                },
            };

            const endpoint = withDefaults(null, DEFAULTS);

            exports.endpoint = endpoint;
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ 8467: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });

            var request = __nccwpck_require__(6234);
            var universalUserAgent = __nccwpck_require__(5030);

            const VERSION = "4.8.0";

            function _buildMessageForResponseErrors(data) {
                return (
                    `Request failed due to following response errors:\n` +
                    data.errors.map((e) => ` - ${e.message}`).join("\n")
                );
            }

            class GraphqlResponseError extends Error {
                constructor(request, headers, response) {
                    super(_buildMessageForResponseErrors(response));
                    this.request = request;
                    this.headers = headers;
                    this.response = response;
                    this.name = "GraphqlResponseError"; // Expose the errors and response data in their shorthand properties.

                    this.errors = response.errors;
                    this.data = response.data; // Maintains proper stack trace (only available on V8)

                    /* istanbul ignore next */

                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(this, this.constructor);
                    }
                }
            }

            const NON_VARIABLE_OPTIONS = [
                "method",
                "baseUrl",
                "url",
                "headers",
                "request",
                "query",
                "mediaType",
            ];
            const FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
            const GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
            function graphql(request, query, options) {
                if (options) {
                    if (typeof query === "string" && "query" in options) {
                        return Promise.reject(
                            new Error(
                                `[@octokit/graphql] "query" cannot be used as variable name`
                            )
                        );
                    }

                    for (const key in options) {
                        if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
                        return Promise.reject(
                            new Error(
                                `[@octokit/graphql] "${key}" cannot be used as variable name`
                            )
                        );
                    }
                }

                const parsedOptions =
                    typeof query === "string"
                        ? Object.assign(
                              {
                                  query,
                              },
                              options
                          )
                        : query;
                const requestOptions = Object.keys(parsedOptions).reduce(
                    (result, key) => {
                        if (NON_VARIABLE_OPTIONS.includes(key)) {
                            result[key] = parsedOptions[key];
                            return result;
                        }

                        if (!result.variables) {
                            result.variables = {};
                        }

                        result.variables[key] = parsedOptions[key];
                        return result;
                    },
                    {}
                ); // workaround for GitHub Enterprise baseUrl set with /api/v3 suffix
                // https://github.com/octokit/auth-app.js/issues/111#issuecomment-657610451

                const baseUrl =
                    parsedOptions.baseUrl || request.endpoint.DEFAULTS.baseUrl;

                if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
                    requestOptions.url = baseUrl.replace(
                        GHES_V3_SUFFIX_REGEX,
                        "/api/graphql"
                    );
                }

                return request(requestOptions).then((response) => {
                    if (response.data.errors) {
                        const headers = {};

                        for (const key of Object.keys(response.headers)) {
                            headers[key] = response.headers[key];
                        }

                        throw new GraphqlResponseError(
                            requestOptions,
                            headers,
                            response.data
                        );
                    }

                    return response.data.data;
                });
            }

            function withDefaults(request$1, newDefaults) {
                const newRequest = request$1.defaults(newDefaults);

                const newApi = (query, options) => {
                    return graphql(newRequest, query, options);
                };

                return Object.assign(newApi, {
                    defaults: withDefaults.bind(null, newRequest),
                    endpoint: request.request.endpoint,
                });
            }

            const graphql$1 = withDefaults(request.request, {
                headers: {
                    "user-agent": `octokit-graphql.js/${VERSION} ${universalUserAgent.getUserAgent()}`,
                },
                method: "POST",
                url: "/graphql",
            });
            function withCustomRequest(customRequest) {
                return withDefaults(customRequest, {
                    method: "POST",
                    url: "/graphql",
                });
            }

            exports.GraphqlResponseError = GraphqlResponseError;
            exports.graphql = graphql$1;
            exports.withCustomRequest = withCustomRequest;
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ 4193: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });

            const VERSION = "2.16.3";

            function ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);

                if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);

                    if (enumerableOnly) {
                        symbols = symbols.filter(function (sym) {
                            return Object.getOwnPropertyDescriptor(
                                object,
                                sym
                            ).enumerable;
                        });
                    }

                    keys.push.apply(keys, symbols);
                }

                return keys;
            }

            function _objectSpread2(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i] != null ? arguments[i] : {};

                    if (i % 2) {
                        ownKeys(Object(source), true).forEach(function (key) {
                            _defineProperty(target, key, source[key]);
                        });
                    } else if (Object.getOwnPropertyDescriptors) {
                        Object.defineProperties(
                            target,
                            Object.getOwnPropertyDescriptors(source)
                        );
                    } else {
                        ownKeys(Object(source)).forEach(function (key) {
                            Object.defineProperty(
                                target,
                                key,
                                Object.getOwnPropertyDescriptor(source, key)
                            );
                        });
                    }
                }

                return target;
            }

            function _defineProperty(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true,
                    });
                } else {
                    obj[key] = value;
                }

                return obj;
            }

            /**
             * Some “list” response that can be paginated have a different response structure
             *
             * They have a `total_count` key in the response (search also has `incomplete_results`,
             * /installation/repositories also has `repository_selection`), as well as a key with
             * the list of the items which name varies from endpoint to endpoint.
             *
             * Octokit normalizes these responses so that paginated results are always returned following
             * the same structure. One challenge is that if the list response has only one page, no Link
             * header is provided, so this header alone is not sufficient to check wether a response is
             * paginated or not.
             *
             * We check if a "total_count" key is present in the response data, but also make sure that
             * a "url" property is not, as the "Get the combined status for a specific ref" endpoint would
             * otherwise match: https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
             */
            function normalizePaginatedListResponse(response) {
                // endpoints can respond with 204 if repository is empty
                if (!response.data) {
                    return _objectSpread2(
                        _objectSpread2({}, response),
                        {},
                        {
                            data: [],
                        }
                    );
                }

                const responseNeedsNormalization =
                    "total_count" in response.data && !("url" in response.data);
                if (!responseNeedsNormalization) return response; // keep the additional properties intact as there is currently no other way
                // to retrieve the same information.

                const incompleteResults = response.data.incomplete_results;
                const repositorySelection = response.data.repository_selection;
                const totalCount = response.data.total_count;
                delete response.data.incomplete_results;
                delete response.data.repository_selection;
                delete response.data.total_count;
                const namespaceKey = Object.keys(response.data)[0];
                const data = response.data[namespaceKey];
                response.data = data;

                if (typeof incompleteResults !== "undefined") {
                    response.data.incomplete_results = incompleteResults;
                }

                if (typeof repositorySelection !== "undefined") {
                    response.data.repository_selection = repositorySelection;
                }

                response.data.total_count = totalCount;
                return response;
            }

            function iterator(octokit, route, parameters) {
                const options =
                    typeof route === "function"
                        ? route.endpoint(parameters)
                        : octokit.request.endpoint(route, parameters);
                const requestMethod =
                    typeof route === "function" ? route : octokit.request;
                const method = options.method;
                const headers = options.headers;
                let url = options.url;
                return {
                    [Symbol.asyncIterator]: () => ({
                        async next() {
                            if (!url)
                                return {
                                    done: true,
                                };

                            try {
                                const response = await requestMethod({
                                    method,
                                    url,
                                    headers,
                                });
                                const normalizedResponse =
                                    normalizePaginatedListResponse(response); // `response.headers.link` format:
                                // '<https://api.github.com/users/aseemk/followers?page=2>; rel="next", <https://api.github.com/users/aseemk/followers?page=2>; rel="last"'
                                // sets `url` to undefined if "next" URL is not present or `link` header is not set

                                url = ((
                                    normalizedResponse.headers.link || ""
                                ).match(/<([^>]+)>;\s*rel="next"/) || [])[1];
                                return {
                                    value: normalizedResponse,
                                };
                            } catch (error) {
                                if (error.status !== 409) throw error;
                                url = "";
                                return {
                                    value: {
                                        status: 200,
                                        headers: {},
                                        data: [],
                                    },
                                };
                            }
                        },
                    }),
                };
            }

            function paginate(octokit, route, parameters, mapFn) {
                if (typeof parameters === "function") {
                    mapFn = parameters;
                    parameters = undefined;
                }

                return gather(
                    octokit,
                    [],
                    iterator(octokit, route, parameters)[
                        Symbol.asyncIterator
                    ](),
                    mapFn
                );
            }

            function gather(octokit, results, iterator, mapFn) {
                return iterator.next().then((result) => {
                    if (result.done) {
                        return results;
                    }

                    let earlyExit = false;

                    function done() {
                        earlyExit = true;
                    }

                    results = results.concat(
                        mapFn ? mapFn(result.value, done) : result.value.data
                    );

                    if (earlyExit) {
                        return results;
                    }

                    return gather(octokit, results, iterator, mapFn);
                });
            }

            const composePaginateRest = Object.assign(paginate, {
                iterator,
            });

            const paginatingEndpoints = [
                "GET /app/hook/deliveries",
                "GET /app/installations",
                "GET /applications/grants",
                "GET /authorizations",
                "GET /enterprises/{enterprise}/actions/permissions/organizations",
                "GET /enterprises/{enterprise}/actions/runner-groups",
                "GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations",
                "GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners",
                "GET /enterprises/{enterprise}/actions/runners",
                "GET /enterprises/{enterprise}/actions/runners/downloads",
                "GET /events",
                "GET /gists",
                "GET /gists/public",
                "GET /gists/starred",
                "GET /gists/{gist_id}/comments",
                "GET /gists/{gist_id}/commits",
                "GET /gists/{gist_id}/forks",
                "GET /installation/repositories",
                "GET /issues",
                "GET /marketplace_listing/plans",
                "GET /marketplace_listing/plans/{plan_id}/accounts",
                "GET /marketplace_listing/stubbed/plans",
                "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
                "GET /networks/{owner}/{repo}/events",
                "GET /notifications",
                "GET /organizations",
                "GET /orgs/{org}/actions/permissions/repositories",
                "GET /orgs/{org}/actions/runner-groups",
                "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories",
                "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners",
                "GET /orgs/{org}/actions/runners",
                "GET /orgs/{org}/actions/runners/downloads",
                "GET /orgs/{org}/actions/secrets",
                "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
                "GET /orgs/{org}/blocks",
                "GET /orgs/{org}/credential-authorizations",
                "GET /orgs/{org}/events",
                "GET /orgs/{org}/failed_invitations",
                "GET /orgs/{org}/hooks",
                "GET /orgs/{org}/hooks/{hook_id}/deliveries",
                "GET /orgs/{org}/installations",
                "GET /orgs/{org}/invitations",
                "GET /orgs/{org}/invitations/{invitation_id}/teams",
                "GET /orgs/{org}/issues",
                "GET /orgs/{org}/members",
                "GET /orgs/{org}/migrations",
                "GET /orgs/{org}/migrations/{migration_id}/repositories",
                "GET /orgs/{org}/outside_collaborators",
                "GET /orgs/{org}/packages",
                "GET /orgs/{org}/projects",
                "GET /orgs/{org}/public_members",
                "GET /orgs/{org}/repos",
                "GET /orgs/{org}/secret-scanning/alerts",
                "GET /orgs/{org}/team-sync/groups",
                "GET /orgs/{org}/teams",
                "GET /orgs/{org}/teams/{team_slug}/discussions",
                "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
                "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
                "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
                "GET /orgs/{org}/teams/{team_slug}/invitations",
                "GET /orgs/{org}/teams/{team_slug}/members",
                "GET /orgs/{org}/teams/{team_slug}/projects",
                "GET /orgs/{org}/teams/{team_slug}/repos",
                "GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings",
                "GET /orgs/{org}/teams/{team_slug}/teams",
                "GET /projects/columns/{column_id}/cards",
                "GET /projects/{project_id}/collaborators",
                "GET /projects/{project_id}/columns",
                "GET /repos/{owner}/{repo}/actions/artifacts",
                "GET /repos/{owner}/{repo}/actions/runners",
                "GET /repos/{owner}/{repo}/actions/runners/downloads",
                "GET /repos/{owner}/{repo}/actions/runs",
                "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
                "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
                "GET /repos/{owner}/{repo}/actions/secrets",
                "GET /repos/{owner}/{repo}/actions/workflows",
                "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
                "GET /repos/{owner}/{repo}/assignees",
                "GET /repos/{owner}/{repo}/autolinks",
                "GET /repos/{owner}/{repo}/branches",
                "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
                "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
                "GET /repos/{owner}/{repo}/code-scanning/alerts",
                "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
                "GET /repos/{owner}/{repo}/code-scanning/analyses",
                "GET /repos/{owner}/{repo}/collaborators",
                "GET /repos/{owner}/{repo}/comments",
                "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
                "GET /repos/{owner}/{repo}/commits",
                "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head",
                "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
                "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
                "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
                "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
                "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
                "GET /repos/{owner}/{repo}/contributors",
                "GET /repos/{owner}/{repo}/deployments",
                "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
                "GET /repos/{owner}/{repo}/events",
                "GET /repos/{owner}/{repo}/forks",
                "GET /repos/{owner}/{repo}/git/matching-refs/{ref}",
                "GET /repos/{owner}/{repo}/hooks",
                "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
                "GET /repos/{owner}/{repo}/invitations",
                "GET /repos/{owner}/{repo}/issues",
                "GET /repos/{owner}/{repo}/issues/comments",
                "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
                "GET /repos/{owner}/{repo}/issues/events",
                "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
                "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
                "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
                "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
                "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
                "GET /repos/{owner}/{repo}/keys",
                "GET /repos/{owner}/{repo}/labels",
                "GET /repos/{owner}/{repo}/milestones",
                "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
                "GET /repos/{owner}/{repo}/notifications",
                "GET /repos/{owner}/{repo}/pages/builds",
                "GET /repos/{owner}/{repo}/projects",
                "GET /repos/{owner}/{repo}/pulls",
                "GET /repos/{owner}/{repo}/pulls/comments",
                "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
                "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
                "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
                "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
                "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
                "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
                "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
                "GET /repos/{owner}/{repo}/releases",
                "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
                "GET /repos/{owner}/{repo}/secret-scanning/alerts",
                "GET /repos/{owner}/{repo}/stargazers",
                "GET /repos/{owner}/{repo}/subscribers",
                "GET /repos/{owner}/{repo}/tags",
                "GET /repos/{owner}/{repo}/teams",
                "GET /repositories",
                "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
                "GET /scim/v2/enterprises/{enterprise}/Groups",
                "GET /scim/v2/enterprises/{enterprise}/Users",
                "GET /scim/v2/organizations/{org}/Users",
                "GET /search/code",
                "GET /search/commits",
                "GET /search/issues",
                "GET /search/labels",
                "GET /search/repositories",
                "GET /search/topics",
                "GET /search/users",
                "GET /teams/{team_id}/discussions",
                "GET /teams/{team_id}/discussions/{discussion_number}/comments",
                "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
                "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
                "GET /teams/{team_id}/invitations",
                "GET /teams/{team_id}/members",
                "GET /teams/{team_id}/projects",
                "GET /teams/{team_id}/repos",
                "GET /teams/{team_id}/team-sync/group-mappings",
                "GET /teams/{team_id}/teams",
                "GET /user/blocks",
                "GET /user/emails",
                "GET /user/followers",
                "GET /user/following",
                "GET /user/gpg_keys",
                "GET /user/installations",
                "GET /user/installations/{installation_id}/repositories",
                "GET /user/issues",
                "GET /user/keys",
                "GET /user/marketplace_purchases",
                "GET /user/marketplace_purchases/stubbed",
                "GET /user/memberships/orgs",
                "GET /user/migrations",
                "GET /user/migrations/{migration_id}/repositories",
                "GET /user/orgs",
                "GET /user/packages",
                "GET /user/public_emails",
                "GET /user/repos",
                "GET /user/repository_invitations",
                "GET /user/starred",
                "GET /user/subscriptions",
                "GET /user/teams",
                "GET /user/{username}/packages",
                "GET /users",
                "GET /users/{username}/events",
                "GET /users/{username}/events/orgs/{org}",
                "GET /users/{username}/events/public",
                "GET /users/{username}/followers",
                "GET /users/{username}/following",
                "GET /users/{username}/gists",
                "GET /users/{username}/gpg_keys",
                "GET /users/{username}/keys",
                "GET /users/{username}/orgs",
                "GET /users/{username}/projects",
                "GET /users/{username}/received_events",
                "GET /users/{username}/received_events/public",
                "GET /users/{username}/repos",
                "GET /users/{username}/starred",
                "GET /users/{username}/subscriptions",
            ];

            function isPaginatingEndpoint(arg) {
                if (typeof arg === "string") {
                    return paginatingEndpoints.includes(arg);
                } else {
                    return false;
                }
            }

            /**
             * @param octokit Octokit instance
             * @param options Options passed to Octokit constructor
             */

            function paginateRest(octokit) {
                return {
                    paginate: Object.assign(paginate.bind(null, octokit), {
                        iterator: iterator.bind(null, octokit),
                    }),
                };
            }
            paginateRest.VERSION = VERSION;

            exports.composePaginateRest = composePaginateRest;
            exports.isPaginatingEndpoint = isPaginatingEndpoint;
            exports.paginateRest = paginateRest;
            exports.paginatingEndpoints = paginatingEndpoints;
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ 3044: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });

            function ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);

                if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);

                    if (enumerableOnly) {
                        symbols = symbols.filter(function (sym) {
                            return Object.getOwnPropertyDescriptor(
                                object,
                                sym
                            ).enumerable;
                        });
                    }

                    keys.push.apply(keys, symbols);
                }

                return keys;
            }

            function _objectSpread2(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i] != null ? arguments[i] : {};

                    if (i % 2) {
                        ownKeys(Object(source), true).forEach(function (key) {
                            _defineProperty(target, key, source[key]);
                        });
                    } else if (Object.getOwnPropertyDescriptors) {
                        Object.defineProperties(
                            target,
                            Object.getOwnPropertyDescriptors(source)
                        );
                    } else {
                        ownKeys(Object(source)).forEach(function (key) {
                            Object.defineProperty(
                                target,
                                key,
                                Object.getOwnPropertyDescriptor(source, key)
                            );
                        });
                    }
                }

                return target;
            }

            function _defineProperty(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true,
                    });
                } else {
                    obj[key] = value;
                }

                return obj;
            }

            const Endpoints = {
                actions: {
                    addSelectedRepoToOrgSecret: [
                        "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}",
                    ],
                    approveWorkflowRun: [
                        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve",
                    ],
                    cancelWorkflowRun: [
                        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel",
                    ],
                    createOrUpdateEnvironmentSecret: [
                        "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}",
                    ],
                    createOrUpdateOrgSecret: [
                        "PUT /orgs/{org}/actions/secrets/{secret_name}",
                    ],
                    createOrUpdateRepoSecret: [
                        "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}",
                    ],
                    createRegistrationTokenForOrg: [
                        "POST /orgs/{org}/actions/runners/registration-token",
                    ],
                    createRegistrationTokenForRepo: [
                        "POST /repos/{owner}/{repo}/actions/runners/registration-token",
                    ],
                    createRemoveTokenForOrg: [
                        "POST /orgs/{org}/actions/runners/remove-token",
                    ],
                    createRemoveTokenForRepo: [
                        "POST /repos/{owner}/{repo}/actions/runners/remove-token",
                    ],
                    createWorkflowDispatch: [
                        "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches",
                    ],
                    deleteArtifact: [
                        "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}",
                    ],
                    deleteEnvironmentSecret: [
                        "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}",
                    ],
                    deleteOrgSecret: [
                        "DELETE /orgs/{org}/actions/secrets/{secret_name}",
                    ],
                    deleteRepoSecret: [
                        "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}",
                    ],
                    deleteSelfHostedRunnerFromOrg: [
                        "DELETE /orgs/{org}/actions/runners/{runner_id}",
                    ],
                    deleteSelfHostedRunnerFromRepo: [
                        "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}",
                    ],
                    deleteWorkflowRun: [
                        "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}",
                    ],
                    deleteWorkflowRunLogs: [
                        "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs",
                    ],
                    disableSelectedRepositoryGithubActionsOrganization: [
                        "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}",
                    ],
                    disableWorkflow: [
                        "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable",
                    ],
                    downloadArtifact: [
                        "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}",
                    ],
                    downloadJobLogsForWorkflowRun: [
                        "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs",
                    ],
                    downloadWorkflowRunLogs: [
                        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs",
                    ],
                    enableSelectedRepositoryGithubActionsOrganization: [
                        "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}",
                    ],
                    enableWorkflow: [
                        "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable",
                    ],
                    getAllowedActionsOrganization: [
                        "GET /orgs/{org}/actions/permissions/selected-actions",
                    ],
                    getAllowedActionsRepository: [
                        "GET /repos/{owner}/{repo}/actions/permissions/selected-actions",
                    ],
                    getArtifact: [
                        "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}",
                    ],
                    getEnvironmentPublicKey: [
                        "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key",
                    ],
                    getEnvironmentSecret: [
                        "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}",
                    ],
                    getGithubActionsPermissionsOrganization: [
                        "GET /orgs/{org}/actions/permissions",
                    ],
                    getGithubActionsPermissionsRepository: [
                        "GET /repos/{owner}/{repo}/actions/permissions",
                    ],
                    getJobForWorkflowRun: [
                        "GET /repos/{owner}/{repo}/actions/jobs/{job_id}",
                    ],
                    getOrgPublicKey: [
                        "GET /orgs/{org}/actions/secrets/public-key",
                    ],
                    getOrgSecret: [
                        "GET /orgs/{org}/actions/secrets/{secret_name}",
                    ],
                    getPendingDeploymentsForRun: [
                        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments",
                    ],
                    getRepoPermissions: [
                        "GET /repos/{owner}/{repo}/actions/permissions",
                        {},
                        {
                            renamed: [
                                "actions",
                                "getGithubActionsPermissionsRepository",
                            ],
                        },
                    ],
                    getRepoPublicKey: [
                        "GET /repos/{owner}/{repo}/actions/secrets/public-key",
                    ],
                    getRepoSecret: [
                        "GET /repos/{owner}/{repo}/actions/secrets/{secret_name}",
                    ],
                    getReviewsForRun: [
                        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals",
                    ],
                    getSelfHostedRunnerForOrg: [
                        "GET /orgs/{org}/actions/runners/{runner_id}",
                    ],
                    getSelfHostedRunnerForRepo: [
                        "GET /repos/{owner}/{repo}/actions/runners/{runner_id}",
                    ],
                    getWorkflow: [
                        "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}",
                    ],
                    getWorkflowRun: [
                        "GET /repos/{owner}/{repo}/actions/runs/{run_id}",
                    ],
                    getWorkflowRunUsage: [
                        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing",
                    ],
                    getWorkflowUsage: [
                        "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing",
                    ],
                    listArtifactsForRepo: [
                        "GET /repos/{owner}/{repo}/actions/artifacts",
                    ],
                    listEnvironmentSecrets: [
                        "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
                    ],
                    listJobsForWorkflowRun: [
                        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
                    ],
                    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
                    listRepoSecrets: [
                        "GET /repos/{owner}/{repo}/actions/secrets",
                    ],
                    listRepoWorkflows: [
                        "GET /repos/{owner}/{repo}/actions/workflows",
                    ],
                    listRunnerApplicationsForOrg: [
                        "GET /orgs/{org}/actions/runners/downloads",
                    ],
                    listRunnerApplicationsForRepo: [
                        "GET /repos/{owner}/{repo}/actions/runners/downloads",
                    ],
                    listSelectedReposForOrgSecret: [
                        "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
                    ],
                    listSelectedRepositoriesEnabledGithubActionsOrganization: [
                        "GET /orgs/{org}/actions/permissions/repositories",
                    ],
                    listSelfHostedRunnersForOrg: [
                        "GET /orgs/{org}/actions/runners",
                    ],
                    listSelfHostedRunnersForRepo: [
                        "GET /repos/{owner}/{repo}/actions/runners",
                    ],
                    listWorkflowRunArtifacts: [
                        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
                    ],
                    listWorkflowRuns: [
                        "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
                    ],
                    listWorkflowRunsForRepo: [
                        "GET /repos/{owner}/{repo}/actions/runs",
                    ],
                    reRunWorkflow: [
                        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun",
                    ],
                    removeSelectedRepoFromOrgSecret: [
                        "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}",
                    ],
                    reviewPendingDeploymentsForRun: [
                        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments",
                    ],
                    setAllowedActionsOrganization: [
                        "PUT /orgs/{org}/actions/permissions/selected-actions",
                    ],
                    setAllowedActionsRepository: [
                        "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions",
                    ],
                    setGithubActionsPermissionsOrganization: [
                        "PUT /orgs/{org}/actions/permissions",
                    ],
                    setGithubActionsPermissionsRepository: [
                        "PUT /repos/{owner}/{repo}/actions/permissions",
                    ],
                    setSelectedReposForOrgSecret: [
                        "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories",
                    ],
                    setSelectedRepositoriesEnabledGithubActionsOrganization: [
                        "PUT /orgs/{org}/actions/permissions/repositories",
                    ],
                },
                activity: {
                    checkRepoIsStarredByAuthenticatedUser: [
                        "GET /user/starred/{owner}/{repo}",
                    ],
                    deleteRepoSubscription: [
                        "DELETE /repos/{owner}/{repo}/subscription",
                    ],
                    deleteThreadSubscription: [
                        "DELETE /notifications/threads/{thread_id}/subscription",
                    ],
                    getFeeds: ["GET /feeds"],
                    getRepoSubscription: [
                        "GET /repos/{owner}/{repo}/subscription",
                    ],
                    getThread: ["GET /notifications/threads/{thread_id}"],
                    getThreadSubscriptionForAuthenticatedUser: [
                        "GET /notifications/threads/{thread_id}/subscription",
                    ],
                    listEventsForAuthenticatedUser: [
                        "GET /users/{username}/events",
                    ],
                    listNotificationsForAuthenticatedUser: [
                        "GET /notifications",
                    ],
                    listOrgEventsForAuthenticatedUser: [
                        "GET /users/{username}/events/orgs/{org}",
                    ],
                    listPublicEvents: ["GET /events"],
                    listPublicEventsForRepoNetwork: [
                        "GET /networks/{owner}/{repo}/events",
                    ],
                    listPublicEventsForUser: [
                        "GET /users/{username}/events/public",
                    ],
                    listPublicOrgEvents: ["GET /orgs/{org}/events"],
                    listReceivedEventsForUser: [
                        "GET /users/{username}/received_events",
                    ],
                    listReceivedPublicEventsForUser: [
                        "GET /users/{username}/received_events/public",
                    ],
                    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
                    listRepoNotificationsForAuthenticatedUser: [
                        "GET /repos/{owner}/{repo}/notifications",
                    ],
                    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
                    listReposStarredByUser: ["GET /users/{username}/starred"],
                    listReposWatchedByUser: [
                        "GET /users/{username}/subscriptions",
                    ],
                    listStargazersForRepo: [
                        "GET /repos/{owner}/{repo}/stargazers",
                    ],
                    listWatchedReposForAuthenticatedUser: [
                        "GET /user/subscriptions",
                    ],
                    listWatchersForRepo: [
                        "GET /repos/{owner}/{repo}/subscribers",
                    ],
                    markNotificationsAsRead: ["PUT /notifications"],
                    markRepoNotificationsAsRead: [
                        "PUT /repos/{owner}/{repo}/notifications",
                    ],
                    markThreadAsRead: [
                        "PATCH /notifications/threads/{thread_id}",
                    ],
                    setRepoSubscription: [
                        "PUT /repos/{owner}/{repo}/subscription",
                    ],
                    setThreadSubscription: [
                        "PUT /notifications/threads/{thread_id}/subscription",
                    ],
                    starRepoForAuthenticatedUser: [
                        "PUT /user/starred/{owner}/{repo}",
                    ],
                    unstarRepoForAuthenticatedUser: [
                        "DELETE /user/starred/{owner}/{repo}",
                    ],
                },
                apps: {
                    addRepoToInstallation: [
                        "PUT /user/installations/{installation_id}/repositories/{repository_id}",
                    ],
                    checkToken: ["POST /applications/{client_id}/token"],
                    createContentAttachment: [
                        "POST /content_references/{content_reference_id}/attachments",
                        {
                            mediaType: {
                                previews: ["corsair"],
                            },
                        },
                    ],
                    createContentAttachmentForRepo: [
                        "POST /repos/{owner}/{repo}/content_references/{content_reference_id}/attachments",
                        {
                            mediaType: {
                                previews: ["corsair"],
                            },
                        },
                    ],
                    createFromManifest: [
                        "POST /app-manifests/{code}/conversions",
                    ],
                    createInstallationAccessToken: [
                        "POST /app/installations/{installation_id}/access_tokens",
                    ],
                    deleteAuthorization: [
                        "DELETE /applications/{client_id}/grant",
                    ],
                    deleteInstallation: [
                        "DELETE /app/installations/{installation_id}",
                    ],
                    deleteToken: ["DELETE /applications/{client_id}/token"],
                    getAuthenticated: ["GET /app"],
                    getBySlug: ["GET /apps/{app_slug}"],
                    getInstallation: [
                        "GET /app/installations/{installation_id}",
                    ],
                    getOrgInstallation: ["GET /orgs/{org}/installation"],
                    getRepoInstallation: [
                        "GET /repos/{owner}/{repo}/installation",
                    ],
                    getSubscriptionPlanForAccount: [
                        "GET /marketplace_listing/accounts/{account_id}",
                    ],
                    getSubscriptionPlanForAccountStubbed: [
                        "GET /marketplace_listing/stubbed/accounts/{account_id}",
                    ],
                    getUserInstallation: ["GET /users/{username}/installation"],
                    getWebhookConfigForApp: ["GET /app/hook/config"],
                    getWebhookDelivery: [
                        "GET /app/hook/deliveries/{delivery_id}",
                    ],
                    listAccountsForPlan: [
                        "GET /marketplace_listing/plans/{plan_id}/accounts",
                    ],
                    listAccountsForPlanStubbed: [
                        "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
                    ],
                    listInstallationReposForAuthenticatedUser: [
                        "GET /user/installations/{installation_id}/repositories",
                    ],
                    listInstallations: ["GET /app/installations"],
                    listInstallationsForAuthenticatedUser: [
                        "GET /user/installations",
                    ],
                    listPlans: ["GET /marketplace_listing/plans"],
                    listPlansStubbed: [
                        "GET /marketplace_listing/stubbed/plans",
                    ],
                    listReposAccessibleToInstallation: [
                        "GET /installation/repositories",
                    ],
                    listSubscriptionsForAuthenticatedUser: [
                        "GET /user/marketplace_purchases",
                    ],
                    listSubscriptionsForAuthenticatedUserStubbed: [
                        "GET /user/marketplace_purchases/stubbed",
                    ],
                    listWebhookDeliveries: ["GET /app/hook/deliveries"],
                    redeliverWebhookDelivery: [
                        "POST /app/hook/deliveries/{delivery_id}/attempts",
                    ],
                    removeRepoFromInstallation: [
                        "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
                    ],
                    resetToken: ["PATCH /applications/{client_id}/token"],
                    revokeInstallationAccessToken: [
                        "DELETE /installation/token",
                    ],
                    scopeToken: ["POST /applications/{client_id}/token/scoped"],
                    suspendInstallation: [
                        "PUT /app/installations/{installation_id}/suspended",
                    ],
                    unsuspendInstallation: [
                        "DELETE /app/installations/{installation_id}/suspended",
                    ],
                    updateWebhookConfigForApp: ["PATCH /app/hook/config"],
                },
                billing: {
                    getGithubActionsBillingOrg: [
                        "GET /orgs/{org}/settings/billing/actions",
                    ],
                    getGithubActionsBillingUser: [
                        "GET /users/{username}/settings/billing/actions",
                    ],
                    getGithubPackagesBillingOrg: [
                        "GET /orgs/{org}/settings/billing/packages",
                    ],
                    getGithubPackagesBillingUser: [
                        "GET /users/{username}/settings/billing/packages",
                    ],
                    getSharedStorageBillingOrg: [
                        "GET /orgs/{org}/settings/billing/shared-storage",
                    ],
                    getSharedStorageBillingUser: [
                        "GET /users/{username}/settings/billing/shared-storage",
                    ],
                },
                checks: {
                    create: ["POST /repos/{owner}/{repo}/check-runs"],
                    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
                    get: [
                        "GET /repos/{owner}/{repo}/check-runs/{check_run_id}",
                    ],
                    getSuite: [
                        "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}",
                    ],
                    listAnnotations: [
                        "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
                    ],
                    listForRef: [
                        "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
                    ],
                    listForSuite: [
                        "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
                    ],
                    listSuitesForRef: [
                        "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
                    ],
                    rerequestSuite: [
                        "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest",
                    ],
                    setSuitesPreferences: [
                        "PATCH /repos/{owner}/{repo}/check-suites/preferences",
                    ],
                    update: [
                        "PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}",
                    ],
                },
                codeScanning: {
                    deleteAnalysis: [
                        "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}",
                    ],
                    getAlert: [
                        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
                        {},
                        {
                            renamedParameters: {
                                alert_id: "alert_number",
                            },
                        },
                    ],
                    getAnalysis: [
                        "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}",
                    ],
                    getSarif: [
                        "GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}",
                    ],
                    listAlertInstances: [
                        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
                    ],
                    listAlertsForRepo: [
                        "GET /repos/{owner}/{repo}/code-scanning/alerts",
                    ],
                    listAlertsInstances: [
                        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
                        {},
                        {
                            renamed: ["codeScanning", "listAlertInstances"],
                        },
                    ],
                    listRecentAnalyses: [
                        "GET /repos/{owner}/{repo}/code-scanning/analyses",
                    ],
                    updateAlert: [
                        "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
                    ],
                    uploadSarif: [
                        "POST /repos/{owner}/{repo}/code-scanning/sarifs",
                    ],
                },
                codesOfConduct: {
                    getAllCodesOfConduct: ["GET /codes_of_conduct"],
                    getConductCode: ["GET /codes_of_conduct/{key}"],
                    getForRepo: [
                        "GET /repos/{owner}/{repo}/community/code_of_conduct",
                        {
                            mediaType: {
                                previews: ["scarlet-witch"],
                            },
                        },
                    ],
                },
                emojis: {
                    get: ["GET /emojis"],
                },
                enterpriseAdmin: {
                    disableSelectedOrganizationGithubActionsEnterprise: [
                        "DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}",
                    ],
                    enableSelectedOrganizationGithubActionsEnterprise: [
                        "PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}",
                    ],
                    getAllowedActionsEnterprise: [
                        "GET /enterprises/{enterprise}/actions/permissions/selected-actions",
                    ],
                    getGithubActionsPermissionsEnterprise: [
                        "GET /enterprises/{enterprise}/actions/permissions",
                    ],
                    listSelectedOrganizationsEnabledGithubActionsEnterprise: [
                        "GET /enterprises/{enterprise}/actions/permissions/organizations",
                    ],
                    setAllowedActionsEnterprise: [
                        "PUT /enterprises/{enterprise}/actions/permissions/selected-actions",
                    ],
                    setGithubActionsPermissionsEnterprise: [
                        "PUT /enterprises/{enterprise}/actions/permissions",
                    ],
                    setSelectedOrganizationsEnabledGithubActionsEnterprise: [
                        "PUT /enterprises/{enterprise}/actions/permissions/organizations",
                    ],
                },
                gists: {
                    checkIsStarred: ["GET /gists/{gist_id}/star"],
                    create: ["POST /gists"],
                    createComment: ["POST /gists/{gist_id}/comments"],
                    delete: ["DELETE /gists/{gist_id}"],
                    deleteComment: [
                        "DELETE /gists/{gist_id}/comments/{comment_id}",
                    ],
                    fork: ["POST /gists/{gist_id}/forks"],
                    get: ["GET /gists/{gist_id}"],
                    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
                    getRevision: ["GET /gists/{gist_id}/{sha}"],
                    list: ["GET /gists"],
                    listComments: ["GET /gists/{gist_id}/comments"],
                    listCommits: ["GET /gists/{gist_id}/commits"],
                    listForUser: ["GET /users/{username}/gists"],
                    listForks: ["GET /gists/{gist_id}/forks"],
                    listPublic: ["GET /gists/public"],
                    listStarred: ["GET /gists/starred"],
                    star: ["PUT /gists/{gist_id}/star"],
                    unstar: ["DELETE /gists/{gist_id}/star"],
                    update: ["PATCH /gists/{gist_id}"],
                    updateComment: [
                        "PATCH /gists/{gist_id}/comments/{comment_id}",
                    ],
                },
                git: {
                    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
                    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
                    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
                    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
                    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
                    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
                    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
                    getCommit: [
                        "GET /repos/{owner}/{repo}/git/commits/{commit_sha}",
                    ],
                    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
                    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
                    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
                    listMatchingRefs: [
                        "GET /repos/{owner}/{repo}/git/matching-refs/{ref}",
                    ],
                    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"],
                },
                gitignore: {
                    getAllTemplates: ["GET /gitignore/templates"],
                    getTemplate: ["GET /gitignore/templates/{name}"],
                },
                interactions: {
                    getRestrictionsForAuthenticatedUser: [
                        "GET /user/interaction-limits",
                    ],
                    getRestrictionsForOrg: [
                        "GET /orgs/{org}/interaction-limits",
                    ],
                    getRestrictionsForRepo: [
                        "GET /repos/{owner}/{repo}/interaction-limits",
                    ],
                    getRestrictionsForYourPublicRepos: [
                        "GET /user/interaction-limits",
                        {},
                        {
                            renamed: [
                                "interactions",
                                "getRestrictionsForAuthenticatedUser",
                            ],
                        },
                    ],
                    removeRestrictionsForAuthenticatedUser: [
                        "DELETE /user/interaction-limits",
                    ],
                    removeRestrictionsForOrg: [
                        "DELETE /orgs/{org}/interaction-limits",
                    ],
                    removeRestrictionsForRepo: [
                        "DELETE /repos/{owner}/{repo}/interaction-limits",
                    ],
                    removeRestrictionsForYourPublicRepos: [
                        "DELETE /user/interaction-limits",
                        {},
                        {
                            renamed: [
                                "interactions",
                                "removeRestrictionsForAuthenticatedUser",
                            ],
                        },
                    ],
                    setRestrictionsForAuthenticatedUser: [
                        "PUT /user/interaction-limits",
                    ],
                    setRestrictionsForOrg: [
                        "PUT /orgs/{org}/interaction-limits",
                    ],
                    setRestrictionsForRepo: [
                        "PUT /repos/{owner}/{repo}/interaction-limits",
                    ],
                    setRestrictionsForYourPublicRepos: [
                        "PUT /user/interaction-limits",
                        {},
                        {
                            renamed: [
                                "interactions",
                                "setRestrictionsForAuthenticatedUser",
                            ],
                        },
                    ],
                },
                issues: {
                    addAssignees: [
                        "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees",
                    ],
                    addLabels: [
                        "POST /repos/{owner}/{repo}/issues/{issue_number}/labels",
                    ],
                    checkUserCanBeAssigned: [
                        "GET /repos/{owner}/{repo}/assignees/{assignee}",
                    ],
                    create: ["POST /repos/{owner}/{repo}/issues"],
                    createComment: [
                        "POST /repos/{owner}/{repo}/issues/{issue_number}/comments",
                    ],
                    createLabel: ["POST /repos/{owner}/{repo}/labels"],
                    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
                    deleteComment: [
                        "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}",
                    ],
                    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
                    deleteMilestone: [
                        "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}",
                    ],
                    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
                    getComment: [
                        "GET /repos/{owner}/{repo}/issues/comments/{comment_id}",
                    ],
                    getEvent: [
                        "GET /repos/{owner}/{repo}/issues/events/{event_id}",
                    ],
                    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
                    getMilestone: [
                        "GET /repos/{owner}/{repo}/milestones/{milestone_number}",
                    ],
                    list: ["GET /issues"],
                    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
                    listComments: [
                        "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
                    ],
                    listCommentsForRepo: [
                        "GET /repos/{owner}/{repo}/issues/comments",
                    ],
                    listEvents: [
                        "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
                    ],
                    listEventsForRepo: [
                        "GET /repos/{owner}/{repo}/issues/events",
                    ],
                    listEventsForTimeline: [
                        "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
                        {
                            mediaType: {
                                previews: ["mockingbird"],
                            },
                        },
                    ],
                    listForAuthenticatedUser: ["GET /user/issues"],
                    listForOrg: ["GET /orgs/{org}/issues"],
                    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
                    listLabelsForMilestone: [
                        "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
                    ],
                    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
                    listLabelsOnIssue: [
                        "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
                    ],
                    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
                    lock: [
                        "PUT /repos/{owner}/{repo}/issues/{issue_number}/lock",
                    ],
                    removeAllLabels: [
                        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels",
                    ],
                    removeAssignees: [
                        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees",
                    ],
                    removeLabel: [
                        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}",
                    ],
                    setLabels: [
                        "PUT /repos/{owner}/{repo}/issues/{issue_number}/labels",
                    ],
                    unlock: [
                        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock",
                    ],
                    update: [
                        "PATCH /repos/{owner}/{repo}/issues/{issue_number}",
                    ],
                    updateComment: [
                        "PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}",
                    ],
                    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
                    updateMilestone: [
                        "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}",
                    ],
                },
                licenses: {
                    get: ["GET /licenses/{license}"],
                    getAllCommonlyUsed: ["GET /licenses"],
                    getForRepo: ["GET /repos/{owner}/{repo}/license"],
                },
                markdown: {
                    render: ["POST /markdown"],
                    renderRaw: [
                        "POST /markdown/raw",
                        {
                            headers: {
                                "content-type": "text/plain; charset=utf-8",
                            },
                        },
                    ],
                },
                meta: {
                    get: ["GET /meta"],
                    getOctocat: ["GET /octocat"],
                    getZen: ["GET /zen"],
                    root: ["GET /"],
                },
                migrations: {
                    cancelImport: ["DELETE /repos/{owner}/{repo}/import"],
                    deleteArchiveForAuthenticatedUser: [
                        "DELETE /user/migrations/{migration_id}/archive",
                        {
                            mediaType: {
                                previews: ["wyandotte"],
                            },
                        },
                    ],
                    deleteArchiveForOrg: [
                        "DELETE /orgs/{org}/migrations/{migration_id}/archive",
                        {
                            mediaType: {
                                previews: ["wyandotte"],
                            },
                        },
                    ],
                    downloadArchiveForOrg: [
                        "GET /orgs/{org}/migrations/{migration_id}/archive",
                        {
                            mediaType: {
                                previews: ["wyandotte"],
                            },
                        },
                    ],
                    getArchiveForAuthenticatedUser: [
                        "GET /user/migrations/{migration_id}/archive",
                        {
                            mediaType: {
                                previews: ["wyandotte"],
                            },
                        },
                    ],
                    getCommitAuthors: [
                        "GET /repos/{owner}/{repo}/import/authors",
                    ],
                    getImportStatus: ["GET /repos/{owner}/{repo}/import"],
                    getLargeFiles: [
                        "GET /repos/{owner}/{repo}/import/large_files",
                    ],
                    getStatusForAuthenticatedUser: [
                        "GET /user/migrations/{migration_id}",
                        {
                            mediaType: {
                                previews: ["wyandotte"],
                            },
                        },
                    ],
                    getStatusForOrg: [
                        "GET /orgs/{org}/migrations/{migration_id}",
                        {
                            mediaType: {
                                previews: ["wyandotte"],
                            },
                        },
                    ],
                    listForAuthenticatedUser: [
                        "GET /user/migrations",
                        {
                            mediaType: {
                                previews: ["wyandotte"],
                            },
                        },
                    ],
                    listForOrg: [
                        "GET /orgs/{org}/migrations",
                        {
                            mediaType: {
                                previews: ["wyandotte"],
                            },
                        },
                    ],
                    listReposForOrg: [
                        "GET /orgs/{org}/migrations/{migration_id}/repositories",
                        {
                            mediaType: {
                                previews: ["wyandotte"],
                            },
                        },
                    ],
                    listReposForUser: [
                        "GET /user/migrations/{migration_id}/repositories",
                        {
                            mediaType: {
                                previews: ["wyandotte"],
                            },
                        },
                    ],
                    mapCommitAuthor: [
                        "PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
                    ],
                    setLfsPreference: [
                        "PATCH /repos/{owner}/{repo}/import/lfs",
                    ],
                    startForAuthenticatedUser: ["POST /user/migrations"],
                    startForOrg: ["POST /orgs/{org}/migrations"],
                    startImport: ["PUT /repos/{owner}/{repo}/import"],
                    unlockRepoForAuthenticatedUser: [
                        "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock",
                        {
                            mediaType: {
                                previews: ["wyandotte"],
                            },
                        },
                    ],
                    unlockRepoForOrg: [
                        "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock",
                        {
                            mediaType: {
                                previews: ["wyandotte"],
                            },
                        },
                    ],
                    updateImport: ["PATCH /repos/{owner}/{repo}/import"],
                },
                orgs: {
                    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
                    cancelInvitation: [
                        "DELETE /orgs/{org}/invitations/{invitation_id}",
                    ],
                    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
                    checkMembershipForUser: [
                        "GET /orgs/{org}/members/{username}",
                    ],
                    checkPublicMembershipForUser: [
                        "GET /orgs/{org}/public_members/{username}",
                    ],
                    convertMemberToOutsideCollaborator: [
                        "PUT /orgs/{org}/outside_collaborators/{username}",
                    ],
                    createInvitation: ["POST /orgs/{org}/invitations"],
                    createWebhook: ["POST /orgs/{org}/hooks"],
                    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
                    get: ["GET /orgs/{org}"],
                    getMembershipForAuthenticatedUser: [
                        "GET /user/memberships/orgs/{org}",
                    ],
                    getMembershipForUser: [
                        "GET /orgs/{org}/memberships/{username}",
                    ],
                    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
                    getWebhookConfigForOrg: [
                        "GET /orgs/{org}/hooks/{hook_id}/config",
                    ],
                    getWebhookDelivery: [
                        "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}",
                    ],
                    list: ["GET /organizations"],
                    listAppInstallations: ["GET /orgs/{org}/installations"],
                    listBlockedUsers: ["GET /orgs/{org}/blocks"],
                    listFailedInvitations: [
                        "GET /orgs/{org}/failed_invitations",
                    ],
                    listForAuthenticatedUser: ["GET /user/orgs"],
                    listForUser: ["GET /users/{username}/orgs"],
                    listInvitationTeams: [
                        "GET /orgs/{org}/invitations/{invitation_id}/teams",
                    ],
                    listMembers: ["GET /orgs/{org}/members"],
                    listMembershipsForAuthenticatedUser: [
                        "GET /user/memberships/orgs",
                    ],
                    listOutsideCollaborators: [
                        "GET /orgs/{org}/outside_collaborators",
                    ],
                    listPendingInvitations: ["GET /orgs/{org}/invitations"],
                    listPublicMembers: ["GET /orgs/{org}/public_members"],
                    listWebhookDeliveries: [
                        "GET /orgs/{org}/hooks/{hook_id}/deliveries",
                    ],
                    listWebhooks: ["GET /orgs/{org}/hooks"],
                    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
                    redeliverWebhookDelivery: [
                        "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts",
                    ],
                    removeMember: ["DELETE /orgs/{org}/members/{username}"],
                    removeMembershipForUser: [
                        "DELETE /orgs/{org}/memberships/{username}",
                    ],
                    removeOutsideCollaborator: [
                        "DELETE /orgs/{org}/outside_collaborators/{username}",
                    ],
                    removePublicMembershipForAuthenticatedUser: [
                        "DELETE /orgs/{org}/public_members/{username}",
                    ],
                    setMembershipForUser: [
                        "PUT /orgs/{org}/memberships/{username}",
                    ],
                    setPublicMembershipForAuthenticatedUser: [
                        "PUT /orgs/{org}/public_members/{username}",
                    ],
                    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
                    update: ["PATCH /orgs/{org}"],
                    updateMembershipForAuthenticatedUser: [
                        "PATCH /user/memberships/orgs/{org}",
                    ],
                    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
                    updateWebhookConfigForOrg: [
                        "PATCH /orgs/{org}/hooks/{hook_id}/config",
                    ],
                },
                packages: {
                    deletePackageForAuthenticatedUser: [
                        "DELETE /user/packages/{package_type}/{package_name}",
                    ],
                    deletePackageForOrg: [
                        "DELETE /orgs/{org}/packages/{package_type}/{package_name}",
                    ],
                    deletePackageForUser: [
                        "DELETE /users/{username}/packages/{package_type}/{package_name}",
                    ],
                    deletePackageVersionForAuthenticatedUser: [
                        "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}",
                    ],
                    deletePackageVersionForOrg: [
                        "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}",
                    ],
                    deletePackageVersionForUser: [
                        "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}",
                    ],
                    getAllPackageVersionsForAPackageOwnedByAnOrg: [
                        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
                        {},
                        {
                            renamed: [
                                "packages",
                                "getAllPackageVersionsForPackageOwnedByOrg",
                            ],
                        },
                    ],
                    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser:
                        [
                            "GET /user/packages/{package_type}/{package_name}/versions",
                            {},
                            {
                                renamed: [
                                    "packages",
                                    "getAllPackageVersionsForPackageOwnedByAuthenticatedUser",
                                ],
                            },
                        ],
                    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
                        "GET /user/packages/{package_type}/{package_name}/versions",
                    ],
                    getAllPackageVersionsForPackageOwnedByOrg: [
                        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
                    ],
                    getAllPackageVersionsForPackageOwnedByUser: [
                        "GET /users/{username}/packages/{package_type}/{package_name}/versions",
                    ],
                    getPackageForAuthenticatedUser: [
                        "GET /user/packages/{package_type}/{package_name}",
                    ],
                    getPackageForOrganization: [
                        "GET /orgs/{org}/packages/{package_type}/{package_name}",
                    ],
                    getPackageForUser: [
                        "GET /users/{username}/packages/{package_type}/{package_name}",
                    ],
                    getPackageVersionForAuthenticatedUser: [
                        "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}",
                    ],
                    getPackageVersionForOrganization: [
                        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}",
                    ],
                    getPackageVersionForUser: [
                        "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}",
                    ],
                    listPackagesForAuthenticatedUser: ["GET /user/packages"],
                    listPackagesForOrganization: ["GET /orgs/{org}/packages"],
                    listPackagesForUser: ["GET /user/{username}/packages"],
                    restorePackageForAuthenticatedUser: [
                        "POST /user/packages/{package_type}/{package_name}/restore{?token}",
                    ],
                    restorePackageForOrg: [
                        "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}",
                    ],
                    restorePackageForUser: [
                        "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}",
                    ],
                    restorePackageVersionForAuthenticatedUser: [
                        "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
                    ],
                    restorePackageVersionForOrg: [
                        "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
                    ],
                    restorePackageVersionForUser: [
                        "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
                    ],
                },
                projects: {
                    addCollaborator: [
                        "PUT /projects/{project_id}/collaborators/{username}",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    createCard: [
                        "POST /projects/columns/{column_id}/cards",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    createColumn: [
                        "POST /projects/{project_id}/columns",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    createForAuthenticatedUser: [
                        "POST /user/projects",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    createForOrg: [
                        "POST /orgs/{org}/projects",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    createForRepo: [
                        "POST /repos/{owner}/{repo}/projects",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    delete: [
                        "DELETE /projects/{project_id}",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    deleteCard: [
                        "DELETE /projects/columns/cards/{card_id}",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    deleteColumn: [
                        "DELETE /projects/columns/{column_id}",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    get: [
                        "GET /projects/{project_id}",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    getCard: [
                        "GET /projects/columns/cards/{card_id}",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    getColumn: [
                        "GET /projects/columns/{column_id}",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    getPermissionForUser: [
                        "GET /projects/{project_id}/collaborators/{username}/permission",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    listCards: [
                        "GET /projects/columns/{column_id}/cards",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    listCollaborators: [
                        "GET /projects/{project_id}/collaborators",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    listColumns: [
                        "GET /projects/{project_id}/columns",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    listForOrg: [
                        "GET /orgs/{org}/projects",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    listForRepo: [
                        "GET /repos/{owner}/{repo}/projects",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    listForUser: [
                        "GET /users/{username}/projects",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    moveCard: [
                        "POST /projects/columns/cards/{card_id}/moves",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    moveColumn: [
                        "POST /projects/columns/{column_id}/moves",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    removeCollaborator: [
                        "DELETE /projects/{project_id}/collaborators/{username}",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    update: [
                        "PATCH /projects/{project_id}",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    updateCard: [
                        "PATCH /projects/columns/cards/{card_id}",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    updateColumn: [
                        "PATCH /projects/columns/{column_id}",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                },
                pulls: {
                    checkIfMerged: [
                        "GET /repos/{owner}/{repo}/pulls/{pull_number}/merge",
                    ],
                    create: ["POST /repos/{owner}/{repo}/pulls"],
                    createReplyForReviewComment: [
                        "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies",
                    ],
                    createReview: [
                        "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
                    ],
                    createReviewComment: [
                        "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments",
                    ],
                    deletePendingReview: [
                        "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
                    ],
                    deleteReviewComment: [
                        "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}",
                    ],
                    dismissReview: [
                        "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals",
                    ],
                    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
                    getReview: [
                        "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
                    ],
                    getReviewComment: [
                        "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}",
                    ],
                    list: ["GET /repos/{owner}/{repo}/pulls"],
                    listCommentsForReview: [
                        "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
                    ],
                    listCommits: [
                        "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
                    ],
                    listFiles: [
                        "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
                    ],
                    listRequestedReviewers: [
                        "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
                    ],
                    listReviewComments: [
                        "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
                    ],
                    listReviewCommentsForRepo: [
                        "GET /repos/{owner}/{repo}/pulls/comments",
                    ],
                    listReviews: [
                        "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
                    ],
                    merge: [
                        "PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge",
                    ],
                    removeRequestedReviewers: [
                        "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
                    ],
                    requestReviewers: [
                        "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
                    ],
                    submitReview: [
                        "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events",
                    ],
                    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
                    updateBranch: [
                        "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch",
                        {
                            mediaType: {
                                previews: ["lydian"],
                            },
                        },
                    ],
                    updateReview: [
                        "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
                    ],
                    updateReviewComment: [
                        "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}",
                    ],
                },
                rateLimit: {
                    get: ["GET /rate_limit"],
                },
                reactions: {
                    createForCommitComment: [
                        "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    createForIssue: [
                        "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    createForIssueComment: [
                        "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    createForPullRequestReviewComment: [
                        "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    createForRelease: [
                        "POST /repos/{owner}/{repo}/releases/{release_id}/reactions",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    createForTeamDiscussionCommentInOrg: [
                        "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    createForTeamDiscussionInOrg: [
                        "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    deleteForCommitComment: [
                        "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    deleteForIssue: [
                        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    deleteForIssueComment: [
                        "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    deleteForPullRequestComment: [
                        "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    deleteForTeamDiscussion: [
                        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    deleteForTeamDiscussionComment: [
                        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    deleteLegacy: [
                        "DELETE /reactions/{reaction_id}",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                        {
                            deprecated:
                                "octokit.rest.reactions.deleteLegacy() is deprecated, see https://docs.github.com/rest/reference/reactions/#delete-a-reaction-legacy",
                        },
                    ],
                    listForCommitComment: [
                        "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    listForIssue: [
                        "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    listForIssueComment: [
                        "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    listForPullRequestReviewComment: [
                        "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    listForTeamDiscussionCommentInOrg: [
                        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                    listForTeamDiscussionInOrg: [
                        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
                        {
                            mediaType: {
                                previews: ["squirrel-girl"],
                            },
                        },
                    ],
                },
                repos: {
                    acceptInvitation: [
                        "PATCH /user/repository_invitations/{invitation_id}",
                    ],
                    addAppAccessRestrictions: [
                        "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
                        {},
                        {
                            mapToData: "apps",
                        },
                    ],
                    addCollaborator: [
                        "PUT /repos/{owner}/{repo}/collaborators/{username}",
                    ],
                    addStatusCheckContexts: [
                        "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
                        {},
                        {
                            mapToData: "contexts",
                        },
                    ],
                    addTeamAccessRestrictions: [
                        "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
                        {},
                        {
                            mapToData: "teams",
                        },
                    ],
                    addUserAccessRestrictions: [
                        "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
                        {},
                        {
                            mapToData: "users",
                        },
                    ],
                    checkCollaborator: [
                        "GET /repos/{owner}/{repo}/collaborators/{username}",
                    ],
                    checkVulnerabilityAlerts: [
                        "GET /repos/{owner}/{repo}/vulnerability-alerts",
                        {
                            mediaType: {
                                previews: ["dorian"],
                            },
                        },
                    ],
                    compareCommits: [
                        "GET /repos/{owner}/{repo}/compare/{base}...{head}",
                    ],
                    compareCommitsWithBasehead: [
                        "GET /repos/{owner}/{repo}/compare/{basehead}",
                    ],
                    createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
                    createCommitComment: [
                        "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments",
                    ],
                    createCommitSignatureProtection: [
                        "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
                        {
                            mediaType: {
                                previews: ["zzzax"],
                            },
                        },
                    ],
                    createCommitStatus: [
                        "POST /repos/{owner}/{repo}/statuses/{sha}",
                    ],
                    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
                    createDeployment: [
                        "POST /repos/{owner}/{repo}/deployments",
                    ],
                    createDeploymentStatus: [
                        "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
                    ],
                    createDispatchEvent: [
                        "POST /repos/{owner}/{repo}/dispatches",
                    ],
                    createForAuthenticatedUser: ["POST /user/repos"],
                    createFork: ["POST /repos/{owner}/{repo}/forks"],
                    createInOrg: ["POST /orgs/{org}/repos"],
                    createOrUpdateEnvironment: [
                        "PUT /repos/{owner}/{repo}/environments/{environment_name}",
                    ],
                    createOrUpdateFileContents: [
                        "PUT /repos/{owner}/{repo}/contents/{path}",
                    ],
                    createPagesSite: [
                        "POST /repos/{owner}/{repo}/pages",
                        {
                            mediaType: {
                                previews: ["switcheroo"],
                            },
                        },
                    ],
                    createRelease: ["POST /repos/{owner}/{repo}/releases"],
                    createUsingTemplate: [
                        "POST /repos/{template_owner}/{template_repo}/generate",
                        {
                            mediaType: {
                                previews: ["baptiste"],
                            },
                        },
                    ],
                    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
                    declineInvitation: [
                        "DELETE /user/repository_invitations/{invitation_id}",
                    ],
                    delete: ["DELETE /repos/{owner}/{repo}"],
                    deleteAccessRestrictions: [
                        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions",
                    ],
                    deleteAdminBranchProtection: [
                        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
                    ],
                    deleteAnEnvironment: [
                        "DELETE /repos/{owner}/{repo}/environments/{environment_name}",
                    ],
                    deleteAutolink: [
                        "DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}",
                    ],
                    deleteBranchProtection: [
                        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection",
                    ],
                    deleteCommitComment: [
                        "DELETE /repos/{owner}/{repo}/comments/{comment_id}",
                    ],
                    deleteCommitSignatureProtection: [
                        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
                        {
                            mediaType: {
                                previews: ["zzzax"],
                            },
                        },
                    ],
                    deleteDeployKey: [
                        "DELETE /repos/{owner}/{repo}/keys/{key_id}",
                    ],
                    deleteDeployment: [
                        "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}",
                    ],
                    deleteFile: [
                        "DELETE /repos/{owner}/{repo}/contents/{path}",
                    ],
                    deleteInvitation: [
                        "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}",
                    ],
                    deletePagesSite: [
                        "DELETE /repos/{owner}/{repo}/pages",
                        {
                            mediaType: {
                                previews: ["switcheroo"],
                            },
                        },
                    ],
                    deletePullRequestReviewProtection: [
                        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
                    ],
                    deleteRelease: [
                        "DELETE /repos/{owner}/{repo}/releases/{release_id}",
                    ],
                    deleteReleaseAsset: [
                        "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}",
                    ],
                    deleteWebhook: [
                        "DELETE /repos/{owner}/{repo}/hooks/{hook_id}",
                    ],
                    disableAutomatedSecurityFixes: [
                        "DELETE /repos/{owner}/{repo}/automated-security-fixes",
                        {
                            mediaType: {
                                previews: ["london"],
                            },
                        },
                    ],
                    disableVulnerabilityAlerts: [
                        "DELETE /repos/{owner}/{repo}/vulnerability-alerts",
                        {
                            mediaType: {
                                previews: ["dorian"],
                            },
                        },
                    ],
                    downloadArchive: [
                        "GET /repos/{owner}/{repo}/zipball/{ref}",
                        {},
                        {
                            renamed: ["repos", "downloadZipballArchive"],
                        },
                    ],
                    downloadTarballArchive: [
                        "GET /repos/{owner}/{repo}/tarball/{ref}",
                    ],
                    downloadZipballArchive: [
                        "GET /repos/{owner}/{repo}/zipball/{ref}",
                    ],
                    enableAutomatedSecurityFixes: [
                        "PUT /repos/{owner}/{repo}/automated-security-fixes",
                        {
                            mediaType: {
                                previews: ["london"],
                            },
                        },
                    ],
                    enableVulnerabilityAlerts: [
                        "PUT /repos/{owner}/{repo}/vulnerability-alerts",
                        {
                            mediaType: {
                                previews: ["dorian"],
                            },
                        },
                    ],
                    get: ["GET /repos/{owner}/{repo}"],
                    getAccessRestrictions: [
                        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions",
                    ],
                    getAdminBranchProtection: [
                        "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
                    ],
                    getAllEnvironments: [
                        "GET /repos/{owner}/{repo}/environments",
                    ],
                    getAllStatusCheckContexts: [
                        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
                    ],
                    getAllTopics: [
                        "GET /repos/{owner}/{repo}/topics",
                        {
                            mediaType: {
                                previews: ["mercy"],
                            },
                        },
                    ],
                    getAppsWithAccessToProtectedBranch: [
                        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
                    ],
                    getAutolink: [
                        "GET /repos/{owner}/{repo}/autolinks/{autolink_id}",
                    ],
                    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
                    getBranchProtection: [
                        "GET /repos/{owner}/{repo}/branches/{branch}/protection",
                    ],
                    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
                    getCodeFrequencyStats: [
                        "GET /repos/{owner}/{repo}/stats/code_frequency",
                    ],
                    getCollaboratorPermissionLevel: [
                        "GET /repos/{owner}/{repo}/collaborators/{username}/permission",
                    ],
                    getCombinedStatusForRef: [
                        "GET /repos/{owner}/{repo}/commits/{ref}/status",
                    ],
                    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
                    getCommitActivityStats: [
                        "GET /repos/{owner}/{repo}/stats/commit_activity",
                    ],
                    getCommitComment: [
                        "GET /repos/{owner}/{repo}/comments/{comment_id}",
                    ],
                    getCommitSignatureProtection: [
                        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
                        {
                            mediaType: {
                                previews: ["zzzax"],
                            },
                        },
                    ],
                    getCommunityProfileMetrics: [
                        "GET /repos/{owner}/{repo}/community/profile",
                    ],
                    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
                    getContributorsStats: [
                        "GET /repos/{owner}/{repo}/stats/contributors",
                    ],
                    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
                    getDeployment: [
                        "GET /repos/{owner}/{repo}/deployments/{deployment_id}",
                    ],
                    getDeploymentStatus: [
                        "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}",
                    ],
                    getEnvironment: [
                        "GET /repos/{owner}/{repo}/environments/{environment_name}",
                    ],
                    getLatestPagesBuild: [
                        "GET /repos/{owner}/{repo}/pages/builds/latest",
                    ],
                    getLatestRelease: [
                        "GET /repos/{owner}/{repo}/releases/latest",
                    ],
                    getPages: ["GET /repos/{owner}/{repo}/pages"],
                    getPagesBuild: [
                        "GET /repos/{owner}/{repo}/pages/builds/{build_id}",
                    ],
                    getPagesHealthCheck: [
                        "GET /repos/{owner}/{repo}/pages/health",
                    ],
                    getParticipationStats: [
                        "GET /repos/{owner}/{repo}/stats/participation",
                    ],
                    getPullRequestReviewProtection: [
                        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
                    ],
                    getPunchCardStats: [
                        "GET /repos/{owner}/{repo}/stats/punch_card",
                    ],
                    getReadme: ["GET /repos/{owner}/{repo}/readme"],
                    getReadmeInDirectory: [
                        "GET /repos/{owner}/{repo}/readme/{dir}",
                    ],
                    getRelease: [
                        "GET /repos/{owner}/{repo}/releases/{release_id}",
                    ],
                    getReleaseAsset: [
                        "GET /repos/{owner}/{repo}/releases/assets/{asset_id}",
                    ],
                    getReleaseByTag: [
                        "GET /repos/{owner}/{repo}/releases/tags/{tag}",
                    ],
                    getStatusChecksProtection: [
                        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
                    ],
                    getTeamsWithAccessToProtectedBranch: [
                        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
                    ],
                    getTopPaths: [
                        "GET /repos/{owner}/{repo}/traffic/popular/paths",
                    ],
                    getTopReferrers: [
                        "GET /repos/{owner}/{repo}/traffic/popular/referrers",
                    ],
                    getUsersWithAccessToProtectedBranch: [
                        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
                    ],
                    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
                    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
                    getWebhookConfigForRepo: [
                        "GET /repos/{owner}/{repo}/hooks/{hook_id}/config",
                    ],
                    getWebhookDelivery: [
                        "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}",
                    ],
                    listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
                    listBranches: ["GET /repos/{owner}/{repo}/branches"],
                    listBranchesForHeadCommit: [
                        "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head",
                        {
                            mediaType: {
                                previews: ["groot"],
                            },
                        },
                    ],
                    listCollaborators: [
                        "GET /repos/{owner}/{repo}/collaborators",
                    ],
                    listCommentsForCommit: [
                        "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
                    ],
                    listCommitCommentsForRepo: [
                        "GET /repos/{owner}/{repo}/comments",
                    ],
                    listCommitStatusesForRef: [
                        "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
                    ],
                    listCommits: ["GET /repos/{owner}/{repo}/commits"],
                    listContributors: [
                        "GET /repos/{owner}/{repo}/contributors",
                    ],
                    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
                    listDeploymentStatuses: [
                        "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
                    ],
                    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
                    listForAuthenticatedUser: ["GET /user/repos"],
                    listForOrg: ["GET /orgs/{org}/repos"],
                    listForUser: ["GET /users/{username}/repos"],
                    listForks: ["GET /repos/{owner}/{repo}/forks"],
                    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
                    listInvitationsForAuthenticatedUser: [
                        "GET /user/repository_invitations",
                    ],
                    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
                    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
                    listPublic: ["GET /repositories"],
                    listPullRequestsAssociatedWithCommit: [
                        "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
                        {
                            mediaType: {
                                previews: ["groot"],
                            },
                        },
                    ],
                    listReleaseAssets: [
                        "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
                    ],
                    listReleases: ["GET /repos/{owner}/{repo}/releases"],
                    listTags: ["GET /repos/{owner}/{repo}/tags"],
                    listTeams: ["GET /repos/{owner}/{repo}/teams"],
                    listWebhookDeliveries: [
                        "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
                    ],
                    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
                    merge: ["POST /repos/{owner}/{repo}/merges"],
                    mergeUpstream: [
                        "POST /repos/{owner}/{repo}/merge-upstream",
                    ],
                    pingWebhook: [
                        "POST /repos/{owner}/{repo}/hooks/{hook_id}/pings",
                    ],
                    redeliverWebhookDelivery: [
                        "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts",
                    ],
                    removeAppAccessRestrictions: [
                        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
                        {},
                        {
                            mapToData: "apps",
                        },
                    ],
                    removeCollaborator: [
                        "DELETE /repos/{owner}/{repo}/collaborators/{username}",
                    ],
                    removeStatusCheckContexts: [
                        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
                        {},
                        {
                            mapToData: "contexts",
                        },
                    ],
                    removeStatusCheckProtection: [
                        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
                    ],
                    removeTeamAccessRestrictions: [
                        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
                        {},
                        {
                            mapToData: "teams",
                        },
                    ],
                    removeUserAccessRestrictions: [
                        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
                        {},
                        {
                            mapToData: "users",
                        },
                    ],
                    renameBranch: [
                        "POST /repos/{owner}/{repo}/branches/{branch}/rename",
                    ],
                    replaceAllTopics: [
                        "PUT /repos/{owner}/{repo}/topics",
                        {
                            mediaType: {
                                previews: ["mercy"],
                            },
                        },
                    ],
                    requestPagesBuild: [
                        "POST /repos/{owner}/{repo}/pages/builds",
                    ],
                    setAdminBranchProtection: [
                        "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
                    ],
                    setAppAccessRestrictions: [
                        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
                        {},
                        {
                            mapToData: "apps",
                        },
                    ],
                    setStatusCheckContexts: [
                        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
                        {},
                        {
                            mapToData: "contexts",
                        },
                    ],
                    setTeamAccessRestrictions: [
                        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
                        {},
                        {
                            mapToData: "teams",
                        },
                    ],
                    setUserAccessRestrictions: [
                        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
                        {},
                        {
                            mapToData: "users",
                        },
                    ],
                    testPushWebhook: [
                        "POST /repos/{owner}/{repo}/hooks/{hook_id}/tests",
                    ],
                    transfer: ["POST /repos/{owner}/{repo}/transfer"],
                    update: ["PATCH /repos/{owner}/{repo}"],
                    updateBranchProtection: [
                        "PUT /repos/{owner}/{repo}/branches/{branch}/protection",
                    ],
                    updateCommitComment: [
                        "PATCH /repos/{owner}/{repo}/comments/{comment_id}",
                    ],
                    updateInformationAboutPagesSite: [
                        "PUT /repos/{owner}/{repo}/pages",
                    ],
                    updateInvitation: [
                        "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}",
                    ],
                    updatePullRequestReviewProtection: [
                        "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
                    ],
                    updateRelease: [
                        "PATCH /repos/{owner}/{repo}/releases/{release_id}",
                    ],
                    updateReleaseAsset: [
                        "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}",
                    ],
                    updateStatusCheckPotection: [
                        "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
                        {},
                        {
                            renamed: ["repos", "updateStatusCheckProtection"],
                        },
                    ],
                    updateStatusCheckProtection: [
                        "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
                    ],
                    updateWebhook: [
                        "PATCH /repos/{owner}/{repo}/hooks/{hook_id}",
                    ],
                    updateWebhookConfigForRepo: [
                        "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config",
                    ],
                    uploadReleaseAsset: [
                        "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
                        {
                            baseUrl: "https://uploads.github.com",
                        },
                    ],
                },
                search: {
                    code: ["GET /search/code"],
                    commits: [
                        "GET /search/commits",
                        {
                            mediaType: {
                                previews: ["cloak"],
                            },
                        },
                    ],
                    issuesAndPullRequests: ["GET /search/issues"],
                    labels: ["GET /search/labels"],
                    repos: ["GET /search/repositories"],
                    topics: [
                        "GET /search/topics",
                        {
                            mediaType: {
                                previews: ["mercy"],
                            },
                        },
                    ],
                    users: ["GET /search/users"],
                },
                secretScanning: {
                    getAlert: [
                        "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}",
                    ],
                    listAlertsForOrg: [
                        "GET /orgs/{org}/secret-scanning/alerts",
                    ],
                    listAlertsForRepo: [
                        "GET /repos/{owner}/{repo}/secret-scanning/alerts",
                    ],
                    updateAlert: [
                        "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}",
                    ],
                },
                teams: {
                    addOrUpdateMembershipForUserInOrg: [
                        "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}",
                    ],
                    addOrUpdateProjectPermissionsInOrg: [
                        "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    addOrUpdateRepoPermissionsInOrg: [
                        "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
                    ],
                    checkPermissionsForProjectInOrg: [
                        "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    checkPermissionsForRepoInOrg: [
                        "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
                    ],
                    create: ["POST /orgs/{org}/teams"],
                    createDiscussionCommentInOrg: [
                        "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
                    ],
                    createDiscussionInOrg: [
                        "POST /orgs/{org}/teams/{team_slug}/discussions",
                    ],
                    deleteDiscussionCommentInOrg: [
                        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
                    ],
                    deleteDiscussionInOrg: [
                        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
                    ],
                    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
                    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
                    getDiscussionCommentInOrg: [
                        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
                    ],
                    getDiscussionInOrg: [
                        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
                    ],
                    getMembershipForUserInOrg: [
                        "GET /orgs/{org}/teams/{team_slug}/memberships/{username}",
                    ],
                    list: ["GET /orgs/{org}/teams"],
                    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
                    listDiscussionCommentsInOrg: [
                        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
                    ],
                    listDiscussionsInOrg: [
                        "GET /orgs/{org}/teams/{team_slug}/discussions",
                    ],
                    listForAuthenticatedUser: ["GET /user/teams"],
                    listMembersInOrg: [
                        "GET /orgs/{org}/teams/{team_slug}/members",
                    ],
                    listPendingInvitationsInOrg: [
                        "GET /orgs/{org}/teams/{team_slug}/invitations",
                    ],
                    listProjectsInOrg: [
                        "GET /orgs/{org}/teams/{team_slug}/projects",
                        {
                            mediaType: {
                                previews: ["inertia"],
                            },
                        },
                    ],
                    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
                    removeMembershipForUserInOrg: [
                        "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}",
                    ],
                    removeProjectInOrg: [
                        "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}",
                    ],
                    removeRepoInOrg: [
                        "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
                    ],
                    updateDiscussionCommentInOrg: [
                        "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
                    ],
                    updateDiscussionInOrg: [
                        "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
                    ],
                    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"],
                },
                users: {
                    addEmailForAuthenticated: ["POST /user/emails"],
                    block: ["PUT /user/blocks/{username}"],
                    checkBlocked: ["GET /user/blocks/{username}"],
                    checkFollowingForUser: [
                        "GET /users/{username}/following/{target_user}",
                    ],
                    checkPersonIsFollowedByAuthenticated: [
                        "GET /user/following/{username}",
                    ],
                    createGpgKeyForAuthenticated: ["POST /user/gpg_keys"],
                    createPublicSshKeyForAuthenticated: ["POST /user/keys"],
                    deleteEmailForAuthenticated: ["DELETE /user/emails"],
                    deleteGpgKeyForAuthenticated: [
                        "DELETE /user/gpg_keys/{gpg_key_id}",
                    ],
                    deletePublicSshKeyForAuthenticated: [
                        "DELETE /user/keys/{key_id}",
                    ],
                    follow: ["PUT /user/following/{username}"],
                    getAuthenticated: ["GET /user"],
                    getByUsername: ["GET /users/{username}"],
                    getContextForUser: ["GET /users/{username}/hovercard"],
                    getGpgKeyForAuthenticated: [
                        "GET /user/gpg_keys/{gpg_key_id}",
                    ],
                    getPublicSshKeyForAuthenticated: [
                        "GET /user/keys/{key_id}",
                    ],
                    list: ["GET /users"],
                    listBlockedByAuthenticated: ["GET /user/blocks"],
                    listEmailsForAuthenticated: ["GET /user/emails"],
                    listFollowedByAuthenticated: ["GET /user/following"],
                    listFollowersForAuthenticatedUser: ["GET /user/followers"],
                    listFollowersForUser: ["GET /users/{username}/followers"],
                    listFollowingForUser: ["GET /users/{username}/following"],
                    listGpgKeysForAuthenticated: ["GET /user/gpg_keys"],
                    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
                    listPublicEmailsForAuthenticated: [
                        "GET /user/public_emails",
                    ],
                    listPublicKeysForUser: ["GET /users/{username}/keys"],
                    listPublicSshKeysForAuthenticated: ["GET /user/keys"],
                    setPrimaryEmailVisibilityForAuthenticated: [
                        "PATCH /user/email/visibility",
                    ],
                    unblock: ["DELETE /user/blocks/{username}"],
                    unfollow: ["DELETE /user/following/{username}"],
                    updateAuthenticated: ["PATCH /user"],
                },
            };

            const VERSION = "5.10.4";

            function endpointsToMethods(octokit, endpointsMap) {
                const newMethods = {};

                for (const [scope, endpoints] of Object.entries(endpointsMap)) {
                    for (const [methodName, endpoint] of Object.entries(
                        endpoints
                    )) {
                        const [route, defaults, decorations] = endpoint;
                        const [method, url] = route.split(/ /);
                        const endpointDefaults = Object.assign(
                            {
                                method,
                                url,
                            },
                            defaults
                        );

                        if (!newMethods[scope]) {
                            newMethods[scope] = {};
                        }

                        const scopeMethods = newMethods[scope];

                        if (decorations) {
                            scopeMethods[methodName] = decorate(
                                octokit,
                                scope,
                                methodName,
                                endpointDefaults,
                                decorations
                            );
                            continue;
                        }

                        scopeMethods[methodName] =
                            octokit.request.defaults(endpointDefaults);
                    }
                }

                return newMethods;
            }

            function decorate(
                octokit,
                scope,
                methodName,
                defaults,
                decorations
            ) {
                const requestWithDefaults = octokit.request.defaults(defaults);
                /* istanbul ignore next */

                function withDecorations(...args) {
                    // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
                    let options = requestWithDefaults.endpoint.merge(...args); // There are currently no other decorations than `.mapToData`

                    if (decorations.mapToData) {
                        options = Object.assign({}, options, {
                            data: options[decorations.mapToData],
                            [decorations.mapToData]: undefined,
                        });
                        return requestWithDefaults(options);
                    }

                    if (decorations.renamed) {
                        const [newScope, newMethodName] = decorations.renamed;
                        octokit.log.warn(
                            `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`
                        );
                    }

                    if (decorations.deprecated) {
                        octokit.log.warn(decorations.deprecated);
                    }

                    if (decorations.renamedParameters) {
                        // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
                        const options = requestWithDefaults.endpoint.merge(
                            ...args
                        );

                        for (const [name, alias] of Object.entries(
                            decorations.renamedParameters
                        )) {
                            if (name in options) {
                                octokit.log.warn(
                                    `"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`
                                );

                                if (!(alias in options)) {
                                    options[alias] = options[name];
                                }

                                delete options[name];
                            }
                        }

                        return requestWithDefaults(options);
                    } // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488

                    return requestWithDefaults(...args);
                }

                return Object.assign(withDecorations, requestWithDefaults);
            }

            function restEndpointMethods(octokit) {
                const api = endpointsToMethods(octokit, Endpoints);
                return {
                    rest: api,
                };
            }
            restEndpointMethods.VERSION = VERSION;
            function legacyRestEndpointMethods(octokit) {
                const api = endpointsToMethods(octokit, Endpoints);
                return _objectSpread2(
                    _objectSpread2({}, api),
                    {},
                    {
                        rest: api,
                    }
                );
            }
            legacyRestEndpointMethods.VERSION = VERSION;

            exports.legacyRestEndpointMethods = legacyRestEndpointMethods;
            exports.restEndpointMethods = restEndpointMethods;
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ 537: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });

            function _interopDefault(ex) {
                return ex && typeof ex === "object" && "default" in ex
                    ? ex["default"]
                    : ex;
            }

            var deprecation = __nccwpck_require__(8932);
            var once = _interopDefault(__nccwpck_require__(1223));

            const logOnceCode = once((deprecation) =>
                console.warn(deprecation)
            );
            const logOnceHeaders = once((deprecation) =>
                console.warn(deprecation)
            );
            /**
             * Error with extra properties to help with debugging
             */

            class RequestError extends Error {
                constructor(message, statusCode, options) {
                    super(message); // Maintains proper stack trace (only available on V8)

                    /* istanbul ignore next */

                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(this, this.constructor);
                    }

                    this.name = "HttpError";
                    this.status = statusCode;
                    let headers;

                    if (
                        "headers" in options &&
                        typeof options.headers !== "undefined"
                    ) {
                        headers = options.headers;
                    }

                    if ("response" in options) {
                        this.response = options.response;
                        headers = options.response.headers;
                    } // redact request credentials without mutating original request options

                    const requestCopy = Object.assign({}, options.request);

                    if (options.request.headers.authorization) {
                        requestCopy.headers = Object.assign(
                            {},
                            options.request.headers,
                            {
                                authorization:
                                    options.request.headers.authorization.replace(
                                        / .*$/,
                                        " [REDACTED]"
                                    ),
                            }
                        );
                    }

                    requestCopy.url = requestCopy.url // client_id & client_secret can be passed as URL query parameters to increase rate limit
                        // see https://developer.github.com/v3/#increasing-the-unauthenticated-rate-limit-for-oauth-applications
                        .replace(
                            /\bclient_secret=\w+/g,
                            "client_secret=[REDACTED]"
                        ) // OAuth tokens can be passed as URL query parameters, although it is not recommended
                        // see https://developer.github.com/v3/#oauth2-token-sent-in-a-header
                        .replace(
                            /\baccess_token=\w+/g,
                            "access_token=[REDACTED]"
                        );
                    this.request = requestCopy; // deprecations

                    Object.defineProperty(this, "code", {
                        get() {
                            logOnceCode(
                                new deprecation.Deprecation(
                                    "[@octokit/request-error] `error.code` is deprecated, use `error.status`."
                                )
                            );
                            return statusCode;
                        },
                    });
                    Object.defineProperty(this, "headers", {
                        get() {
                            logOnceHeaders(
                                new deprecation.Deprecation(
                                    "[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."
                                )
                            );
                            return headers || {};
                        },
                    });
                }
            }

            exports.RequestError = RequestError;
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ 6234: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });

            function _interopDefault(ex) {
                return ex && typeof ex === "object" && "default" in ex
                    ? ex["default"]
                    : ex;
            }

            var endpoint = __nccwpck_require__(9440);
            var universalUserAgent = __nccwpck_require__(5030);
            var isPlainObject = __nccwpck_require__(3287);
            var nodeFetch = _interopDefault(__nccwpck_require__(1768));
            var requestError = __nccwpck_require__(537);

            const VERSION = "5.6.1";

            function getBufferResponse(response) {
                return response.arrayBuffer();
            }

            function fetchWrapper(requestOptions) {
                const log =
                    requestOptions.request && requestOptions.request.log
                        ? requestOptions.request.log
                        : console;

                if (
                    isPlainObject.isPlainObject(requestOptions.body) ||
                    Array.isArray(requestOptions.body)
                ) {
                    requestOptions.body = JSON.stringify(requestOptions.body);
                }

                let headers = {};
                let status;
                let url;
                const fetch =
                    (requestOptions.request && requestOptions.request.fetch) ||
                    nodeFetch;
                return fetch(
                    requestOptions.url,
                    Object.assign(
                        {
                            method: requestOptions.method,
                            body: requestOptions.body,
                            headers: requestOptions.headers,
                            redirect: requestOptions.redirect,
                        }, // `requestOptions.request.agent` type is incompatible
                        // see https://github.com/octokit/types.ts/pull/264
                        requestOptions.request
                    )
                )
                    .then(async (response) => {
                        url = response.url;
                        status = response.status;

                        for (const keyAndValue of response.headers) {
                            headers[keyAndValue[0]] = keyAndValue[1];
                        }

                        if ("deprecation" in headers) {
                            const matches =
                                headers.link &&
                                headers.link.match(
                                    /<([^>]+)>; rel="deprecation"/
                                );
                            const deprecationLink = matches && matches.pop();
                            log.warn(
                                `[@octokit/request] "${requestOptions.method} ${
                                    requestOptions.url
                                }" is deprecated. It is scheduled to be removed on ${
                                    headers.sunset
                                }${
                                    deprecationLink
                                        ? `. See ${deprecationLink}`
                                        : ""
                                }`
                            );
                        }

                        if (status === 204 || status === 205) {
                            return;
                        } // GitHub API returns 200 for HEAD requests

                        if (requestOptions.method === "HEAD") {
                            if (status < 400) {
                                return;
                            }

                            throw new requestError.RequestError(
                                response.statusText,
                                status,
                                {
                                    response: {
                                        url,
                                        status,
                                        headers,
                                        data: undefined,
                                    },
                                    request: requestOptions,
                                }
                            );
                        }

                        if (status === 304) {
                            throw new requestError.RequestError(
                                "Not modified",
                                status,
                                {
                                    response: {
                                        url,
                                        status,
                                        headers,
                                        data: await getResponseData(response),
                                    },
                                    request: requestOptions,
                                }
                            );
                        }

                        if (status >= 400) {
                            const data = await getResponseData(response);
                            const error = new requestError.RequestError(
                                toErrorMessage(data),
                                status,
                                {
                                    response: {
                                        url,
                                        status,
                                        headers,
                                        data,
                                    },
                                    request: requestOptions,
                                }
                            );
                            throw error;
                        }

                        return getResponseData(response);
                    })
                    .then((data) => {
                        return {
                            status,
                            url,
                            headers,
                            data,
                        };
                    })
                    .catch((error) => {
                        if (error instanceof requestError.RequestError)
                            throw error;
                        throw new requestError.RequestError(
                            error.message,
                            500,
                            {
                                request: requestOptions,
                            }
                        );
                    });
            }

            async function getResponseData(response) {
                const contentType = response.headers.get("content-type");

                if (/application\/json/.test(contentType)) {
                    return response.json();
                }

                if (
                    !contentType ||
                    /^text\/|charset=utf-8$/.test(contentType)
                ) {
                    return response.text();
                }

                return getBufferResponse(response);
            }

            function toErrorMessage(data) {
                if (typeof data === "string") return data; // istanbul ignore else - just in case

                if ("message" in data) {
                    if (Array.isArray(data.errors)) {
                        return `${data.message}: ${data.errors
                            .map(JSON.stringify)
                            .join(", ")}`;
                    }

                    return data.message;
                } // istanbul ignore next - just in case

                return `Unknown error: ${JSON.stringify(data)}`;
            }

            function withDefaults(oldEndpoint, newDefaults) {
                const endpoint = oldEndpoint.defaults(newDefaults);

                const newApi = function (route, parameters) {
                    const endpointOptions = endpoint.merge(route, parameters);

                    if (
                        !endpointOptions.request ||
                        !endpointOptions.request.hook
                    ) {
                        return fetchWrapper(endpoint.parse(endpointOptions));
                    }

                    const request = (route, parameters) => {
                        return fetchWrapper(
                            endpoint.parse(endpoint.merge(route, parameters))
                        );
                    };

                    Object.assign(request, {
                        endpoint,
                        defaults: withDefaults.bind(null, endpoint),
                    });
                    return endpointOptions.request.hook(
                        request,
                        endpointOptions
                    );
                };

                return Object.assign(newApi, {
                    endpoint,
                    defaults: withDefaults.bind(null, endpoint),
                });
            }

            const request = withDefaults(endpoint.endpoint, {
                headers: {
                    "user-agent": `octokit-request.js/${VERSION} ${universalUserAgent.getUserAgent()}`,
                },
            });

            exports.request = request;
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ 1768: /***/ (module, exports, __nccwpck_require__) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });

            function _interopDefault(ex) {
                return ex && typeof ex === "object" && "default" in ex
                    ? ex["default"]
                    : ex;
            }

            var Stream = _interopDefault(__nccwpck_require__(2413));
            var http = _interopDefault(__nccwpck_require__(8605));
            var Url = _interopDefault(__nccwpck_require__(8835));
            var https = _interopDefault(__nccwpck_require__(7211));
            var zlib = _interopDefault(__nccwpck_require__(8761));

            // Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js

            // fix for "Readable" isn't a named export issue
            const Readable = Stream.Readable;

            const BUFFER = Symbol("buffer");
            const TYPE = Symbol("type");

            class Blob {
                constructor() {
                    this[TYPE] = "";

                    const blobParts = arguments[0];
                    const options = arguments[1];

                    const buffers = [];
                    let size = 0;

                    if (blobParts) {
                        const a = blobParts;
                        const length = Number(a.length);
                        for (let i = 0; i < length; i++) {
                            const element = a[i];
                            let buffer;
                            if (element instanceof Buffer) {
                                buffer = element;
                            } else if (ArrayBuffer.isView(element)) {
                                buffer = Buffer.from(
                                    element.buffer,
                                    element.byteOffset,
                                    element.byteLength
                                );
                            } else if (element instanceof ArrayBuffer) {
                                buffer = Buffer.from(element);
                            } else if (element instanceof Blob) {
                                buffer = element[BUFFER];
                            } else {
                                buffer = Buffer.from(
                                    typeof element === "string"
                                        ? element
                                        : String(element)
                                );
                            }
                            size += buffer.length;
                            buffers.push(buffer);
                        }
                    }

                    this[BUFFER] = Buffer.concat(buffers);

                    let type =
                        options &&
                        options.type !== undefined &&
                        String(options.type).toLowerCase();
                    if (type && !/[^\u0020-\u007E]/.test(type)) {
                        this[TYPE] = type;
                    }
                }
                get size() {
                    return this[BUFFER].length;
                }
                get type() {
                    return this[TYPE];
                }
                text() {
                    return Promise.resolve(this[BUFFER].toString());
                }
                arrayBuffer() {
                    const buf = this[BUFFER];
                    const ab = buf.buffer.slice(
                        buf.byteOffset,
                        buf.byteOffset + buf.byteLength
                    );
                    return Promise.resolve(ab);
                }
                stream() {
                    const readable = new Readable();
                    readable._read = function () {};
                    readable.push(this[BUFFER]);
                    readable.push(null);
                    return readable;
                }
                toString() {
                    return "[object Blob]";
                }
                slice() {
                    const size = this.size;

                    const start = arguments[0];
                    const end = arguments[1];
                    let relativeStart, relativeEnd;
                    if (start === undefined) {
                        relativeStart = 0;
                    } else if (start < 0) {
                        relativeStart = Math.max(size + start, 0);
                    } else {
                        relativeStart = Math.min(start, size);
                    }
                    if (end === undefined) {
                        relativeEnd = size;
                    } else if (end < 0) {
                        relativeEnd = Math.max(size + end, 0);
                    } else {
                        relativeEnd = Math.min(end, size);
                    }
                    const span = Math.max(relativeEnd - relativeStart, 0);

                    const buffer = this[BUFFER];
                    const slicedBuffer = buffer.slice(
                        relativeStart,
                        relativeStart + span
                    );
                    const blob = new Blob([], { type: arguments[2] });
                    blob[BUFFER] = slicedBuffer;
                    return blob;
                }
            }

            Object.defineProperties(Blob.prototype, {
                size: { enumerable: true },
                type: { enumerable: true },
                slice: { enumerable: true },
            });

            Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
                value: "Blob",
                writable: false,
                enumerable: false,
                configurable: true,
            });

            /**
             * fetch-error.js
             *
             * FetchError interface for operational errors
             */

            /**
             * Create FetchError instance
             *
             * @param   String      message      Error message for human
             * @param   String      type         Error type for machine
             * @param   String      systemError  For Node.js system error
             * @return  FetchError
             */
            function FetchError(message, type, systemError) {
                Error.call(this, message);

                this.message = message;
                this.type = type;

                // when err.type is `system`, err.code contains system error code
                if (systemError) {
                    this.code = this.errno = systemError.code;
                }

                // hide custom error implementation details from end-users
                Error.captureStackTrace(this, this.constructor);
            }

            FetchError.prototype = Object.create(Error.prototype);
            FetchError.prototype.constructor = FetchError;
            FetchError.prototype.name = "FetchError";

            let convert;
            try {
                convert = __nccwpck_require__(2877).convert;
            } catch (e) {}

            const INTERNALS = Symbol("Body internals");

            // fix an issue where "PassThrough" isn't a named export for node <10
            const PassThrough = Stream.PassThrough;

            /**
             * Body mixin
             *
             * Ref: https://fetch.spec.whatwg.org/#body
             *
             * @param   Stream  body  Readable stream
             * @param   Object  opts  Response options
             * @return  Void
             */
            function Body(body) {
                var _this = this;

                var _ref =
                        arguments.length > 1 && arguments[1] !== undefined
                            ? arguments[1]
                            : {},
                    _ref$size = _ref.size;

                let size = _ref$size === undefined ? 0 : _ref$size;
                var _ref$timeout = _ref.timeout;
                let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

                if (body == null) {
                    // body is undefined or null
                    body = null;
                } else if (isURLSearchParams(body)) {
                    // body is a URLSearchParams
                    body = Buffer.from(body.toString());
                } else if (isBlob(body));
                else if (Buffer.isBuffer(body));
                else if (
                    Object.prototype.toString.call(body) ===
                    "[object ArrayBuffer]"
                ) {
                    // body is ArrayBuffer
                    body = Buffer.from(body);
                } else if (ArrayBuffer.isView(body)) {
                    // body is ArrayBufferView
                    body = Buffer.from(
                        body.buffer,
                        body.byteOffset,
                        body.byteLength
                    );
                } else if (body instanceof Stream);
                else {
                    // none of the above
                    // coerce to string then buffer
                    body = Buffer.from(String(body));
                }
                this[INTERNALS] = {
                    body,
                    disturbed: false,
                    error: null,
                };
                this.size = size;
                this.timeout = timeout;

                if (body instanceof Stream) {
                    body.on("error", function (err) {
                        const error =
                            err.name === "AbortError"
                                ? err
                                : new FetchError(
                                      `Invalid response body while trying to fetch ${_this.url}: ${err.message}`,
                                      "system",
                                      err
                                  );
                        _this[INTERNALS].error = error;
                    });
                }
            }

            Body.prototype = {
                get body() {
                    return this[INTERNALS].body;
                },

                get bodyUsed() {
                    return this[INTERNALS].disturbed;
                },

                /**
                 * Decode response as ArrayBuffer
                 *
                 * @return  Promise
                 */
                arrayBuffer() {
                    return consumeBody.call(this).then(function (buf) {
                        return buf.buffer.slice(
                            buf.byteOffset,
                            buf.byteOffset + buf.byteLength
                        );
                    });
                },

                /**
                 * Return raw response as Blob
                 *
                 * @return Promise
                 */
                blob() {
                    let ct =
                        (this.headers && this.headers.get("content-type")) ||
                        "";
                    return consumeBody.call(this).then(function (buf) {
                        return Object.assign(
                            // Prevent copying
                            new Blob([], {
                                type: ct.toLowerCase(),
                            }),
                            {
                                [BUFFER]: buf,
                            }
                        );
                    });
                },

                /**
                 * Decode response as json
                 *
                 * @return  Promise
                 */
                json() {
                    var _this2 = this;

                    return consumeBody.call(this).then(function (buffer) {
                        try {
                            return JSON.parse(buffer.toString());
                        } catch (err) {
                            return Body.Promise.reject(
                                new FetchError(
                                    `invalid json response body at ${_this2.url} reason: ${err.message}`,
                                    "invalid-json"
                                )
                            );
                        }
                    });
                },

                /**
                 * Decode response as text
                 *
                 * @return  Promise
                 */
                text() {
                    return consumeBody.call(this).then(function (buffer) {
                        return buffer.toString();
                    });
                },

                /**
                 * Decode response as buffer (non-spec api)
                 *
                 * @return  Promise
                 */
                buffer() {
                    return consumeBody.call(this);
                },

                /**
                 * Decode response as text, while automatically detecting the encoding and
                 * trying to decode to UTF-8 (non-spec api)
                 *
                 * @return  Promise
                 */
                textConverted() {
                    var _this3 = this;

                    return consumeBody.call(this).then(function (buffer) {
                        return convertBody(buffer, _this3.headers);
                    });
                },
            };

            // In browsers, all properties are enumerable.
            Object.defineProperties(Body.prototype, {
                body: { enumerable: true },
                bodyUsed: { enumerable: true },
                arrayBuffer: { enumerable: true },
                blob: { enumerable: true },
                json: { enumerable: true },
                text: { enumerable: true },
            });

            Body.mixIn = function (proto) {
                for (const name of Object.getOwnPropertyNames(Body.prototype)) {
                    // istanbul ignore else: future proof
                    if (!(name in proto)) {
                        const desc = Object.getOwnPropertyDescriptor(
                            Body.prototype,
                            name
                        );
                        Object.defineProperty(proto, name, desc);
                    }
                }
            };

            /**
             * Consume and convert an entire Body to a Buffer.
             *
             * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
             *
             * @return  Promise
             */
            function consumeBody() {
                var _this4 = this;

                if (this[INTERNALS].disturbed) {
                    return Body.Promise.reject(
                        new TypeError(`body used already for: ${this.url}`)
                    );
                }

                this[INTERNALS].disturbed = true;

                if (this[INTERNALS].error) {
                    return Body.Promise.reject(this[INTERNALS].error);
                }

                let body = this.body;

                // body is null
                if (body === null) {
                    return Body.Promise.resolve(Buffer.alloc(0));
                }

                // body is blob
                if (isBlob(body)) {
                    body = body.stream();
                }

                // body is buffer
                if (Buffer.isBuffer(body)) {
                    return Body.Promise.resolve(body);
                }

                // istanbul ignore if: should never happen
                if (!(body instanceof Stream)) {
                    return Body.Promise.resolve(Buffer.alloc(0));
                }

                // body is stream
                // get ready to actually consume the body
                let accum = [];
                let accumBytes = 0;
                let abort = false;

                return new Body.Promise(function (resolve, reject) {
                    let resTimeout;

                    // allow timeout on slow response body
                    if (_this4.timeout) {
                        resTimeout = setTimeout(function () {
                            abort = true;
                            reject(
                                new FetchError(
                                    `Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`,
                                    "body-timeout"
                                )
                            );
                        }, _this4.timeout);
                    }

                    // handle stream errors
                    body.on("error", function (err) {
                        if (err.name === "AbortError") {
                            // if the request was aborted, reject with this Error
                            abort = true;
                            reject(err);
                        } else {
                            // other errors, such as incorrect content-encoding
                            reject(
                                new FetchError(
                                    `Invalid response body while trying to fetch ${_this4.url}: ${err.message}`,
                                    "system",
                                    err
                                )
                            );
                        }
                    });

                    body.on("data", function (chunk) {
                        if (abort || chunk === null) {
                            return;
                        }

                        if (
                            _this4.size &&
                            accumBytes + chunk.length > _this4.size
                        ) {
                            abort = true;
                            reject(
                                new FetchError(
                                    `content size at ${_this4.url} over limit: ${_this4.size}`,
                                    "max-size"
                                )
                            );
                            return;
                        }

                        accumBytes += chunk.length;
                        accum.push(chunk);
                    });

                    body.on("end", function () {
                        if (abort) {
                            return;
                        }

                        clearTimeout(resTimeout);

                        try {
                            resolve(Buffer.concat(accum, accumBytes));
                        } catch (err) {
                            // handle streams that have accumulated too much data (issue #414)
                            reject(
                                new FetchError(
                                    `Could not create Buffer from response body for ${_this4.url}: ${err.message}`,
                                    "system",
                                    err
                                )
                            );
                        }
                    });
                });
            }

            /**
             * Detect buffer encoding and convert to target encoding
             * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
             *
             * @param   Buffer  buffer    Incoming buffer
             * @param   String  encoding  Target encoding
             * @return  String
             */
            function convertBody(buffer, headers) {
                if (typeof convert !== "function") {
                    throw new Error(
                        "The package `encoding` must be installed to use the textConverted() function"
                    );
                }

                const ct = headers.get("content-type");
                let charset = "utf-8";
                let res, str;

                // header
                if (ct) {
                    res = /charset=([^;]*)/i.exec(ct);
                }

                // no charset in content type, peek at response body for at most 1024 bytes
                str = buffer.slice(0, 1024).toString();

                // html5
                if (!res && str) {
                    res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
                }

                // html4
                if (!res && str) {
                    res =
                        /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(
                            str
                        );
                    if (!res) {
                        res =
                            /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(
                                str
                            );
                        if (res) {
                            res.pop(); // drop last quote
                        }
                    }

                    if (res) {
                        res = /charset=(.*)/i.exec(res.pop());
                    }
                }

                // xml
                if (!res && str) {
                    res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
                }

                // found charset
                if (res) {
                    charset = res.pop();

                    // prevent decode issues when sites use incorrect encoding
                    // ref: https://hsivonen.fi/encoding-menu/
                    if (charset === "gb2312" || charset === "gbk") {
                        charset = "gb18030";
                    }
                }

                // turn raw buffers into a single utf-8 buffer
                return convert(buffer, "UTF-8", charset).toString();
            }

            /**
             * Detect a URLSearchParams object
             * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
             *
             * @param   Object  obj     Object to detect by type or brand
             * @return  String
             */
            function isURLSearchParams(obj) {
                // Duck-typing as a necessary condition.
                if (
                    typeof obj !== "object" ||
                    typeof obj.append !== "function" ||
                    typeof obj.delete !== "function" ||
                    typeof obj.get !== "function" ||
                    typeof obj.getAll !== "function" ||
                    typeof obj.has !== "function" ||
                    typeof obj.set !== "function"
                ) {
                    return false;
                }

                // Brand-checking and more duck-typing as optional condition.
                return (
                    obj.constructor.name === "URLSearchParams" ||
                    Object.prototype.toString.call(obj) ===
                        "[object URLSearchParams]" ||
                    typeof obj.sort === "function"
                );
            }

            /**
             * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
             * @param  {*} obj
             * @return {boolean}
             */
            function isBlob(obj) {
                return (
                    typeof obj === "object" &&
                    typeof obj.arrayBuffer === "function" &&
                    typeof obj.type === "string" &&
                    typeof obj.stream === "function" &&
                    typeof obj.constructor === "function" &&
                    typeof obj.constructor.name === "string" &&
                    /^(Blob|File)$/.test(obj.constructor.name) &&
                    /^(Blob|File)$/.test(obj[Symbol.toStringTag])
                );
            }

            /**
             * Clone body given Res/Req instance
             *
             * @param   Mixed  instance  Response or Request instance
             * @return  Mixed
             */
            function clone(instance) {
                let p1, p2;
                let body = instance.body;

                // don't allow cloning a used body
                if (instance.bodyUsed) {
                    throw new Error("cannot clone body after it is used");
                }

                // check that body is a stream and not form-data object
                // note: we can't clone the form-data object without having it as a dependency
                if (
                    body instanceof Stream &&
                    typeof body.getBoundary !== "function"
                ) {
                    // tee instance body
                    p1 = new PassThrough();
                    p2 = new PassThrough();
                    body.pipe(p1);
                    body.pipe(p2);
                    // set instance body to teed body and return the other teed body
                    instance[INTERNALS].body = p1;
                    body = p2;
                }

                return body;
            }

            /**
             * Performs the operation "extract a `Content-Type` value from |object|" as
             * specified in the specification:
             * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
             *
             * This function assumes that instance.body is present.
             *
             * @param   Mixed  instance  Any options.body input
             */
            function extractContentType(body) {
                if (body === null) {
                    // body is null
                    return null;
                } else if (typeof body === "string") {
                    // body is string
                    return "text/plain;charset=UTF-8";
                } else if (isURLSearchParams(body)) {
                    // body is a URLSearchParams
                    return "application/x-www-form-urlencoded;charset=UTF-8";
                } else if (isBlob(body)) {
                    // body is blob
                    return body.type || null;
                } else if (Buffer.isBuffer(body)) {
                    // body is buffer
                    return null;
                } else if (
                    Object.prototype.toString.call(body) ===
                    "[object ArrayBuffer]"
                ) {
                    // body is ArrayBuffer
                    return null;
                } else if (ArrayBuffer.isView(body)) {
                    // body is ArrayBufferView
                    return null;
                } else if (typeof body.getBoundary === "function") {
                    // detect form data input from form-data module
                    return `multipart/form-data;boundary=${body.getBoundary()}`;
                } else if (body instanceof Stream) {
                    // body is stream
                    // can't really do much about this
                    return null;
                } else {
                    // Body constructor defaults other things to string
                    return "text/plain;charset=UTF-8";
                }
            }

            /**
             * The Fetch Standard treats this as if "total bytes" is a property on the body.
             * For us, we have to explicitly get it with a function.
             *
             * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
             *
             * @param   Body    instance   Instance of Body
             * @return  Number?            Number of bytes, or null if not possible
             */
            function getTotalBytes(instance) {
                const body = instance.body;

                if (body === null) {
                    // body is null
                    return 0;
                } else if (isBlob(body)) {
                    return body.size;
                } else if (Buffer.isBuffer(body)) {
                    // body is buffer
                    return body.length;
                } else if (body && typeof body.getLengthSync === "function") {
                    // detect form data input from form-data module
                    if (
                        (body._lengthRetrievers &&
                            body._lengthRetrievers.length == 0) || // 1.x
                        (body.hasKnownLength && body.hasKnownLength())
                    ) {
                        // 2.x
                        return body.getLengthSync();
                    }
                    return null;
                } else {
                    // body is stream
                    return null;
                }
            }

            /**
             * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
             *
             * @param   Body    instance   Instance of Body
             * @return  Void
             */
            function writeToStream(dest, instance) {
                const body = instance.body;

                if (body === null) {
                    // body is null
                    dest.end();
                } else if (isBlob(body)) {
                    body.stream().pipe(dest);
                } else if (Buffer.isBuffer(body)) {
                    // body is buffer
                    dest.write(body);
                    dest.end();
                } else {
                    // body is stream
                    body.pipe(dest);
                }
            }

            // expose Promise
            Body.Promise = global.Promise;

            /**
             * headers.js
             *
             * Headers class offers convenient helpers
             */

            const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
            const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

            function validateName(name) {
                name = `${name}`;
                if (invalidTokenRegex.test(name) || name === "") {
                    throw new TypeError(
                        `${name} is not a legal HTTP header name`
                    );
                }
            }

            function validateValue(value) {
                value = `${value}`;
                if (invalidHeaderCharRegex.test(value)) {
                    throw new TypeError(
                        `${value} is not a legal HTTP header value`
                    );
                }
            }

            /**
             * Find the key in the map object given a header name.
             *
             * Returns undefined if not found.
             *
             * @param   String  name  Header name
             * @return  String|Undefined
             */
            function find(map, name) {
                name = name.toLowerCase();
                for (const key in map) {
                    if (key.toLowerCase() === name) {
                        return key;
                    }
                }
                return undefined;
            }

            const MAP = Symbol("map");
            class Headers {
                /**
                 * Headers class
                 *
                 * @param   Object  headers  Response headers
                 * @return  Void
                 */
                constructor() {
                    let init =
                        arguments.length > 0 && arguments[0] !== undefined
                            ? arguments[0]
                            : undefined;

                    this[MAP] = Object.create(null);

                    if (init instanceof Headers) {
                        const rawHeaders = init.raw();
                        const headerNames = Object.keys(rawHeaders);

                        for (const headerName of headerNames) {
                            for (const value of rawHeaders[headerName]) {
                                this.append(headerName, value);
                            }
                        }

                        return;
                    }

                    // We don't worry about converting prop to ByteString here as append()
                    // will handle it.
                    if (init == null);
                    else if (typeof init === "object") {
                        const method = init[Symbol.iterator];
                        if (method != null) {
                            if (typeof method !== "function") {
                                throw new TypeError(
                                    "Header pairs must be iterable"
                                );
                            }

                            // sequence<sequence<ByteString>>
                            // Note: per spec we have to first exhaust the lists then process them
                            const pairs = [];
                            for (const pair of init) {
                                if (
                                    typeof pair !== "object" ||
                                    typeof pair[Symbol.iterator] !== "function"
                                ) {
                                    throw new TypeError(
                                        "Each header pair must be iterable"
                                    );
                                }
                                pairs.push(Array.from(pair));
                            }

                            for (const pair of pairs) {
                                if (pair.length !== 2) {
                                    throw new TypeError(
                                        "Each header pair must be a name/value tuple"
                                    );
                                }
                                this.append(pair[0], pair[1]);
                            }
                        } else {
                            // record<ByteString, ByteString>
                            for (const key of Object.keys(init)) {
                                const value = init[key];
                                this.append(key, value);
                            }
                        }
                    } else {
                        throw new TypeError(
                            "Provided initializer must be an object"
                        );
                    }
                }

                /**
                 * Return combined header value given name
                 *
                 * @param   String  name  Header name
                 * @return  Mixed
                 */
                get(name) {
                    name = `${name}`;
                    validateName(name);
                    const key = find(this[MAP], name);
                    if (key === undefined) {
                        return null;
                    }

                    return this[MAP][key].join(", ");
                }

                /**
                 * Iterate over all headers
                 *
                 * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
                 * @param   Boolean   thisArg   `this` context for callback function
                 * @return  Void
                 */
                forEach(callback) {
                    let thisArg =
                        arguments.length > 1 && arguments[1] !== undefined
                            ? arguments[1]
                            : undefined;

                    let pairs = getHeaders(this);
                    let i = 0;
                    while (i < pairs.length) {
                        var _pairs$i = pairs[i];
                        const name = _pairs$i[0],
                            value = _pairs$i[1];

                        callback.call(thisArg, value, name, this);
                        pairs = getHeaders(this);
                        i++;
                    }
                }

                /**
                 * Overwrite header values given name
                 *
                 * @param   String  name   Header name
                 * @param   String  value  Header value
                 * @return  Void
                 */
                set(name, value) {
                    name = `${name}`;
                    value = `${value}`;
                    validateName(name);
                    validateValue(value);
                    const key = find(this[MAP], name);
                    this[MAP][key !== undefined ? key : name] = [value];
                }

                /**
                 * Append a value onto existing header
                 *
                 * @param   String  name   Header name
                 * @param   String  value  Header value
                 * @return  Void
                 */
                append(name, value) {
                    name = `${name}`;
                    value = `${value}`;
                    validateName(name);
                    validateValue(value);
                    const key = find(this[MAP], name);
                    if (key !== undefined) {
                        this[MAP][key].push(value);
                    } else {
                        this[MAP][name] = [value];
                    }
                }

                /**
                 * Check for header name existence
                 *
                 * @param   String   name  Header name
                 * @return  Boolean
                 */
                has(name) {
                    name = `${name}`;
                    validateName(name);
                    return find(this[MAP], name) !== undefined;
                }

                /**
                 * Delete all header values given name
                 *
                 * @param   String  name  Header name
                 * @return  Void
                 */
                delete(name) {
                    name = `${name}`;
                    validateName(name);
                    const key = find(this[MAP], name);
                    if (key !== undefined) {
                        delete this[MAP][key];
                    }
                }

                /**
                 * Return raw headers (non-spec api)
                 *
                 * @return  Object
                 */
                raw() {
                    return this[MAP];
                }

                /**
                 * Get an iterator on keys.
                 *
                 * @return  Iterator
                 */
                keys() {
                    return createHeadersIterator(this, "key");
                }

                /**
                 * Get an iterator on values.
                 *
                 * @return  Iterator
                 */
                values() {
                    return createHeadersIterator(this, "value");
                }

                /**
                 * Get an iterator on entries.
                 *
                 * This is the default iterator of the Headers object.
                 *
                 * @return  Iterator
                 */
                [Symbol.iterator]() {
                    return createHeadersIterator(this, "key+value");
                }
            }
            Headers.prototype.entries = Headers.prototype[Symbol.iterator];

            Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
                value: "Headers",
                writable: false,
                enumerable: false,
                configurable: true,
            });

            Object.defineProperties(Headers.prototype, {
                get: { enumerable: true },
                forEach: { enumerable: true },
                set: { enumerable: true },
                append: { enumerable: true },
                has: { enumerable: true },
                delete: { enumerable: true },
                keys: { enumerable: true },
                values: { enumerable: true },
                entries: { enumerable: true },
            });

            function getHeaders(headers) {
                let kind =
                    arguments.length > 1 && arguments[1] !== undefined
                        ? arguments[1]
                        : "key+value";

                const keys = Object.keys(headers[MAP]).sort();
                return keys.map(
                    kind === "key"
                        ? function (k) {
                              return k.toLowerCase();
                          }
                        : kind === "value"
                        ? function (k) {
                              return headers[MAP][k].join(", ");
                          }
                        : function (k) {
                              return [
                                  k.toLowerCase(),
                                  headers[MAP][k].join(", "),
                              ];
                          }
                );
            }

            const INTERNAL = Symbol("internal");

            function createHeadersIterator(target, kind) {
                const iterator = Object.create(HeadersIteratorPrototype);
                iterator[INTERNAL] = {
                    target,
                    kind,
                    index: 0,
                };
                return iterator;
            }

            const HeadersIteratorPrototype = Object.setPrototypeOf(
                {
                    next() {
                        // istanbul ignore if
                        if (
                            !this ||
                            Object.getPrototypeOf(this) !==
                                HeadersIteratorPrototype
                        ) {
                            throw new TypeError(
                                "Value of `this` is not a HeadersIterator"
                            );
                        }

                        var _INTERNAL = this[INTERNAL];
                        const target = _INTERNAL.target,
                            kind = _INTERNAL.kind,
                            index = _INTERNAL.index;

                        const values = getHeaders(target, kind);
                        const len = values.length;
                        if (index >= len) {
                            return {
                                value: undefined,
                                done: true,
                            };
                        }

                        this[INTERNAL].index = index + 1;

                        return {
                            value: values[index],
                            done: false,
                        };
                    },
                },
                Object.getPrototypeOf(
                    Object.getPrototypeOf([][Symbol.iterator]())
                )
            );

            Object.defineProperty(
                HeadersIteratorPrototype,
                Symbol.toStringTag,
                {
                    value: "HeadersIterator",
                    writable: false,
                    enumerable: false,
                    configurable: true,
                }
            );

            /**
             * Export the Headers object in a form that Node.js can consume.
             *
             * @param   Headers  headers
             * @return  Object
             */
            function exportNodeCompatibleHeaders(headers) {
                const obj = Object.assign({ __proto__: null }, headers[MAP]);

                // http.request() only supports string as Host header. This hack makes
                // specifying custom Host header possible.
                const hostHeaderKey = find(headers[MAP], "Host");
                if (hostHeaderKey !== undefined) {
                    obj[hostHeaderKey] = obj[hostHeaderKey][0];
                }

                return obj;
            }

            /**
             * Create a Headers object from an object of headers, ignoring those that do
             * not conform to HTTP grammar productions.
             *
             * @param   Object  obj  Object of headers
             * @return  Headers
             */
            function createHeadersLenient(obj) {
                const headers = new Headers();
                for (const name of Object.keys(obj)) {
                    if (invalidTokenRegex.test(name)) {
                        continue;
                    }
                    if (Array.isArray(obj[name])) {
                        for (const val of obj[name]) {
                            if (invalidHeaderCharRegex.test(val)) {
                                continue;
                            }
                            if (headers[MAP][name] === undefined) {
                                headers[MAP][name] = [val];
                            } else {
                                headers[MAP][name].push(val);
                            }
                        }
                    } else if (!invalidHeaderCharRegex.test(obj[name])) {
                        headers[MAP][name] = [obj[name]];
                    }
                }
                return headers;
            }

            const INTERNALS$1 = Symbol("Response internals");

            // fix an issue where "STATUS_CODES" aren't a named export for node <10
            const STATUS_CODES = http.STATUS_CODES;

            /**
             * Response class
             *
             * @param   Stream  body  Readable stream
             * @param   Object  opts  Response options
             * @return  Void
             */
            class Response {
                constructor() {
                    let body =
                        arguments.length > 0 && arguments[0] !== undefined
                            ? arguments[0]
                            : null;
                    let opts =
                        arguments.length > 1 && arguments[1] !== undefined
                            ? arguments[1]
                            : {};

                    Body.call(this, body, opts);

                    const status = opts.status || 200;
                    const headers = new Headers(opts.headers);

                    if (body != null && !headers.has("Content-Type")) {
                        const contentType = extractContentType(body);
                        if (contentType) {
                            headers.append("Content-Type", contentType);
                        }
                    }

                    this[INTERNALS$1] = {
                        url: opts.url,
                        status,
                        statusText: opts.statusText || STATUS_CODES[status],
                        headers,
                        counter: opts.counter,
                    };
                }

                get url() {
                    return this[INTERNALS$1].url || "";
                }

                get status() {
                    return this[INTERNALS$1].status;
                }

                /**
                 * Convenience property representing if the request ended normally
                 */
                get ok() {
                    return (
                        this[INTERNALS$1].status >= 200 &&
                        this[INTERNALS$1].status < 300
                    );
                }

                get redirected() {
                    return this[INTERNALS$1].counter > 0;
                }

                get statusText() {
                    return this[INTERNALS$1].statusText;
                }

                get headers() {
                    return this[INTERNALS$1].headers;
                }

                /**
                 * Clone this response
                 *
                 * @return  Response
                 */
                clone() {
                    return new Response(clone(this), {
                        url: this.url,
                        status: this.status,
                        statusText: this.statusText,
                        headers: this.headers,
                        ok: this.ok,
                        redirected: this.redirected,
                    });
                }
            }

            Body.mixIn(Response.prototype);

            Object.defineProperties(Response.prototype, {
                url: { enumerable: true },
                status: { enumerable: true },
                ok: { enumerable: true },
                redirected: { enumerable: true },
                statusText: { enumerable: true },
                headers: { enumerable: true },
                clone: { enumerable: true },
            });

            Object.defineProperty(Response.prototype, Symbol.toStringTag, {
                value: "Response",
                writable: false,
                enumerable: false,
                configurable: true,
            });

            const INTERNALS$2 = Symbol("Request internals");

            // fix an issue where "format", "parse" aren't a named export for node <10
            const parse_url = Url.parse;
            const format_url = Url.format;

            const streamDestructionSupported =
                "destroy" in Stream.Readable.prototype;

            /**
             * Check if a value is an instance of Request.
             *
             * @param   Mixed   input
             * @return  Boolean
             */
            function isRequest(input) {
                return (
                    typeof input === "object" &&
                    typeof input[INTERNALS$2] === "object"
                );
            }

            function isAbortSignal(signal) {
                const proto =
                    signal &&
                    typeof signal === "object" &&
                    Object.getPrototypeOf(signal);
                return !!(proto && proto.constructor.name === "AbortSignal");
            }

            /**
             * Request class
             *
             * @param   Mixed   input  Url or Request instance
             * @param   Object  init   Custom options
             * @return  Void
             */
            class Request {
                constructor(input) {
                    let init =
                        arguments.length > 1 && arguments[1] !== undefined
                            ? arguments[1]
                            : {};

                    let parsedURL;

                    // normalize input
                    if (!isRequest(input)) {
                        if (input && input.href) {
                            // in order to support Node.js' Url objects; though WHATWG's URL objects
                            // will fall into this branch also (since their `toString()` will return
                            // `href` property anyway)
                            parsedURL = parse_url(input.href);
                        } else {
                            // coerce input to a string before attempting to parse
                            parsedURL = parse_url(`${input}`);
                        }
                        input = {};
                    } else {
                        parsedURL = parse_url(input.url);
                    }

                    let method = init.method || input.method || "GET";
                    method = method.toUpperCase();

                    if (
                        (init.body != null ||
                            (isRequest(input) && input.body !== null)) &&
                        (method === "GET" || method === "HEAD")
                    ) {
                        throw new TypeError(
                            "Request with GET/HEAD method cannot have body"
                        );
                    }

                    let inputBody =
                        init.body != null
                            ? init.body
                            : isRequest(input) && input.body !== null
                            ? clone(input)
                            : null;

                    Body.call(this, inputBody, {
                        timeout: init.timeout || input.timeout || 0,
                        size: init.size || input.size || 0,
                    });

                    const headers = new Headers(
                        init.headers || input.headers || {}
                    );

                    if (inputBody != null && !headers.has("Content-Type")) {
                        const contentType = extractContentType(inputBody);
                        if (contentType) {
                            headers.append("Content-Type", contentType);
                        }
                    }

                    let signal = isRequest(input) ? input.signal : null;
                    if ("signal" in init) signal = init.signal;

                    if (signal != null && !isAbortSignal(signal)) {
                        throw new TypeError(
                            "Expected signal to be an instanceof AbortSignal"
                        );
                    }

                    this[INTERNALS$2] = {
                        method,
                        redirect: init.redirect || input.redirect || "follow",
                        headers,
                        parsedURL,
                        signal,
                    };

                    // node-fetch-only options
                    this.follow =
                        init.follow !== undefined
                            ? init.follow
                            : input.follow !== undefined
                            ? input.follow
                            : 20;
                    this.compress =
                        init.compress !== undefined
                            ? init.compress
                            : input.compress !== undefined
                            ? input.compress
                            : true;
                    this.counter = init.counter || input.counter || 0;
                    this.agent = init.agent || input.agent;
                }

                get method() {
                    return this[INTERNALS$2].method;
                }

                get url() {
                    return format_url(this[INTERNALS$2].parsedURL);
                }

                get headers() {
                    return this[INTERNALS$2].headers;
                }

                get redirect() {
                    return this[INTERNALS$2].redirect;
                }

                get signal() {
                    return this[INTERNALS$2].signal;
                }

                /**
                 * Clone this request
                 *
                 * @return  Request
                 */
                clone() {
                    return new Request(this);
                }
            }

            Body.mixIn(Request.prototype);

            Object.defineProperty(Request.prototype, Symbol.toStringTag, {
                value: "Request",
                writable: false,
                enumerable: false,
                configurable: true,
            });

            Object.defineProperties(Request.prototype, {
                method: { enumerable: true },
                url: { enumerable: true },
                headers: { enumerable: true },
                redirect: { enumerable: true },
                clone: { enumerable: true },
                signal: { enumerable: true },
            });

            /**
             * Convert a Request to Node.js http request options.
             *
             * @param   Request  A Request instance
             * @return  Object   The options object to be passed to http.request
             */
            function getNodeRequestOptions(request) {
                const parsedURL = request[INTERNALS$2].parsedURL;
                const headers = new Headers(request[INTERNALS$2].headers);

                // fetch step 1.3
                if (!headers.has("Accept")) {
                    headers.set("Accept", "*/*");
                }

                // Basic fetch
                if (!parsedURL.protocol || !parsedURL.hostname) {
                    throw new TypeError("Only absolute URLs are supported");
                }

                if (!/^https?:$/.test(parsedURL.protocol)) {
                    throw new TypeError("Only HTTP(S) protocols are supported");
                }

                if (
                    request.signal &&
                    request.body instanceof Stream.Readable &&
                    !streamDestructionSupported
                ) {
                    throw new Error(
                        "Cancellation of streamed requests with AbortSignal is not supported in node < 8"
                    );
                }

                // HTTP-network-or-cache fetch steps 2.4-2.7
                let contentLengthValue = null;
                if (
                    request.body == null &&
                    /^(POST|PUT)$/i.test(request.method)
                ) {
                    contentLengthValue = "0";
                }
                if (request.body != null) {
                    const totalBytes = getTotalBytes(request);
                    if (typeof totalBytes === "number") {
                        contentLengthValue = String(totalBytes);
                    }
                }
                if (contentLengthValue) {
                    headers.set("Content-Length", contentLengthValue);
                }

                // HTTP-network-or-cache fetch step 2.11
                if (!headers.has("User-Agent")) {
                    headers.set(
                        "User-Agent",
                        "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)"
                    );
                }

                // HTTP-network-or-cache fetch step 2.15
                if (request.compress && !headers.has("Accept-Encoding")) {
                    headers.set("Accept-Encoding", "gzip,deflate");
                }

                let agent = request.agent;
                if (typeof agent === "function") {
                    agent = agent(parsedURL);
                }

                if (!headers.has("Connection") && !agent) {
                    headers.set("Connection", "close");
                }

                // HTTP-network fetch step 4.2
                // chunked encoding is handled by Node.js

                return Object.assign({}, parsedURL, {
                    method: request.method,
                    headers: exportNodeCompatibleHeaders(headers),
                    agent,
                });
            }

            /**
             * abort-error.js
             *
             * AbortError interface for cancelled requests
             */

            /**
             * Create AbortError instance
             *
             * @param   String      message      Error message for human
             * @return  AbortError
             */
            function AbortError(message) {
                Error.call(this, message);

                this.type = "aborted";
                this.message = message;

                // hide custom error implementation details from end-users
                Error.captureStackTrace(this, this.constructor);
            }

            AbortError.prototype = Object.create(Error.prototype);
            AbortError.prototype.constructor = AbortError;
            AbortError.prototype.name = "AbortError";

            // fix an issue where "PassThrough", "resolve" aren't a named export for node <10
            const PassThrough$1 = Stream.PassThrough;
            const resolve_url = Url.resolve;

            /**
             * Fetch function
             *
             * @param   Mixed    url   Absolute url or Request instance
             * @param   Object   opts  Fetch options
             * @return  Promise
             */
            function fetch(url, opts) {
                // allow custom promise
                if (!fetch.Promise) {
                    throw new Error(
                        "native promise missing, set fetch.Promise to your favorite alternative"
                    );
                }

                Body.Promise = fetch.Promise;

                // wrap http.request into fetch
                return new fetch.Promise(function (resolve, reject) {
                    // build request object
                    const request = new Request(url, opts);
                    const options = getNodeRequestOptions(request);

                    const send = (options.protocol === "https:" ? https : http)
                        .request;
                    const signal = request.signal;

                    let response = null;

                    const abort = function abort() {
                        let error = new AbortError(
                            "The user aborted a request."
                        );
                        reject(error);
                        if (
                            request.body &&
                            request.body instanceof Stream.Readable
                        ) {
                            request.body.destroy(error);
                        }
                        if (!response || !response.body) return;
                        response.body.emit("error", error);
                    };

                    if (signal && signal.aborted) {
                        abort();
                        return;
                    }

                    const abortAndFinalize = function abortAndFinalize() {
                        abort();
                        finalize();
                    };

                    // send request
                    const req = send(options);
                    let reqTimeout;

                    if (signal) {
                        signal.addEventListener("abort", abortAndFinalize);
                    }

                    function finalize() {
                        req.abort();
                        if (signal)
                            signal.removeEventListener(
                                "abort",
                                abortAndFinalize
                            );
                        clearTimeout(reqTimeout);
                    }

                    if (request.timeout) {
                        req.once("socket", function (socket) {
                            reqTimeout = setTimeout(function () {
                                reject(
                                    new FetchError(
                                        `network timeout at: ${request.url}`,
                                        "request-timeout"
                                    )
                                );
                                finalize();
                            }, request.timeout);
                        });
                    }

                    req.on("error", function (err) {
                        reject(
                            new FetchError(
                                `request to ${request.url} failed, reason: ${err.message}`,
                                "system",
                                err
                            )
                        );
                        finalize();
                    });

                    req.on("response", function (res) {
                        clearTimeout(reqTimeout);

                        const headers = createHeadersLenient(res.headers);

                        // HTTP fetch step 5
                        if (fetch.isRedirect(res.statusCode)) {
                            // HTTP fetch step 5.2
                            const location = headers.get("Location");

                            // HTTP fetch step 5.3
                            const locationURL =
                                location === null
                                    ? null
                                    : resolve_url(request.url, location);

                            // HTTP fetch step 5.5
                            switch (request.redirect) {
                                case "error":
                                    reject(
                                        new FetchError(
                                            `uri requested responds with a redirect, redirect mode is set to error: ${request.url}`,
                                            "no-redirect"
                                        )
                                    );
                                    finalize();
                                    return;
                                case "manual":
                                    // node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
                                    if (locationURL !== null) {
                                        // handle corrupted header
                                        try {
                                            headers.set(
                                                "Location",
                                                locationURL
                                            );
                                        } catch (err) {
                                            // istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
                                            reject(err);
                                        }
                                    }
                                    break;
                                case "follow":
                                    // HTTP-redirect fetch step 2
                                    if (locationURL === null) {
                                        break;
                                    }

                                    // HTTP-redirect fetch step 5
                                    if (request.counter >= request.follow) {
                                        reject(
                                            new FetchError(
                                                `maximum redirect reached at: ${request.url}`,
                                                "max-redirect"
                                            )
                                        );
                                        finalize();
                                        return;
                                    }

                                    // HTTP-redirect fetch step 6 (counter increment)
                                    // Create a new Request object.
                                    const requestOpts = {
                                        headers: new Headers(request.headers),
                                        follow: request.follow,
                                        counter: request.counter + 1,
                                        agent: request.agent,
                                        compress: request.compress,
                                        method: request.method,
                                        body: request.body,
                                        signal: request.signal,
                                        timeout: request.timeout,
                                        size: request.size,
                                    };

                                    // HTTP-redirect fetch step 9
                                    if (
                                        res.statusCode !== 303 &&
                                        request.body &&
                                        getTotalBytes(request) === null
                                    ) {
                                        reject(
                                            new FetchError(
                                                "Cannot follow redirect with body being a readable stream",
                                                "unsupported-redirect"
                                            )
                                        );
                                        finalize();
                                        return;
                                    }

                                    // HTTP-redirect fetch step 11
                                    if (
                                        res.statusCode === 303 ||
                                        ((res.statusCode === 301 ||
                                            res.statusCode === 302) &&
                                            request.method === "POST")
                                    ) {
                                        requestOpts.method = "GET";
                                        requestOpts.body = undefined;
                                        requestOpts.headers.delete(
                                            "content-length"
                                        );
                                    }

                                    // HTTP-redirect fetch step 15
                                    resolve(
                                        fetch(
                                            new Request(
                                                locationURL,
                                                requestOpts
                                            )
                                        )
                                    );
                                    finalize();
                                    return;
                            }
                        }

                        // prepare response
                        res.once("end", function () {
                            if (signal)
                                signal.removeEventListener(
                                    "abort",
                                    abortAndFinalize
                                );
                        });
                        let body = res.pipe(new PassThrough$1());

                        const response_options = {
                            url: request.url,
                            status: res.statusCode,
                            statusText: res.statusMessage,
                            headers: headers,
                            size: request.size,
                            timeout: request.timeout,
                            counter: request.counter,
                        };

                        // HTTP-network fetch step 12.1.1.3
                        const codings = headers.get("Content-Encoding");

                        // HTTP-network fetch step 12.1.1.4: handle content codings

                        // in following scenarios we ignore compression support
                        // 1. compression support is disabled
                        // 2. HEAD request
                        // 3. no Content-Encoding header
                        // 4. no content response (204)
                        // 5. content not modified response (304)
                        if (
                            !request.compress ||
                            request.method === "HEAD" ||
                            codings === null ||
                            res.statusCode === 204 ||
                            res.statusCode === 304
                        ) {
                            response = new Response(body, response_options);
                            resolve(response);
                            return;
                        }

                        // For Node v6+
                        // Be less strict when decoding compressed responses, since sometimes
                        // servers send slightly invalid responses that are still accepted
                        // by common browsers.
                        // Always using Z_SYNC_FLUSH is what cURL does.
                        const zlibOptions = {
                            flush: zlib.Z_SYNC_FLUSH,
                            finishFlush: zlib.Z_SYNC_FLUSH,
                        };

                        // for gzip
                        if (codings == "gzip" || codings == "x-gzip") {
                            body = body.pipe(zlib.createGunzip(zlibOptions));
                            response = new Response(body, response_options);
                            resolve(response);
                            return;
                        }

                        // for deflate
                        if (codings == "deflate" || codings == "x-deflate") {
                            // handle the infamous raw deflate response from old servers
                            // a hack for old IIS and Apache servers
                            const raw = res.pipe(new PassThrough$1());
                            raw.once("data", function (chunk) {
                                // see http://stackoverflow.com/questions/37519828
                                if ((chunk[0] & 0x0f) === 0x08) {
                                    body = body.pipe(zlib.createInflate());
                                } else {
                                    body = body.pipe(zlib.createInflateRaw());
                                }
                                response = new Response(body, response_options);
                                resolve(response);
                            });
                            return;
                        }

                        // for br
                        if (
                            codings == "br" &&
                            typeof zlib.createBrotliDecompress === "function"
                        ) {
                            body = body.pipe(zlib.createBrotliDecompress());
                            response = new Response(body, response_options);
                            resolve(response);
                            return;
                        }

                        // otherwise, use response as-is
                        response = new Response(body, response_options);
                        resolve(response);
                    });

                    writeToStream(req, request);
                });
            }
            /**
             * Redirect code matching
             *
             * @param   Number   code  Status code
             * @return  Boolean
             */
            fetch.isRedirect = function (code) {
                return (
                    code === 301 ||
                    code === 302 ||
                    code === 303 ||
                    code === 307 ||
                    code === 308
                );
            };

            // expose Promise
            fetch.Promise = global.Promise;

            module.exports = exports = fetch;
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.default = exports;
            exports.Headers = Headers;
            exports.Request = Request;
            exports.Response = Response;
            exports.FetchError = FetchError;

            /***/
        },

        /***/ 7678: /***/ (module, exports) => {
            "use strict";

            /// <reference lib="es2018"/>
            /// <reference lib="dom"/>
            /// <reference types="node"/>
            Object.defineProperty(exports, "__esModule", { value: true });
            const typedArrayTypeNames = [
                "Int8Array",
                "Uint8Array",
                "Uint8ClampedArray",
                "Int16Array",
                "Uint16Array",
                "Int32Array",
                "Uint32Array",
                "Float32Array",
                "Float64Array",
                "BigInt64Array",
                "BigUint64Array",
            ];
            function isTypedArrayName(name) {
                return typedArrayTypeNames.includes(name);
            }
            const objectTypeNames = [
                "Function",
                "Generator",
                "AsyncGenerator",
                "GeneratorFunction",
                "AsyncGeneratorFunction",
                "AsyncFunction",
                "Observable",
                "Array",
                "Buffer",
                "Object",
                "RegExp",
                "Date",
                "Error",
                "Map",
                "Set",
                "WeakMap",
                "WeakSet",
                "ArrayBuffer",
                "SharedArrayBuffer",
                "DataView",
                "Promise",
                "URL",
                "HTMLElement",
                ...typedArrayTypeNames,
            ];
            function isObjectTypeName(name) {
                return objectTypeNames.includes(name);
            }
            const primitiveTypeNames = [
                "null",
                "undefined",
                "string",
                "number",
                "bigint",
                "boolean",
                "symbol",
            ];
            function isPrimitiveTypeName(name) {
                return primitiveTypeNames.includes(name);
            }
            // eslint-disable-next-line @typescript-eslint/ban-types
            function isOfType(type) {
                return (value) => typeof value === type;
            }
            const { toString } = Object.prototype;
            const getObjectType = (value) => {
                const objectTypeName = toString.call(value).slice(8, -1);
                if (
                    /HTML\w+Element/.test(objectTypeName) &&
                    is.domElement(value)
                ) {
                    return "HTMLElement";
                }
                if (isObjectTypeName(objectTypeName)) {
                    return objectTypeName;
                }
                return undefined;
            };
            const isObjectOfType = (type) => (value) =>
                getObjectType(value) === type;
            function is(value) {
                if (value === null) {
                    return "null";
                }
                switch (typeof value) {
                    case "undefined":
                        return "undefined";
                    case "string":
                        return "string";
                    case "number":
                        return "number";
                    case "boolean":
                        return "boolean";
                    case "function":
                        return "Function";
                    case "bigint":
                        return "bigint";
                    case "symbol":
                        return "symbol";
                    default:
                }
                if (is.observable(value)) {
                    return "Observable";
                }
                if (is.array(value)) {
                    return "Array";
                }
                if (is.buffer(value)) {
                    return "Buffer";
                }
                const tagType = getObjectType(value);
                if (tagType) {
                    return tagType;
                }
                if (
                    value instanceof String ||
                    value instanceof Boolean ||
                    value instanceof Number
                ) {
                    throw new TypeError(
                        "Please don't use object wrappers for primitive types"
                    );
                }
                return "Object";
            }
            is.undefined = isOfType("undefined");
            is.string = isOfType("string");
            const isNumberType = isOfType("number");
            is.number = (value) => isNumberType(value) && !is.nan(value);
            is.bigint = isOfType("bigint");
            // eslint-disable-next-line @typescript-eslint/ban-types
            is.function_ = isOfType("function");
            is.null_ = (value) => value === null;
            is.class_ = (value) =>
                is.function_(value) && value.toString().startsWith("class ");
            is.boolean = (value) => value === true || value === false;
            is.symbol = isOfType("symbol");
            is.numericString = (value) =>
                is.string(value) &&
                !is.emptyStringOrWhitespace(value) &&
                !Number.isNaN(Number(value));
            is.array = (value, assertion) => {
                if (!Array.isArray(value)) {
                    return false;
                }
                if (!is.function_(assertion)) {
                    return true;
                }
                return value.every(assertion);
            };
            is.buffer = (value) => {
                var _a, _b, _c, _d;
                return (_d =
                    (_c =
                        (_b =
                            (_a = value) === null || _a === void 0
                                ? void 0
                                : _a.constructor) === null || _b === void 0
                            ? void 0
                            : _b.isBuffer) === null || _c === void 0
                        ? void 0
                        : _c.call(_b, value)) !== null && _d !== void 0
                    ? _d
                    : false;
            };
            is.nullOrUndefined = (value) =>
                is.null_(value) || is.undefined(value);
            is.object = (value) =>
                !is.null_(value) &&
                (typeof value === "object" || is.function_(value));
            is.iterable = (value) => {
                var _a;
                return is.function_(
                    (_a = value) === null || _a === void 0
                        ? void 0
                        : _a[Symbol.iterator]
                );
            };
            is.asyncIterable = (value) => {
                var _a;
                return is.function_(
                    (_a = value) === null || _a === void 0
                        ? void 0
                        : _a[Symbol.asyncIterator]
                );
            };
            is.generator = (value) =>
                is.iterable(value) &&
                is.function_(value.next) &&
                is.function_(value.throw);
            is.asyncGenerator = (value) =>
                is.asyncIterable(value) &&
                is.function_(value.next) &&
                is.function_(value.throw);
            is.nativePromise = (value) => isObjectOfType("Promise")(value);
            const hasPromiseAPI = (value) => {
                var _a, _b;
                return (
                    is.function_(
                        (_a = value) === null || _a === void 0
                            ? void 0
                            : _a.then
                    ) &&
                    is.function_(
                        (_b = value) === null || _b === void 0
                            ? void 0
                            : _b.catch
                    )
                );
            };
            is.promise = (value) =>
                is.nativePromise(value) || hasPromiseAPI(value);
            is.generatorFunction = isObjectOfType("GeneratorFunction");
            is.asyncGeneratorFunction = (value) =>
                getObjectType(value) === "AsyncGeneratorFunction";
            is.asyncFunction = (value) =>
                getObjectType(value) === "AsyncFunction";
            // eslint-disable-next-line no-prototype-builtins, @typescript-eslint/ban-types
            is.boundFunction = (value) =>
                is.function_(value) && !value.hasOwnProperty("prototype");
            is.regExp = isObjectOfType("RegExp");
            is.date = isObjectOfType("Date");
            is.error = isObjectOfType("Error");
            is.map = (value) => isObjectOfType("Map")(value);
            is.set = (value) => isObjectOfType("Set")(value);
            is.weakMap = (value) => isObjectOfType("WeakMap")(value);
            is.weakSet = (value) => isObjectOfType("WeakSet")(value);
            is.int8Array = isObjectOfType("Int8Array");
            is.uint8Array = isObjectOfType("Uint8Array");
            is.uint8ClampedArray = isObjectOfType("Uint8ClampedArray");
            is.int16Array = isObjectOfType("Int16Array");
            is.uint16Array = isObjectOfType("Uint16Array");
            is.int32Array = isObjectOfType("Int32Array");
            is.uint32Array = isObjectOfType("Uint32Array");
            is.float32Array = isObjectOfType("Float32Array");
            is.float64Array = isObjectOfType("Float64Array");
            is.bigInt64Array = isObjectOfType("BigInt64Array");
            is.bigUint64Array = isObjectOfType("BigUint64Array");
            is.arrayBuffer = isObjectOfType("ArrayBuffer");
            is.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer");
            is.dataView = isObjectOfType("DataView");
            is.directInstanceOf = (instance, class_) =>
                Object.getPrototypeOf(instance) === class_.prototype;
            is.urlInstance = (value) => isObjectOfType("URL")(value);
            is.urlString = (value) => {
                if (!is.string(value)) {
                    return false;
                }
                try {
                    new URL(value); // eslint-disable-line no-new
                    return true;
                } catch (_a) {
                    return false;
                }
            };
            // TODO: Use the `not` operator with a type guard here when it's available.
            // Example: `is.truthy = (value: unknown): value is (not false | not 0 | not '' | not undefined | not null) => Boolean(value);`
            is.truthy = (value) => Boolean(value);
            // Example: `is.falsy = (value: unknown): value is (not true | 0 | '' | undefined | null) => Boolean(value);`
            is.falsy = (value) => !value;
            is.nan = (value) => Number.isNaN(value);
            is.primitive = (value) =>
                is.null_(value) || isPrimitiveTypeName(typeof value);
            is.integer = (value) => Number.isInteger(value);
            is.safeInteger = (value) => Number.isSafeInteger(value);
            is.plainObject = (value) => {
                // From: https://github.com/sindresorhus/is-plain-obj/blob/main/index.js
                if (toString.call(value) !== "[object Object]") {
                    return false;
                }
                const prototype = Object.getPrototypeOf(value);
                return (
                    prototype === null ||
                    prototype === Object.getPrototypeOf({})
                );
            };
            is.typedArray = (value) => isTypedArrayName(getObjectType(value));
            const isValidLength = (value) =>
                is.safeInteger(value) && value >= 0;
            is.arrayLike = (value) =>
                !is.nullOrUndefined(value) &&
                !is.function_(value) &&
                isValidLength(value.length);
            is.inRange = (value, range) => {
                if (is.number(range)) {
                    return (
                        value >= Math.min(0, range) &&
                        value <= Math.max(range, 0)
                    );
                }
                if (is.array(range) && range.length === 2) {
                    return (
                        value >= Math.min(...range) &&
                        value <= Math.max(...range)
                    );
                }
                throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
            };
            const NODE_TYPE_ELEMENT = 1;
            const DOM_PROPERTIES_TO_CHECK = [
                "innerHTML",
                "ownerDocument",
                "style",
                "attributes",
                "nodeValue",
            ];
            is.domElement = (value) => {
                return (
                    is.object(value) &&
                    value.nodeType === NODE_TYPE_ELEMENT &&
                    is.string(value.nodeName) &&
                    !is.plainObject(value) &&
                    DOM_PROPERTIES_TO_CHECK.every(
                        (property) => property in value
                    )
                );
            };
            is.observable = (value) => {
                var _a, _b, _c, _d;
                if (!value) {
                    return false;
                }
                // eslint-disable-next-line no-use-extend-native/no-use-extend-native
                if (
                    value ===
                    ((_b = (_a = value)[Symbol.observable]) === null ||
                    _b === void 0
                        ? void 0
                        : _b.call(_a))
                ) {
                    return true;
                }
                if (
                    value ===
                    ((_d = (_c = value)["@@observable"]) === null ||
                    _d === void 0
                        ? void 0
                        : _d.call(_c))
                ) {
                    return true;
                }
                return false;
            };
            is.nodeStream = (value) =>
                is.object(value) &&
                is.function_(value.pipe) &&
                !is.observable(value);
            is.infinite = (value) => value === Infinity || value === -Infinity;
            const isAbsoluteMod2 = (remainder) => (value) =>
                is.integer(value) && Math.abs(value % 2) === remainder;
            is.evenInteger = isAbsoluteMod2(0);
            is.oddInteger = isAbsoluteMod2(1);
            is.emptyArray = (value) => is.array(value) && value.length === 0;
            is.nonEmptyArray = (value) => is.array(value) && value.length > 0;
            is.emptyString = (value) => is.string(value) && value.length === 0;
            // TODO: Use `not ''` when the `not` operator is available.
            is.nonEmptyString = (value) => is.string(value) && value.length > 0;
            const isWhiteSpaceString = (value) =>
                is.string(value) && !/\S/.test(value);
            is.emptyStringOrWhitespace = (value) =>
                is.emptyString(value) || isWhiteSpaceString(value);
            is.emptyObject = (value) =>
                is.object(value) &&
                !is.map(value) &&
                !is.set(value) &&
                Object.keys(value).length === 0;
            // TODO: Use `not` operator here to remove `Map` and `Set` from type guard:
            // - https://github.com/Microsoft/TypeScript/pull/29317
            is.nonEmptyObject = (value) =>
                is.object(value) &&
                !is.map(value) &&
                !is.set(value) &&
                Object.keys(value).length > 0;
            is.emptySet = (value) => is.set(value) && value.size === 0;
            is.nonEmptySet = (value) => is.set(value) && value.size > 0;
            is.emptyMap = (value) => is.map(value) && value.size === 0;
            is.nonEmptyMap = (value) => is.map(value) && value.size > 0;
            const predicateOnArray = (method, predicate, values) => {
                if (!is.function_(predicate)) {
                    throw new TypeError(
                        `Invalid predicate: ${JSON.stringify(predicate)}`
                    );
                }
                if (values.length === 0) {
                    throw new TypeError("Invalid number of values");
                }
                return method.call(values, predicate);
            };
            is.any = (predicate, ...values) => {
                const predicates = is.array(predicate)
                    ? predicate
                    : [predicate];
                return predicates.some((singlePredicate) =>
                    predicateOnArray(
                        Array.prototype.some,
                        singlePredicate,
                        values
                    )
                );
            };
            is.all = (predicate, ...values) =>
                predicateOnArray(Array.prototype.every, predicate, values);
            const assertType = (
                condition,
                description,
                value,
                options = {}
            ) => {
                if (!condition) {
                    const { multipleValues } = options;
                    const valuesMessage = multipleValues
                        ? `received values of types ${[
                              ...new Set(
                                  value.map(
                                      (singleValue) => `\`${is(singleValue)}\``
                                  )
                              ),
                          ].join(", ")}`
                        : `received value of type \`${is(value)}\``;
                    throw new TypeError(
                        `Expected value which is \`${description}\`, ${valuesMessage}.`
                    );
                }
            };
            exports.assert = {
                // Unknowns.
                undefined: (value) =>
                    assertType(is.undefined(value), "undefined", value),
                string: (value) =>
                    assertType(is.string(value), "string", value),
                number: (value) =>
                    assertType(is.number(value), "number", value),
                bigint: (value) =>
                    assertType(is.bigint(value), "bigint", value),
                // eslint-disable-next-line @typescript-eslint/ban-types
                function_: (value) =>
                    assertType(is.function_(value), "Function", value),
                null_: (value) => assertType(is.null_(value), "null", value),
                class_: (value) =>
                    assertType(is.class_(value), "Class" /* class_ */, value),
                boolean: (value) =>
                    assertType(is.boolean(value), "boolean", value),
                symbol: (value) =>
                    assertType(is.symbol(value), "symbol", value),
                numericString: (value) =>
                    assertType(
                        is.numericString(value),
                        "string with a number" /* numericString */,
                        value
                    ),
                array: (value, assertion) => {
                    const assert = assertType;
                    assert(is.array(value), "Array", value);
                    if (assertion) {
                        value.forEach(assertion);
                    }
                },
                buffer: (value) =>
                    assertType(is.buffer(value), "Buffer", value),
                nullOrUndefined: (value) =>
                    assertType(
                        is.nullOrUndefined(value),
                        "null or undefined" /* nullOrUndefined */,
                        value
                    ),
                object: (value) =>
                    assertType(is.object(value), "Object", value),
                iterable: (value) =>
                    assertType(
                        is.iterable(value),
                        "Iterable" /* iterable */,
                        value
                    ),
                asyncIterable: (value) =>
                    assertType(
                        is.asyncIterable(value),
                        "AsyncIterable" /* asyncIterable */,
                        value
                    ),
                generator: (value) =>
                    assertType(is.generator(value), "Generator", value),
                asyncGenerator: (value) =>
                    assertType(
                        is.asyncGenerator(value),
                        "AsyncGenerator",
                        value
                    ),
                nativePromise: (value) =>
                    assertType(
                        is.nativePromise(value),
                        "native Promise" /* nativePromise */,
                        value
                    ),
                promise: (value) =>
                    assertType(is.promise(value), "Promise", value),
                generatorFunction: (value) =>
                    assertType(
                        is.generatorFunction(value),
                        "GeneratorFunction",
                        value
                    ),
                asyncGeneratorFunction: (value) =>
                    assertType(
                        is.asyncGeneratorFunction(value),
                        "AsyncGeneratorFunction",
                        value
                    ),
                // eslint-disable-next-line @typescript-eslint/ban-types
                asyncFunction: (value) =>
                    assertType(is.asyncFunction(value), "AsyncFunction", value),
                // eslint-disable-next-line @typescript-eslint/ban-types
                boundFunction: (value) =>
                    assertType(is.boundFunction(value), "Function", value),
                regExp: (value) =>
                    assertType(is.regExp(value), "RegExp", value),
                date: (value) => assertType(is.date(value), "Date", value),
                error: (value) => assertType(is.error(value), "Error", value),
                map: (value) => assertType(is.map(value), "Map", value),
                set: (value) => assertType(is.set(value), "Set", value),
                weakMap: (value) =>
                    assertType(is.weakMap(value), "WeakMap", value),
                weakSet: (value) =>
                    assertType(is.weakSet(value), "WeakSet", value),
                int8Array: (value) =>
                    assertType(is.int8Array(value), "Int8Array", value),
                uint8Array: (value) =>
                    assertType(is.uint8Array(value), "Uint8Array", value),
                uint8ClampedArray: (value) =>
                    assertType(
                        is.uint8ClampedArray(value),
                        "Uint8ClampedArray",
                        value
                    ),
                int16Array: (value) =>
                    assertType(is.int16Array(value), "Int16Array", value),
                uint16Array: (value) =>
                    assertType(is.uint16Array(value), "Uint16Array", value),
                int32Array: (value) =>
                    assertType(is.int32Array(value), "Int32Array", value),
                uint32Array: (value) =>
                    assertType(is.uint32Array(value), "Uint32Array", value),
                float32Array: (value) =>
                    assertType(is.float32Array(value), "Float32Array", value),
                float64Array: (value) =>
                    assertType(is.float64Array(value), "Float64Array", value),
                bigInt64Array: (value) =>
                    assertType(is.bigInt64Array(value), "BigInt64Array", value),
                bigUint64Array: (value) =>
                    assertType(
                        is.bigUint64Array(value),
                        "BigUint64Array",
                        value
                    ),
                arrayBuffer: (value) =>
                    assertType(is.arrayBuffer(value), "ArrayBuffer", value),
                sharedArrayBuffer: (value) =>
                    assertType(
                        is.sharedArrayBuffer(value),
                        "SharedArrayBuffer",
                        value
                    ),
                dataView: (value) =>
                    assertType(is.dataView(value), "DataView", value),
                urlInstance: (value) =>
                    assertType(is.urlInstance(value), "URL", value),
                urlString: (value) =>
                    assertType(
                        is.urlString(value),
                        "string with a URL" /* urlString */,
                        value
                    ),
                truthy: (value) =>
                    assertType(is.truthy(value), "truthy" /* truthy */, value),
                falsy: (value) =>
                    assertType(is.falsy(value), "falsy" /* falsy */, value),
                nan: (value) =>
                    assertType(is.nan(value), "NaN" /* nan */, value),
                primitive: (value) =>
                    assertType(
                        is.primitive(value),
                        "primitive" /* primitive */,
                        value
                    ),
                integer: (value) =>
                    assertType(
                        is.integer(value),
                        "integer" /* integer */,
                        value
                    ),
                safeInteger: (value) =>
                    assertType(
                        is.safeInteger(value),
                        "integer" /* safeInteger */,
                        value
                    ),
                plainObject: (value) =>
                    assertType(
                        is.plainObject(value),
                        "plain object" /* plainObject */,
                        value
                    ),
                typedArray: (value) =>
                    assertType(
                        is.typedArray(value),
                        "TypedArray" /* typedArray */,
                        value
                    ),
                arrayLike: (value) =>
                    assertType(
                        is.arrayLike(value),
                        "array-like" /* arrayLike */,
                        value
                    ),
                domElement: (value) =>
                    assertType(
                        is.domElement(value),
                        "HTMLElement" /* domElement */,
                        value
                    ),
                observable: (value) =>
                    assertType(is.observable(value), "Observable", value),
                nodeStream: (value) =>
                    assertType(
                        is.nodeStream(value),
                        "Node.js Stream" /* nodeStream */,
                        value
                    ),
                infinite: (value) =>
                    assertType(
                        is.infinite(value),
                        "infinite number" /* infinite */,
                        value
                    ),
                emptyArray: (value) =>
                    assertType(
                        is.emptyArray(value),
                        "empty array" /* emptyArray */,
                        value
                    ),
                nonEmptyArray: (value) =>
                    assertType(
                        is.nonEmptyArray(value),
                        "non-empty array" /* nonEmptyArray */,
                        value
                    ),
                emptyString: (value) =>
                    assertType(
                        is.emptyString(value),
                        "empty string" /* emptyString */,
                        value
                    ),
                nonEmptyString: (value) =>
                    assertType(
                        is.nonEmptyString(value),
                        "non-empty string" /* nonEmptyString */,
                        value
                    ),
                emptyStringOrWhitespace: (value) =>
                    assertType(
                        is.emptyStringOrWhitespace(value),
                        "empty string or whitespace" /* emptyStringOrWhitespace */,
                        value
                    ),
                emptyObject: (value) =>
                    assertType(
                        is.emptyObject(value),
                        "empty object" /* emptyObject */,
                        value
                    ),
                nonEmptyObject: (value) =>
                    assertType(
                        is.nonEmptyObject(value),
                        "non-empty object" /* nonEmptyObject */,
                        value
                    ),
                emptySet: (value) =>
                    assertType(
                        is.emptySet(value),
                        "empty set" /* emptySet */,
                        value
                    ),
                nonEmptySet: (value) =>
                    assertType(
                        is.nonEmptySet(value),
                        "non-empty set" /* nonEmptySet */,
                        value
                    ),
                emptyMap: (value) =>
                    assertType(
                        is.emptyMap(value),
                        "empty map" /* emptyMap */,
                        value
                    ),
                nonEmptyMap: (value) =>
                    assertType(
                        is.nonEmptyMap(value),
                        "non-empty map" /* nonEmptyMap */,
                        value
                    ),
                // Numbers.
                evenInteger: (value) =>
                    assertType(
                        is.evenInteger(value),
                        "even integer" /* evenInteger */,
                        value
                    ),
                oddInteger: (value) =>
                    assertType(
                        is.oddInteger(value),
                        "odd integer" /* oddInteger */,
                        value
                    ),
                // Two arguments.
                directInstanceOf: (instance, class_) =>
                    assertType(
                        is.directInstanceOf(instance, class_),
                        "T" /* directInstanceOf */,
                        instance
                    ),
                inRange: (value, range) =>
                    assertType(
                        is.inRange(value, range),
                        "in range" /* inRange */,
                        value
                    ),
                // Variadic functions.
                any: (predicate, ...values) => {
                    return assertType(
                        is.any(predicate, ...values),
                        "predicate returns truthy for any value" /* any */,
                        values,
                        { multipleValues: true }
                    );
                },
                all: (predicate, ...values) =>
                    assertType(
                        is.all(predicate, ...values),
                        "predicate returns truthy for all values" /* all */,
                        values,
                        { multipleValues: true }
                    ),
            };
            // Some few keywords are reserved, but we'll populate them for Node.js users
            // See https://github.com/Microsoft/TypeScript/issues/2536
            Object.defineProperties(is, {
                class: {
                    value: is.class_,
                },
                function: {
                    value: is.function_,
                },
                null: {
                    value: is.null_,
                },
            });
            Object.defineProperties(exports.assert, {
                class: {
                    value: exports.assert.class_,
                },
                function: {
                    value: exports.assert.function_,
                },
                null: {
                    value: exports.assert.null_,
                },
            });
            exports.default = is;
            // For CommonJS default export support
            module.exports = is;
            module.exports.default = is;
            module.exports.assert = exports.assert;

            /***/
        },

        /***/ 8097: /***/ (module, exports, __nccwpck_require__) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            const defer_to_connect_1 = __nccwpck_require__(6214);
            const util_1 = __nccwpck_require__(1669);
            const nodejsMajorVersion = Number(
                process.versions.node.split(".")[0]
            );
            const timer = (request) => {
                if (request.timings) {
                    return request.timings;
                }
                const timings = {
                    start: Date.now(),
                    socket: undefined,
                    lookup: undefined,
                    connect: undefined,
                    secureConnect: undefined,
                    upload: undefined,
                    response: undefined,
                    end: undefined,
                    error: undefined,
                    abort: undefined,
                    phases: {
                        wait: undefined,
                        dns: undefined,
                        tcp: undefined,
                        tls: undefined,
                        request: undefined,
                        firstByte: undefined,
                        download: undefined,
                        total: undefined,
                    },
                };
                request.timings = timings;
                const handleError = (origin) => {
                    const emit = origin.emit.bind(origin);
                    origin.emit = (event, ...args) => {
                        // Catches the `error` event
                        if (event === "error") {
                            timings.error = Date.now();
                            timings.phases.total =
                                timings.error - timings.start;
                            origin.emit = emit;
                        }
                        // Saves the original behavior
                        return emit(event, ...args);
                    };
                };
                handleError(request);
                const onAbort = () => {
                    timings.abort = Date.now();
                    // Let the `end` response event be responsible for setting the total phase,
                    // unless the Node.js major version is >= 13.
                    if (!timings.response || nodejsMajorVersion >= 13) {
                        timings.phases.total = Date.now() - timings.start;
                    }
                };
                request.prependOnceListener("abort", onAbort);
                const onSocket = (socket) => {
                    timings.socket = Date.now();
                    timings.phases.wait = timings.socket - timings.start;
                    if (util_1.types.isProxy(socket)) {
                        return;
                    }
                    const lookupListener = () => {
                        timings.lookup = Date.now();
                        timings.phases.dns = timings.lookup - timings.socket;
                    };
                    socket.prependOnceListener("lookup", lookupListener);
                    defer_to_connect_1.default(socket, {
                        connect: () => {
                            timings.connect = Date.now();
                            if (timings.lookup === undefined) {
                                socket.removeListener("lookup", lookupListener);
                                timings.lookup = timings.connect;
                                timings.phases.dns =
                                    timings.lookup - timings.socket;
                            }
                            timings.phases.tcp =
                                timings.connect - timings.lookup;
                            // This callback is called before flushing any data,
                            // so we don't need to set `timings.phases.request` here.
                        },
                        secureConnect: () => {
                            timings.secureConnect = Date.now();
                            timings.phases.tls =
                                timings.secureConnect - timings.connect;
                        },
                    });
                };
                if (request.socket) {
                    onSocket(request.socket);
                } else {
                    request.prependOnceListener("socket", onSocket);
                }
                const onUpload = () => {
                    var _a;
                    timings.upload = Date.now();
                    timings.phases.request =
                        timings.upload -
                        ((_a = timings.secureConnect) !== null && _a !== void 0
                            ? _a
                            : timings.connect);
                };
                const writableFinished = () => {
                    if (typeof request.writableFinished === "boolean") {
                        return request.writableFinished;
                    }
                    // Node.js doesn't have `request.writableFinished` property
                    return (
                        request.finished &&
                        request.outputSize === 0 &&
                        (!request.socket || request.socket.writableLength === 0)
                    );
                };
                if (writableFinished()) {
                    onUpload();
                } else {
                    request.prependOnceListener("finish", onUpload);
                }
                request.prependOnceListener("response", (response) => {
                    timings.response = Date.now();
                    timings.phases.firstByte =
                        timings.response - timings.upload;
                    response.timings = timings;
                    handleError(response);
                    response.prependOnceListener("end", () => {
                        timings.end = Date.now();
                        timings.phases.download =
                            timings.end - timings.response;
                        timings.phases.total = timings.end - timings.start;
                    });
                    response.prependOnceListener("aborted", onAbort);
                });
                return timings;
            };
            exports.default = timer;
            // For CommonJS default export support
            module.exports = timer;
            module.exports.default = timer;

            /***/
        },

        /***/ 3682: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            var register = __nccwpck_require__(4670);
            var addHook = __nccwpck_require__(5549);
            var removeHook = __nccwpck_require__(6819);

            // bind with array of arguments: https://stackoverflow.com/a/21792913
            var bind = Function.bind;
            var bindable = bind.bind(bind);

            function bindApi(hook, state, name) {
                var removeHookRef = bindable(removeHook, null).apply(
                    null,
                    name ? [state, name] : [state]
                );
                hook.api = { remove: removeHookRef };
                hook.remove = removeHookRef;
                ["before", "error", "after", "wrap"].forEach(function (kind) {
                    var args = name ? [state, kind, name] : [state, kind];
                    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(
                        null,
                        args
                    );
                });
            }

            function HookSingular() {
                var singularHookName = "h";
                var singularHookState = {
                    registry: {},
                };
                var singularHook = register.bind(
                    null,
                    singularHookState,
                    singularHookName
                );
                bindApi(singularHook, singularHookState, singularHookName);
                return singularHook;
            }

            function HookCollection() {
                var state = {
                    registry: {},
                };

                var hook = register.bind(null, state);
                bindApi(hook, state);

                return hook;
            }

            var collectionHookDeprecationMessageDisplayed = false;
            function Hook() {
                if (!collectionHookDeprecationMessageDisplayed) {
                    console.warn(
                        '[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'
                    );
                    collectionHookDeprecationMessageDisplayed = true;
                }
                return HookCollection();
            }

            Hook.Singular = HookSingular.bind();
            Hook.Collection = HookCollection.bind();

            module.exports = Hook;
            // expose constructors as a named property for TypeScript
            module.exports.Hook = Hook;
            module.exports.Singular = Hook.Singular;
            module.exports.Collection = Hook.Collection;

            /***/
        },

        /***/ 5549: /***/ (module) => {
            module.exports = addHook;

            function addHook(state, kind, name, hook) {
                var orig = hook;
                if (!state.registry[name]) {
                    state.registry[name] = [];
                }

                if (kind === "before") {
                    hook = function (method, options) {
                        return Promise.resolve()
                            .then(orig.bind(null, options))
                            .then(method.bind(null, options));
                    };
                }

                if (kind === "after") {
                    hook = function (method, options) {
                        var result;
                        return Promise.resolve()
                            .then(method.bind(null, options))
                            .then(function (result_) {
                                result = result_;
                                return orig(result, options);
                            })
                            .then(function () {
                                return result;
                            });
                    };
                }

                if (kind === "error") {
                    hook = function (method, options) {
                        return Promise.resolve()
                            .then(method.bind(null, options))
                            .catch(function (error) {
                                return orig(error, options);
                            });
                    };
                }

                state.registry[name].push({
                    hook: hook,
                    orig: orig,
                });
            }

            /***/
        },

        /***/ 4670: /***/ (module) => {
            module.exports = register;

            function register(state, name, method, options) {
                if (typeof method !== "function") {
                    throw new Error(
                        "method for before hook must be a function"
                    );
                }

                if (!options) {
                    options = {};
                }

                if (Array.isArray(name)) {
                    return name.reverse().reduce(function (callback, name) {
                        return register.bind(
                            null,
                            state,
                            name,
                            callback,
                            options
                        );
                    }, method)();
                }

                return Promise.resolve().then(function () {
                    if (!state.registry[name]) {
                        return method(options);
                    }

                    return state.registry[name].reduce(function (
                        method,
                        registered
                    ) {
                        return registered.hook.bind(null, method, options);
                    },
                    method)();
                });
            }

            /***/
        },

        /***/ 6819: /***/ (module) => {
            module.exports = removeHook;

            function removeHook(state, name, method) {
                if (!state.registry[name]) {
                    return;
                }

                var index = state.registry[name]
                    .map(function (registered) {
                        return registered.orig;
                    })
                    .indexOf(method);

                if (index === -1) {
                    return;
                }

                state.registry[name].splice(index, 1);
            }

            /***/
        },

        /***/ 2286: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            "use strict";

            const {
                V4MAPPED,
                ADDRCONFIG,
                ALL,
                promises: { Resolver: AsyncResolver },
                lookup: dnsLookup,
            } = __nccwpck_require__(881);
            const { promisify } = __nccwpck_require__(1669);
            const os = __nccwpck_require__(2087);

            const kCacheableLookupCreateConnection = Symbol(
                "cacheableLookupCreateConnection"
            );
            const kCacheableLookupInstance = Symbol("cacheableLookupInstance");
            const kExpires = Symbol("expires");

            const supportsALL = typeof ALL === "number";

            const verifyAgent = (agent) => {
                if (!(agent && typeof agent.createConnection === "function")) {
                    throw new Error(
                        "Expected an Agent instance as the first argument"
                    );
                }
            };

            const map4to6 = (entries) => {
                for (const entry of entries) {
                    if (entry.family === 6) {
                        continue;
                    }

                    entry.address = `::ffff:${entry.address}`;
                    entry.family = 6;
                }
            };

            const getIfaceInfo = () => {
                let has4 = false;
                let has6 = false;

                for (const device of Object.values(os.networkInterfaces())) {
                    for (const iface of device) {
                        if (iface.internal) {
                            continue;
                        }

                        if (iface.family === "IPv6") {
                            has6 = true;
                        } else {
                            has4 = true;
                        }

                        if (has4 && has6) {
                            return { has4, has6 };
                        }
                    }
                }

                return { has4, has6 };
            };

            const isIterable = (map) => {
                return Symbol.iterator in map;
            };

            const ttl = { ttl: true };
            const all = { all: true };

            class CacheableLookup {
                constructor({
                    cache = new Map(),
                    maxTtl = Infinity,
                    fallbackDuration = 3600,
                    errorTtl = 0.15,
                    resolver = new AsyncResolver(),
                    lookup = dnsLookup,
                } = {}) {
                    this.maxTtl = maxTtl;
                    this.errorTtl = errorTtl;

                    this._cache = cache;
                    this._resolver = resolver;
                    this._dnsLookup = promisify(lookup);

                    if (this._resolver instanceof AsyncResolver) {
                        this._resolve4 = this._resolver.resolve4.bind(
                            this._resolver
                        );
                        this._resolve6 = this._resolver.resolve6.bind(
                            this._resolver
                        );
                    } else {
                        this._resolve4 = promisify(
                            this._resolver.resolve4.bind(this._resolver)
                        );
                        this._resolve6 = promisify(
                            this._resolver.resolve6.bind(this._resolver)
                        );
                    }

                    this._iface = getIfaceInfo();

                    this._pending = {};
                    this._nextRemovalTime = false;
                    this._hostnamesToFallback = new Set();

                    if (fallbackDuration < 1) {
                        this._fallback = false;
                    } else {
                        this._fallback = true;

                        const interval = setInterval(() => {
                            this._hostnamesToFallback.clear();
                        }, fallbackDuration * 1000);

                        /* istanbul ignore next: There is no `interval.unref()` when running inside an Electron renderer */
                        if (interval.unref) {
                            interval.unref();
                        }
                    }

                    this.lookup = this.lookup.bind(this);
                    this.lookupAsync = this.lookupAsync.bind(this);
                }

                set servers(servers) {
                    this.clear();

                    this._resolver.setServers(servers);
                }

                get servers() {
                    return this._resolver.getServers();
                }

                lookup(hostname, options, callback) {
                    if (typeof options === "function") {
                        callback = options;
                        options = {};
                    } else if (typeof options === "number") {
                        options = {
                            family: options,
                        };
                    }

                    if (!callback) {
                        throw new Error("Callback must be a function.");
                    }

                    // eslint-disable-next-line promise/prefer-await-to-then
                    this.lookupAsync(hostname, options).then((result) => {
                        if (options.all) {
                            callback(null, result);
                        } else {
                            callback(
                                null,
                                result.address,
                                result.family,
                                result.expires,
                                result.ttl
                            );
                        }
                    }, callback);
                }

                async lookupAsync(hostname, options = {}) {
                    if (typeof options === "number") {
                        options = {
                            family: options,
                        };
                    }

                    let cached = await this.query(hostname);

                    if (options.family === 6) {
                        const filtered = cached.filter(
                            (entry) => entry.family === 6
                        );

                        if (options.hints & V4MAPPED) {
                            if (
                                (supportsALL && options.hints & ALL) ||
                                filtered.length === 0
                            ) {
                                map4to6(cached);
                            } else {
                                cached = filtered;
                            }
                        } else {
                            cached = filtered;
                        }
                    } else if (options.family === 4) {
                        cached = cached.filter((entry) => entry.family === 4);
                    }

                    if (options.hints & ADDRCONFIG) {
                        const { _iface } = this;
                        cached = cached.filter((entry) =>
                            entry.family === 6 ? _iface.has6 : _iface.has4
                        );
                    }

                    if (cached.length === 0) {
                        const error = new Error(
                            `cacheableLookup ENOTFOUND ${hostname}`
                        );
                        error.code = "ENOTFOUND";
                        error.hostname = hostname;

                        throw error;
                    }

                    if (options.all) {
                        return cached;
                    }

                    return cached[0];
                }

                async query(hostname) {
                    let cached = await this._cache.get(hostname);

                    if (!cached) {
                        const pending = this._pending[hostname];

                        if (pending) {
                            cached = await pending;
                        } else {
                            const newPromise = this.queryAndCache(hostname);
                            this._pending[hostname] = newPromise;

                            try {
                                cached = await newPromise;
                            } finally {
                                delete this._pending[hostname];
                            }
                        }
                    }

                    cached = cached.map((entry) => {
                        return { ...entry };
                    });

                    return cached;
                }

                async _resolve(hostname) {
                    const wrap = async (promise) => {
                        try {
                            return await promise;
                        } catch (error) {
                            if (
                                error.code === "ENODATA" ||
                                error.code === "ENOTFOUND"
                            ) {
                                return [];
                            }

                            throw error;
                        }
                    };

                    // ANY is unsafe as it doesn't trigger new queries in the underlying server.
                    const [A, AAAA] = await Promise.all(
                        [
                            this._resolve4(hostname, ttl),
                            this._resolve6(hostname, ttl),
                        ].map((promise) => wrap(promise))
                    );

                    let aTtl = 0;
                    let aaaaTtl = 0;
                    let cacheTtl = 0;

                    const now = Date.now();

                    for (const entry of A) {
                        entry.family = 4;
                        entry.expires = now + entry.ttl * 1000;

                        aTtl = Math.max(aTtl, entry.ttl);
                    }

                    for (const entry of AAAA) {
                        entry.family = 6;
                        entry.expires = now + entry.ttl * 1000;

                        aaaaTtl = Math.max(aaaaTtl, entry.ttl);
                    }

                    if (A.length > 0) {
                        if (AAAA.length > 0) {
                            cacheTtl = Math.min(aTtl, aaaaTtl);
                        } else {
                            cacheTtl = aTtl;
                        }
                    } else {
                        cacheTtl = aaaaTtl;
                    }

                    return {
                        entries: [...A, ...AAAA],
                        cacheTtl,
                    };
                }

                async _lookup(hostname) {
                    try {
                        const entries = await this._dnsLookup(hostname, {
                            all: true,
                        });

                        return {
                            entries,
                            cacheTtl: 0,
                        };
                    } catch (_) {
                        return {
                            entries: [],
                            cacheTtl: 0,
                        };
                    }
                }

                async _set(hostname, data, cacheTtl) {
                    if (this.maxTtl > 0 && cacheTtl > 0) {
                        cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1000;
                        data[kExpires] = Date.now() + cacheTtl;

                        try {
                            await this._cache.set(hostname, data, cacheTtl);
                        } catch (error) {
                            this.lookupAsync = async () => {
                                const cacheError = new Error(
                                    "Cache Error. Please recreate the CacheableLookup instance."
                                );
                                cacheError.cause = error;

                                throw cacheError;
                            };
                        }

                        if (isIterable(this._cache)) {
                            this._tick(cacheTtl);
                        }
                    }
                }

                async queryAndCache(hostname) {
                    if (this._hostnamesToFallback.has(hostname)) {
                        return this._dnsLookup(hostname, all);
                    }

                    let query = await this._resolve(hostname);

                    if (query.entries.length === 0 && this._fallback) {
                        query = await this._lookup(hostname);

                        if (query.entries.length !== 0) {
                            // Use `dns.lookup(...)` for that particular hostname
                            this._hostnamesToFallback.add(hostname);
                        }
                    }

                    const cacheTtl =
                        query.entries.length === 0
                            ? this.errorTtl
                            : query.cacheTtl;
                    await this._set(hostname, query.entries, cacheTtl);

                    return query.entries;
                }

                _tick(ms) {
                    const nextRemovalTime = this._nextRemovalTime;

                    if (!nextRemovalTime || ms < nextRemovalTime) {
                        clearTimeout(this._removalTimeout);

                        this._nextRemovalTime = ms;

                        this._removalTimeout = setTimeout(() => {
                            this._nextRemovalTime = false;

                            let nextExpiry = Infinity;

                            const now = Date.now();

                            for (const [hostname, entries] of this._cache) {
                                const expires = entries[kExpires];

                                if (now >= expires) {
                                    this._cache.delete(hostname);
                                } else if (expires < nextExpiry) {
                                    nextExpiry = expires;
                                }
                            }

                            if (nextExpiry !== Infinity) {
                                this._tick(nextExpiry - now);
                            }
                        }, ms);

                        /* istanbul ignore next: There is no `timeout.unref()` when running inside an Electron renderer */
                        if (this._removalTimeout.unref) {
                            this._removalTimeout.unref();
                        }
                    }
                }

                install(agent) {
                    verifyAgent(agent);

                    if (kCacheableLookupCreateConnection in agent) {
                        throw new Error(
                            "CacheableLookup has been already installed"
                        );
                    }

                    agent[kCacheableLookupCreateConnection] =
                        agent.createConnection;
                    agent[kCacheableLookupInstance] = this;

                    agent.createConnection = (options, callback) => {
                        if (!("lookup" in options)) {
                            options.lookup = this.lookup;
                        }

                        return agent[kCacheableLookupCreateConnection](
                            options,
                            callback
                        );
                    };
                }

                uninstall(agent) {
                    verifyAgent(agent);

                    if (agent[kCacheableLookupCreateConnection]) {
                        if (agent[kCacheableLookupInstance] !== this) {
                            throw new Error(
                                "The agent is not owned by this CacheableLookup instance"
                            );
                        }

                        agent.createConnection =
                            agent[kCacheableLookupCreateConnection];

                        delete agent[kCacheableLookupCreateConnection];
                        delete agent[kCacheableLookupInstance];
                    }
                }

                updateInterfaceInfo() {
                    const { _iface } = this;

                    this._iface = getIfaceInfo();

                    if (
                        (_iface.has4 && !this._iface.has4) ||
                        (_iface.has6 && !this._iface.has6)
                    ) {
                        this._cache.clear();
                    }
                }

                clear(hostname) {
                    if (hostname) {
                        this._cache.delete(hostname);
                        return;
                    }

                    this._cache.clear();
                }
            }

            module.exports = CacheableLookup;
            module.exports.default = CacheableLookup;

            /***/
        },

        /***/ 8116: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            "use strict";

            const EventEmitter = __nccwpck_require__(8614);
            const urlLib = __nccwpck_require__(8835);
            const normalizeUrl = __nccwpck_require__(7952);
            const getStream = __nccwpck_require__(1766);
            const CachePolicy = __nccwpck_require__(1002);
            const Response = __nccwpck_require__(9004);
            const lowercaseKeys = __nccwpck_require__(9662);
            const cloneResponse = __nccwpck_require__(1312);
            const Keyv = __nccwpck_require__(1531);

            class CacheableRequest {
                constructor(request, cacheAdapter) {
                    if (typeof request !== "function") {
                        throw new TypeError(
                            "Parameter `request` must be a function"
                        );
                    }

                    this.cache = new Keyv({
                        uri: typeof cacheAdapter === "string" && cacheAdapter,
                        store: typeof cacheAdapter !== "string" && cacheAdapter,
                        namespace: "cacheable-request",
                    });

                    return this.createCacheableRequest(request);
                }

                createCacheableRequest(request) {
                    return (opts, cb) => {
                        let url;
                        if (typeof opts === "string") {
                            url = normalizeUrlObject(urlLib.parse(opts));
                            opts = {};
                        } else if (opts instanceof urlLib.URL) {
                            url = normalizeUrlObject(
                                urlLib.parse(opts.toString())
                            );
                            opts = {};
                        } else {
                            const [pathname, ...searchParts] = (
                                opts.path || ""
                            ).split("?");
                            const search =
                                searchParts.length > 0
                                    ? `?${searchParts.join("?")}`
                                    : "";
                            url = normalizeUrlObject({
                                ...opts,
                                pathname,
                                search,
                            });
                        }

                        opts = {
                            headers: {},
                            method: "GET",
                            cache: true,
                            strictTtl: false,
                            automaticFailover: false,
                            ...opts,
                            ...urlObjectToRequestOptions(url),
                        };
                        opts.headers = lowercaseKeys(opts.headers);

                        const ee = new EventEmitter();
                        const normalizedUrlString = normalizeUrl(
                            urlLib.format(url),
                            {
                                stripWWW: false,
                                removeTrailingSlash: false,
                                stripAuthentication: false,
                            }
                        );
                        const key = `${opts.method}:${normalizedUrlString}`;
                        let revalidate = false;
                        let madeRequest = false;

                        const makeRequest = (opts) => {
                            madeRequest = true;
                            let requestErrored = false;
                            let requestErrorCallback;

                            const requestErrorPromise = new Promise(
                                (resolve) => {
                                    requestErrorCallback = () => {
                                        if (!requestErrored) {
                                            requestErrored = true;
                                            resolve();
                                        }
                                    };
                                }
                            );

                            const handler = (response) => {
                                if (revalidate && !opts.forceRefresh) {
                                    response.status = response.statusCode;
                                    const revalidatedPolicy =
                                        CachePolicy.fromObject(
                                            revalidate.cachePolicy
                                        ).revalidatedPolicy(opts, response);
                                    if (!revalidatedPolicy.modified) {
                                        const headers =
                                            revalidatedPolicy.policy.responseHeaders();
                                        response = new Response(
                                            revalidate.statusCode,
                                            headers,
                                            revalidate.body,
                                            revalidate.url
                                        );
                                        response.cachePolicy =
                                            revalidatedPolicy.policy;
                                        response.fromCache = true;
                                    }
                                }

                                if (!response.fromCache) {
                                    response.cachePolicy = new CachePolicy(
                                        opts,
                                        response,
                                        opts
                                    );
                                    response.fromCache = false;
                                }

                                let clonedResponse;
                                if (
                                    opts.cache &&
                                    response.cachePolicy.storable()
                                ) {
                                    clonedResponse = cloneResponse(response);

                                    (async () => {
                                        try {
                                            const bodyPromise =
                                                getStream.buffer(response);

                                            await Promise.race([
                                                requestErrorPromise,
                                                new Promise((resolve) =>
                                                    response.once(
                                                        "end",
                                                        resolve
                                                    )
                                                ),
                                            ]);

                                            if (requestErrored) {
                                                return;
                                            }

                                            const body = await bodyPromise;

                                            const value = {
                                                cachePolicy:
                                                    response.cachePolicy.toObject(),
                                                url: response.url,
                                                statusCode: response.fromCache
                                                    ? revalidate.statusCode
                                                    : response.statusCode,
                                                body,
                                            };

                                            let ttl = opts.strictTtl
                                                ? response.cachePolicy.timeToLive()
                                                : undefined;
                                            if (opts.maxTtl) {
                                                ttl = ttl
                                                    ? Math.min(ttl, opts.maxTtl)
                                                    : opts.maxTtl;
                                            }

                                            await this.cache.set(
                                                key,
                                                value,
                                                ttl
                                            );
                                        } catch (error) {
                                            ee.emit(
                                                "error",
                                                new CacheableRequest.CacheError(
                                                    error
                                                )
                                            );
                                        }
                                    })();
                                } else if (opts.cache && revalidate) {
                                    (async () => {
                                        try {
                                            await this.cache.delete(key);
                                        } catch (error) {
                                            ee.emit(
                                                "error",
                                                new CacheableRequest.CacheError(
                                                    error
                                                )
                                            );
                                        }
                                    })();
                                }

                                ee.emit("response", clonedResponse || response);
                                if (typeof cb === "function") {
                                    cb(clonedResponse || response);
                                }
                            };

                            try {
                                const req = request(opts, handler);
                                req.once("error", requestErrorCallback);
                                req.once("abort", requestErrorCallback);
                                ee.emit("request", req);
                            } catch (error) {
                                ee.emit(
                                    "error",
                                    new CacheableRequest.RequestError(error)
                                );
                            }
                        };

                        (async () => {
                            const get = async (opts) => {
                                await Promise.resolve();

                                const cacheEntry = opts.cache
                                    ? await this.cache.get(key)
                                    : undefined;
                                if (typeof cacheEntry === "undefined") {
                                    return makeRequest(opts);
                                }

                                const policy = CachePolicy.fromObject(
                                    cacheEntry.cachePolicy
                                );
                                if (
                                    policy.satisfiesWithoutRevalidation(opts) &&
                                    !opts.forceRefresh
                                ) {
                                    const headers = policy.responseHeaders();
                                    const response = new Response(
                                        cacheEntry.statusCode,
                                        headers,
                                        cacheEntry.body,
                                        cacheEntry.url
                                    );
                                    response.cachePolicy = policy;
                                    response.fromCache = true;

                                    ee.emit("response", response);
                                    if (typeof cb === "function") {
                                        cb(response);
                                    }
                                } else {
                                    revalidate = cacheEntry;
                                    opts.headers =
                                        policy.revalidationHeaders(opts);
                                    makeRequest(opts);
                                }
                            };

                            const errorHandler = (error) =>
                                ee.emit(
                                    "error",
                                    new CacheableRequest.CacheError(error)
                                );
                            this.cache.once("error", errorHandler);
                            ee.on("response", () =>
                                this.cache.removeListener("error", errorHandler)
                            );

                            try {
                                await get(opts);
                            } catch (error) {
                                if (opts.automaticFailover && !madeRequest) {
                                    makeRequest(opts);
                                }

                                ee.emit(
                                    "error",
                                    new CacheableRequest.CacheError(error)
                                );
                            }
                        })();

                        return ee;
                    };
                }
            }

            function urlObjectToRequestOptions(url) {
                const options = { ...url };
                options.path = `${url.pathname || "/"}${url.search || ""}`;
                delete options.pathname;
                delete options.search;
                return options;
            }

            function normalizeUrlObject(url) {
                // If url was parsed by url.parse or new URL:
                // - hostname will be set
                // - host will be hostname[:port]
                // - port will be set if it was explicit in the parsed string
                // Otherwise, url was from request options:
                // - hostname or host may be set
                // - host shall not have port encoded
                return {
                    protocol: url.protocol,
                    auth: url.auth,
                    hostname: url.hostname || url.host || "localhost",
                    port: url.port,
                    pathname: url.pathname,
                    search: url.search,
                };
            }

            CacheableRequest.RequestError = class extends Error {
                constructor(error) {
                    super(error.message);
                    this.name = "RequestError";
                    Object.assign(this, error);
                }
            };

            CacheableRequest.CacheError = class extends Error {
                constructor(error) {
                    super(error.message);
                    this.name = "CacheError";
                    Object.assign(this, error);
                }
            };

            module.exports = CacheableRequest;

            /***/
        },

        /***/ 2725: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            const qs = __nccwpck_require__(1191);
            const crypto = __nccwpck_require__(6417);
            const fs = __nccwpck_require__(5747);
            const fetch = __nccwpck_require__(467);
            const packageJson = __nccwpck_require__(8600);
            const { stringify } = __nccwpck_require__(5816);

            /*
             * ChartJSImage URL builder
             * @typedef ChartJSImage
             */
            function ChartJSImage(
                { secret, protocol, host, port, timeout } = {},
                previous = {}
            ) {
                if (!(this instanceof ChartJSImage)) {
                    return new ChartJSImage(
                        { secret, protocol, host, port, timeout },
                        previous
                    );
                }
                this._protocol = protocol || "https";
                this._host = host || "image-charts.com";
                this._port = port || 443;
                this._pathname = "/chart.js/2.8.0";
                this._timeout = typeof timeout !== "undefined" ? timeout : 5000;
                this._query = {};
                this._secret = secret;
                Object.assign(this, previous);
            }

            ChartJSImage.prototype._clone = function (param, value) {
                return new this.constructor(
                    {},
                    {
                        ...this,
                        _query: {
                            ...this._query,
                            [param]: value,
                        },
                    }
                );
            };

            /**
             * Javascript/JSON definition of the chart. Use a Chart.js configuration object.
             * [Reference documentation]{@link }
             * @example
             * const chart = ChartJSImage().c("{type:'bar',data:{labels:['Q1','Q2','Q3','Q4'],datasets:[{label:'Users',data:[50,60,70,180]},{label:'Revenue',data:[100,200,300,400]}]}}");
             *
             * @param {string} value - Javascript/JSON definition of the chart. Use a Chart.js configuration object.
             * @return {ChartJSImage.constructor}
             */
            ChartJSImage.prototype.c = function (value) {
                return this._clone("c", stringify(value));
            };

            /**
             * Javascript/JSON definition of the chart. Use a Chart.js configuration object.
             * [Reference documentation]{@link }
             * @example
             * const chart = ChartJSImage().chart("{type:'bar',data:{labels:['Q1','Q2','Q3','Q4'],datasets:[{label:'Users',data:[50,60,70,180]},{label:'Revenue',data:[100,200,300,400]}]}}");
             *
             * @param {string} value - Javascript/JSON definition of the chart. Use a Chart.js configuration object.
             * @return {ChartJSImage.constructor}
             */
            ChartJSImage.prototype.chart = function (value) {
                return this._clone("chart", stringify(value));
            };

            /**
             * Width of the chart
             * [Reference documentation]{@link }
             * @example
             * const chart = ChartJSImage().width("400");
             * @default "500"
             * @param {integer} value - Width of the chart
             * @return {ChartJSImage.constructor}
             */
            ChartJSImage.prototype.width = function (value) {
                return this._clone("width", value);
            };

            /**
             * Height of the chart
             * [Reference documentation]{@link }
             * @example
             * const chart = ChartJSImage().height("300");
             * @default "300"
             * @param {integer} value - Height of the chart
             * @return {ChartJSImage.constructor}
             */
            ChartJSImage.prototype.height = function (value) {
                return this._clone("height", value);
            };

            /**
             * Background of the chart canvas. Accepts rgb (rgb(255,255,120)), colors (red), and url-encoded hex values (%23ff00ff). Abbreviated as &#34;bkg&#34;
             * [Reference documentation]{@link }
             * @example
             * const chart = ChartJSImage().backgroundColor("black");
             * const chart = ChartJSImage().backgroundColor("rgb(255,255,120)");
             * const chart = ChartJSImage().backgroundColor("%23ff00ff");
             *
             * @param {string} value - Background of the chart canvas. Accepts rgb (rgb(255,255,120)), colors (red), and url-encoded hex values (%23ff00ff). Abbreviated as &#34;bkg&#34;
             * @return {ChartJSImage.constructor}
             */
            ChartJSImage.prototype.backgroundColor = function (value) {
                return this._clone("backgroundColor", value);
            };

            /**
             * Background of the chart canvas. Accepts rgb (rgb(255,255,120)), colors (red), and url-encoded hex values (%23ff00ff). Abbreviated as &#34;bkg&#34;
             * [Reference documentation]{@link }
             * @example
             * const chart = ChartJSImage().bkg("black");
             * const chart = ChartJSImage().bkg("rgb(255,255,120)");
             * const chart = ChartJSImage().bkg("%23ff00ff");
             *
             * @param {string} value - Background of the chart canvas. Accepts rgb (rgb(255,255,120)), colors (red), and url-encoded hex values (%23ff00ff). Abbreviated as &#34;bkg&#34;
             * @return {ChartJSImage.constructor}
             */
            ChartJSImage.prototype.bkg = function (value) {
                return this._clone("bkg", value);
            };

            /**
             * Encoding of your &#34;chart&#34; parameter. Accepted values are url and base64.
             * [Reference documentation]{@link }
             * @example
             * const chart = ChartJSImage().encoding("url");
             * const chart = ChartJSImage().encoding("base64");
             * @default "url"
             * @param {string} value - Encoding of your &#34;chart&#34; parameter. Accepted values are url and base64.
             * @return {ChartJSImage.constructor}
             */
            ChartJSImage.prototype.encoding = function (value) {
                return this._clone("encoding", value);
            };

            /**
             * image-charts enterprise `account_id`
             * [Reference documentation]{@link https://documentation.image-charts.com/enterprise/}
             * @example
             * const chart = ChartJSImage().icac("accountId");
             *
             * @param {string} value - image-charts enterprise `account_id`
             * @return {ChartJSImage.constructor}
             */
            ChartJSImage.prototype.icac = function (value) {
                return this._clone("icac", value);
            };

            /**
             * HMAC-SHA256 signature required to activate paid features
             * [Reference documentation]{@link https://documentation.image-charts.com/enterprise/}
             * @example
             * const chart = ChartJSImage().ichm("0785cf22a0381c2e0239e27c126de4181f501d117c2c81745611e9db928b0376");
             *
             * @param {string} value - HMAC-SHA256 signature required to activate paid features
             * @return {ChartJSImage.constructor}
             */
            ChartJSImage.prototype.ichm = function (value) {
                return this._clone("ichm", value);
            };

            /**
             * Retina is a marketing term coined by Apple that refers to devices and monitors that have a resolution and pixel density so high — roughly 300 or more pixels per inch – that a person is unable to discern the individual pixels at a normal viewing distance.
             *           In order to generate beautiful charts for these Retina displays, Image-Charts supports a retina mode that can be activated through the icretina=1 parameter
             * [Reference documentation]{@link https://documentation.image-charts.com/reference/retina/}
             * @example
             * const chart = ChartJSImage().icretina("1");
             *
             * @param {string} value - retina mode
             * @return {ChartJSImage.constructor}
             */
            ChartJSImage.prototype.icretina = function (value) {
                return this._clone("icretina", value);
            };

            /**
             * Get the full ChartJSImage API url (signed and encoded if necessary)
             * @return {string} full generated url
             */
            ChartJSImage.prototype.toURL = function () {
                const url = new URL(`${this._protocol}://${this._host}`);

                /* istanbul ignore else */
                if (this._port) {
                    url.port = this._port;
                }

                url.pathname = this._pathname;

                const searchParams = new URLSearchParams(this._query);

                if (this._query.icac && this._secret && this._secret.length) {
                    searchParams.append(
                        "ichm",
                        crypto
                            .createHmac("sha256", this._secret)
                            .update(searchParams.toString())
                            .digest("hex")
                    );
                }

                url.search = searchParams.toString();

                return url.toString();
            };

            /**
             * Do a request to ChartJSImage API with current configuration and yield a promise of a NodeJS buffer
             * @return {Promise<Buffer>} binary image represented as a NodeJS Buffer wrapped inside a promise
             */
            ChartJSImage.prototype.toBuffer = function () {
                const _options = {
                    timeout: this._timeout,
                    headers: {
                        "User-Agent":
                            `javascript-chart.js-image/${packageJson.version}` +
                            (this._query.icac
                                ? " " + `(${this._query.icac})`
                                : ""),
                    },
                };
                return fetch(this.toURL(), _options).then((res) => {
                    return res.buffer().then((buff) => {
                        if (res.status >= 200 && res.status < 300) {
                            buff._response = res;
                            buff._request = _options;
                            return buff;
                        }

                        const validation_message = res.headers.get(
                            "x-ic-error-validation"
                        );
                        const validation_code =
                            res.headers.get("x-ic-error-code");
                        let message = validation_message
                            ? JSON.parse(validation_message)
                                  .map((x) => x.message)
                                  .join("\n")
                                  .trim()
                            : "";
                        /* istanbul ignore next */
                        message =
                            message.length > 0 || !validation_code
                                ? message
                                : validation_code;
                        /* istanbul ignore next */
                        message = message.length > 0 ? message : res.statusText;
                        const err = new Error(message);
                        /* istanbul ignore next */
                        err.code = validation_code || res.statusText;
                        err.statusCode = res.statusCode;
                        err._response = res;
                        err._request = _options;
                        return Promise.reject(err);
                    });
                });
            };

            /**
             * Do a request to ChartJSImage API with current configuration and writes the content inside a file
             * @return {Promise}
             */
            ChartJSImage.prototype.toFile = function (file) {
                return this.toBuffer().then(
                    (buffer) =>
                        new Promise((resolve, reject) =>
                            fs.writeFile(file, buffer, (err) =>
                                err ? reject(err) : resolve()
                            )
                        )
                );
            };

            /**
             * Do a request to ChartJSImageAPI with current configuration and yield a promise of a base64 encoded data URI
             * @return {Promise<String>} base64 data URI wrapped inside a promise
             */
            ChartJSImage.prototype.toDataURI = function () {
                const encoding = "base64";
                const mimetype = this._query.chan ? "image/gif" : "image/png";
                return this.toBuffer().then(
                    (buffer) =>
                        `data:${mimetype};${encoding},${buffer.toString(
                            encoding
                        )}`
                );
            };

            module.exports = ChartJSImage;

            /***/
        },

        /***/ 1312: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            "use strict";

            const PassThrough = __nccwpck_require__(2413).PassThrough;
            const mimicResponse = __nccwpck_require__(2610);

            const cloneResponse = (response) => {
                if (!(response && response.pipe)) {
                    throw new TypeError(
                        "Parameter `response` must be a response stream."
                    );
                }

                const clone = new PassThrough();
                mimicResponse(response, clone);

                return response.pipe(clone);
            };

            module.exports = cloneResponse;

            /***/
        },

        /***/ 2391: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            "use strict";

            const { Transform, PassThrough } = __nccwpck_require__(2413);
            const zlib = __nccwpck_require__(8761);
            const mimicResponse = __nccwpck_require__(3877);

            module.exports = (response) => {
                const contentEncoding = (
                    response.headers["content-encoding"] || ""
                ).toLowerCase();

                if (!["gzip", "deflate", "br"].includes(contentEncoding)) {
                    return response;
                }

                // TODO: Remove this when targeting Node.js 12.
                const isBrotli = contentEncoding === "br";
                if (
                    isBrotli &&
                    typeof zlib.createBrotliDecompress !== "function"
                ) {
                    response.destroy(
                        new Error("Brotli is not supported on Node.js < 12")
                    );
                    return response;
                }

                let isEmpty = true;

                const checker = new Transform({
                    transform(data, _encoding, callback) {
                        isEmpty = false;

                        callback(null, data);
                    },

                    flush(callback) {
                        callback();
                    },
                });

                const finalStream = new PassThrough({
                    autoDestroy: false,
                    destroy(error, callback) {
                        response.destroy();

                        callback(error);
                    },
                });

                const decompressStream = isBrotli
                    ? zlib.createBrotliDecompress()
                    : zlib.createUnzip();

                decompressStream.once("error", (error) => {
                    if (isEmpty && !response.readable) {
                        finalStream.end();
                        return;
                    }

                    finalStream.destroy(error);
                });

                mimicResponse(response, finalStream);
                response.pipe(checker).pipe(decompressStream).pipe(finalStream);

                return finalStream;
            };

            /***/
        },

        /***/ 3877: /***/ (module) => {
            "use strict";

            // We define these manually to ensure they're always copied
            // even if they would move up the prototype chain
            // https://nodejs.org/api/http.html#http_class_http_incomingmessage
            const knownProperties = [
                "aborted",
                "complete",
                "headers",
                "httpVersion",
                "httpVersionMinor",
                "httpVersionMajor",
                "method",
                "rawHeaders",
                "rawTrailers",
                "setTimeout",
                "socket",
                "statusCode",
                "statusMessage",
                "trailers",
                "url",
            ];

            module.exports = (fromStream, toStream) => {
                if (toStream._readableState.autoDestroy) {
                    throw new Error(
                        "The second stream must have the `autoDestroy` option set to `false`"
                    );
                }

                const fromProperties = new Set(
                    Object.keys(fromStream).concat(knownProperties)
                );

                const properties = {};

                for (const property of fromProperties) {
                    // Don't overwrite existing properties.
                    if (property in toStream) {
                        continue;
                    }

                    properties[property] = {
                        get() {
                            const value = fromStream[property];
                            const isFunction = typeof value === "function";

                            return isFunction ? value.bind(fromStream) : value;
                        },
                        set(value) {
                            fromStream[property] = value;
                        },
                        enumerable: true,
                        configurable: false,
                    };
                }

                Object.defineProperties(toStream, properties);

                fromStream.once("aborted", () => {
                    toStream.destroy();

                    toStream.emit("aborted");
                });

                fromStream.once("close", () => {
                    if (fromStream.complete) {
                        if (toStream.readable) {
                            toStream.once("end", () => {
                                toStream.emit("close");
                            });
                        } else {
                            toStream.emit("close");
                        }
                    } else {
                        toStream.emit("close");
                    }
                });

                return toStream;
            };

            /***/
        },

        /***/ 6214: /***/ (module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            function isTLSSocket(socket) {
                return socket.encrypted;
            }
            const deferToConnect = (socket, fn) => {
                let listeners;
                if (typeof fn === "function") {
                    const connect = fn;
                    listeners = { connect };
                } else {
                    listeners = fn;
                }
                const hasConnectListener =
                    typeof listeners.connect === "function";
                const hasSecureConnectListener =
                    typeof listeners.secureConnect === "function";
                const hasCloseListener = typeof listeners.close === "function";
                const onConnect = () => {
                    if (hasConnectListener) {
                        listeners.connect();
                    }
                    if (isTLSSocket(socket) && hasSecureConnectListener) {
                        if (socket.authorized) {
                            listeners.secureConnect();
                        } else if (!socket.authorizationError) {
                            socket.once(
                                "secureConnect",
                                listeners.secureConnect
                            );
                        }
                    }
                    if (hasCloseListener) {
                        socket.once("close", listeners.close);
                    }
                };
                if (socket.writable && !socket.connecting) {
                    onConnect();
                } else if (socket.connecting) {
                    socket.once("connect", onConnect);
                } else if (socket.destroyed && hasCloseListener) {
                    listeners.close(socket._hadError);
                }
            };
            exports.default = deferToConnect;
            // For CommonJS default export support
            module.exports = deferToConnect;
            module.exports.default = deferToConnect;

            /***/
        },

        /***/ 8932: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });

            class Deprecation extends Error {
                constructor(message) {
                    super(message); // Maintains proper stack trace (only available on V8)

                    /* istanbul ignore next */

                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(this, this.constructor);
                    }

                    this.name = "Deprecation";
                }
            }

            exports.Deprecation = Deprecation;

            /***/
        },

        /***/ 2437: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            /* @flow */
            /*::

type DotenvParseOptions = {
  debug?: boolean
}

// keys and values from src
type DotenvParseOutput = { [string]: string }

type DotenvConfigOptions = {
  path?: string, // path to .env file
  encoding?: string, // encoding of .env file
  debug?: string // turn on logging for debugging purposes
}

type DotenvConfigOutput = {
  parsed?: DotenvParseOutput,
  error?: Error
}

*/

            const fs = __nccwpck_require__(5747);
            const path = __nccwpck_require__(5622);
            const os = __nccwpck_require__(2087);

            function log(message /*: string */) {
                console.log(`[dotenv][DEBUG] ${message}`);
            }

            const NEWLINE = "\n";
            const RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
            const RE_NEWLINES = /\\n/g;
            const NEWLINES_MATCH = /\r\n|\n|\r/;

            // Parses src into an Object
            function parse(
                src /*: string | Buffer */,
                options /*: ?DotenvParseOptions */
            ) /*: DotenvParseOutput */ {
                const debug = Boolean(options && options.debug);
                const obj = {};

                // convert Buffers before splitting into lines and processing
                src.toString()
                    .split(NEWLINES_MATCH)
                    .forEach(function (line, idx) {
                        // matching "KEY' and 'VAL' in 'KEY=VAL'
                        const keyValueArr = line.match(RE_INI_KEY_VAL);
                        // matched?
                        if (keyValueArr != null) {
                            const key = keyValueArr[1];
                            // default undefined or missing values to empty string
                            let val = keyValueArr[2] || "";
                            const end = val.length - 1;
                            const isDoubleQuoted =
                                val[0] === '"' && val[end] === '"';
                            const isSingleQuoted =
                                val[0] === "'" && val[end] === "'";

                            // if single or double quoted, remove quotes
                            if (isSingleQuoted || isDoubleQuoted) {
                                val = val.substring(1, end);

                                // if double quoted, expand newlines
                                if (isDoubleQuoted) {
                                    val = val.replace(RE_NEWLINES, NEWLINE);
                                }
                            } else {
                                // remove surrounding whitespace
                                val = val.trim();
                            }

                            obj[key] = val;
                        } else if (debug) {
                            log(
                                `did not match key and value when parsing line ${
                                    idx + 1
                                }: ${line}`
                            );
                        }
                    });

                return obj;
            }

            function resolveHome(envPath) {
                return envPath[0] === "~"
                    ? path.join(os.homedir(), envPath.slice(1))
                    : envPath;
            }

            // Populates process.env from .env file
            function config(
                options /*: ?DotenvConfigOptions */
            ) /*: DotenvConfigOutput */ {
                let dotenvPath = path.resolve(process.cwd(), ".env");
                let encoding /*: string */ = "utf8";
                let debug = false;

                if (options) {
                    if (options.path != null) {
                        dotenvPath = resolveHome(options.path);
                    }
                    if (options.encoding != null) {
                        encoding = options.encoding;
                    }
                    if (options.debug != null) {
                        debug = true;
                    }
                }

                try {
                    // specifying an encoding returns a string instead of a buffer
                    const parsed = parse(
                        fs.readFileSync(dotenvPath, { encoding }),
                        { debug }
                    );

                    Object.keys(parsed).forEach(function (key) {
                        if (
                            !Object.prototype.hasOwnProperty.call(
                                process.env,
                                key
                            )
                        ) {
                            process.env[key] = parsed[key];
                        } else if (debug) {
                            log(
                                `"${key}" is already defined in \`process.env\` and will not be overwritten`
                            );
                        }
                    });

                    return { parsed };
                } catch (e) {
                    return { error: e };
                }
            }

            module.exports.config = config;
            module.exports.parse = parse;

            /***/
        },

        /***/ 1205: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            var once = __nccwpck_require__(1223);

            var noop = function () {};

            var isRequest = function (stream) {
                return stream.setHeader && typeof stream.abort === "function";
            };

            var isChildProcess = function (stream) {
                return (
                    stream.stdio &&
                    Array.isArray(stream.stdio) &&
                    stream.stdio.length === 3
                );
            };

            var eos = function (stream, opts, callback) {
                if (typeof opts === "function") return eos(stream, null, opts);
                if (!opts) opts = {};

                callback = once(callback || noop);

                var ws = stream._writableState;
                var rs = stream._readableState;
                var readable =
                    opts.readable ||
                    (opts.readable !== false && stream.readable);
                var writable =
                    opts.writable ||
                    (opts.writable !== false && stream.writable);
                var cancelled = false;

                var onlegacyfinish = function () {
                    if (!stream.writable) onfinish();
                };

                var onfinish = function () {
                    writable = false;
                    if (!readable) callback.call(stream);
                };

                var onend = function () {
                    readable = false;
                    if (!writable) callback.call(stream);
                };

                var onexit = function (exitCode) {
                    callback.call(
                        stream,
                        exitCode
                            ? new Error("exited with error code: " + exitCode)
                            : null
                    );
                };

                var onerror = function (err) {
                    callback.call(stream, err);
                };

                var onclose = function () {
                    process.nextTick(onclosenexttick);
                };

                var onclosenexttick = function () {
                    if (cancelled) return;
                    if (readable && !(rs && rs.ended && !rs.destroyed))
                        return callback.call(
                            stream,
                            new Error("premature close")
                        );
                    if (writable && !(ws && ws.ended && !ws.destroyed))
                        return callback.call(
                            stream,
                            new Error("premature close")
                        );
                };

                var onrequest = function () {
                    stream.req.on("finish", onfinish);
                };

                if (isRequest(stream)) {
                    stream.on("complete", onfinish);
                    stream.on("abort", onclose);
                    if (stream.req) onrequest();
                    else stream.on("request", onrequest);
                } else if (writable && !ws) {
                    // legacy streams
                    stream.on("end", onlegacyfinish);
                    stream.on("close", onlegacyfinish);
                }

                if (isChildProcess(stream)) stream.on("exit", onexit);

                stream.on("end", onend);
                stream.on("finish", onfinish);
                if (opts.error !== false) stream.on("error", onerror);
                stream.on("close", onclose);

                return function () {
                    cancelled = true;
                    stream.removeListener("complete", onfinish);
                    stream.removeListener("abort", onclose);
                    stream.removeListener("request", onrequest);
                    if (stream.req)
                        stream.req.removeListener("finish", onfinish);
                    stream.removeListener("end", onlegacyfinish);
                    stream.removeListener("close", onlegacyfinish);
                    stream.removeListener("finish", onfinish);
                    stream.removeListener("exit", onexit);
                    stream.removeListener("end", onend);
                    stream.removeListener("error", onerror);
                    stream.removeListener("close", onclose);
                };
            };

            module.exports = eos;

            /***/
        },

        /***/ 1585: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            "use strict";

            const { PassThrough: PassThroughStream } =
                __nccwpck_require__(2413);

            module.exports = (options) => {
                options = { ...options };

                const { array } = options;
                let { encoding } = options;
                const isBuffer = encoding === "buffer";
                let objectMode = false;

                if (array) {
                    objectMode = !(encoding || isBuffer);
                } else {
                    encoding = encoding || "utf8";
                }

                if (isBuffer) {
                    encoding = null;
                }

                const stream = new PassThroughStream({ objectMode });

                if (encoding) {
                    stream.setEncoding(encoding);
                }

                let length = 0;
                const chunks = [];

                stream.on("data", (chunk) => {
                    chunks.push(chunk);

                    if (objectMode) {
                        length = chunks.length;
                    } else {
                        length += chunk.length;
                    }
                });

                stream.getBufferedValue = () => {
                    if (array) {
                        return chunks;
                    }

                    return isBuffer
                        ? Buffer.concat(chunks, length)
                        : chunks.join("");
                };

                stream.getBufferedLength = () => length;

                return stream;
            };

            /***/
        },

        /***/ 1766: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            "use strict";

            const { constants: BufferConstants } = __nccwpck_require__(4293);
            const pump = __nccwpck_require__(8341);
            const bufferStream = __nccwpck_require__(1585);

            class MaxBufferError extends Error {
                constructor() {
                    super("maxBuffer exceeded");
                    this.name = "MaxBufferError";
                }
            }

            async function getStream(inputStream, options) {
                if (!inputStream) {
                    return Promise.reject(new Error("Expected a stream"));
                }

                options = {
                    maxBuffer: Infinity,
                    ...options,
                };

                const { maxBuffer } = options;

                let stream;
                await new Promise((resolve, reject) => {
                    const rejectPromise = (error) => {
                        // Don't retrieve an oversized buffer.
                        if (
                            error &&
                            stream.getBufferedLength() <=
                                BufferConstants.MAX_LENGTH
                        ) {
                            error.bufferedData = stream.getBufferedValue();
                        }

                        reject(error);
                    };

                    stream = pump(
                        inputStream,
                        bufferStream(options),
                        (error) => {
                            if (error) {
                                rejectPromise(error);
                                return;
                            }

                            resolve();
                        }
                    );

                    stream.on("data", () => {
                        if (stream.getBufferedLength() > maxBuffer) {
                            rejectPromise(new MaxBufferError());
                        }
                    });
                });

                return stream.getBufferedValue();
            }

            module.exports = getStream;
            // TODO: Remove this for the next major release
            module.exports.default = getStream;
            module.exports.buffer = (stream, options) =>
                getStream(stream, { ...options, encoding: "buffer" });
            module.exports.array = (stream, options) =>
                getStream(stream, { ...options, array: true });
            module.exports.MaxBufferError = MaxBufferError;

            /***/
        },

        /***/ 6457: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            const types_1 = __nccwpck_require__(4597);
            function createRejection(error, ...beforeErrorGroups) {
                const promise = (async () => {
                    if (error instanceof types_1.RequestError) {
                        try {
                            for (const hooks of beforeErrorGroups) {
                                if (hooks) {
                                    for (const hook of hooks) {
                                        // eslint-disable-next-line no-await-in-loop
                                        error = await hook(error);
                                    }
                                }
                            }
                        } catch (error_) {
                            error = error_;
                        }
                    }
                    throw error;
                })();
                const returnPromise = () => promise;
                promise.json = returnPromise;
                promise.text = returnPromise;
                promise.buffer = returnPromise;
                promise.on = returnPromise;
                return promise;
            }
            exports.default = createRejection;

            /***/
        },

        /***/ 6056: /***/ function (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) {
            "use strict";

            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          Object.defineProperty(o, k2, {
                              enumerable: true,
                              get: function () {
                                  return m[k];
                              },
                          });
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __exportStar =
                (this && this.__exportStar) ||
                function (m, exports) {
                    for (var p in m)
                        if (
                            p !== "default" &&
                            !Object.prototype.hasOwnProperty.call(exports, p)
                        )
                            __createBinding(exports, m, p);
                };
            Object.defineProperty(exports, "__esModule", { value: true });
            const events_1 = __nccwpck_require__(8614);
            const is_1 = __nccwpck_require__(7678);
            const PCancelable = __nccwpck_require__(9072);
            const types_1 = __nccwpck_require__(4597);
            const parse_body_1 = __nccwpck_require__(8220);
            const core_1 = __nccwpck_require__(94);
            const proxy_events_1 = __nccwpck_require__(3021);
            const get_buffer_1 = __nccwpck_require__(4500);
            const is_response_ok_1 = __nccwpck_require__(9298);
            const proxiedRequestEvents = [
                "request",
                "response",
                "redirect",
                "uploadProgress",
                "downloadProgress",
            ];
            function asPromise(normalizedOptions) {
                let globalRequest;
                let globalResponse;
                const emitter = new events_1.EventEmitter();
                const promise = new PCancelable((resolve, reject, onCancel) => {
                    const makeRequest = (retryCount) => {
                        const request = new core_1.default(
                            undefined,
                            normalizedOptions
                        );
                        request.retryCount = retryCount;
                        request._noPipe = true;
                        onCancel(() => request.destroy());
                        onCancel.shouldReject = false;
                        onCancel(() =>
                            reject(new types_1.CancelError(request))
                        );
                        globalRequest = request;
                        request.once("response", async (response) => {
                            var _a;
                            response.retryCount = retryCount;
                            if (response.request.aborted) {
                                // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error
                                return;
                            }
                            // Download body
                            let rawBody;
                            try {
                                rawBody = await get_buffer_1.default(request);
                                response.rawBody = rawBody;
                            } catch (_b) {
                                // The same error is caught below.
                                // See request.once('error')
                                return;
                            }
                            if (request._isAboutToError) {
                                return;
                            }
                            // Parse body
                            const contentEncoding = (
                                (_a = response.headers["content-encoding"]) !==
                                    null && _a !== void 0
                                    ? _a
                                    : ""
                            ).toLowerCase();
                            const isCompressed = [
                                "gzip",
                                "deflate",
                                "br",
                            ].includes(contentEncoding);
                            const { options } = request;
                            if (isCompressed && !options.decompress) {
                                response.body = rawBody;
                            } else {
                                try {
                                    response.body = parse_body_1.default(
                                        response,
                                        options.responseType,
                                        options.parseJson,
                                        options.encoding
                                    );
                                } catch (error) {
                                    // Fallback to `utf8`
                                    response.body = rawBody.toString();
                                    if (
                                        is_response_ok_1.isResponseOk(response)
                                    ) {
                                        request._beforeError(error);
                                        return;
                                    }
                                }
                            }
                            try {
                                for (const [
                                    index,
                                    hook,
                                ] of options.hooks.afterResponse.entries()) {
                                    // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise
                                    // eslint-disable-next-line no-await-in-loop
                                    response = await hook(
                                        response,
                                        async (updatedOptions) => {
                                            const typedOptions =
                                                core_1.default.normalizeArguments(
                                                    undefined,
                                                    {
                                                        ...updatedOptions,
                                                        retry: {
                                                            calculateDelay:
                                                                () => 0,
                                                        },
                                                        throwHttpErrors: false,
                                                        resolveBodyOnly: false,
                                                    },
                                                    options
                                                );
                                            // Remove any further hooks for that request, because we'll call them anyway.
                                            // The loop continues. We don't want duplicates (asPromise recursion).
                                            typedOptions.hooks.afterResponse =
                                                typedOptions.hooks.afterResponse.slice(
                                                    0,
                                                    index
                                                );
                                            for (const hook of typedOptions
                                                .hooks.beforeRetry) {
                                                // eslint-disable-next-line no-await-in-loop
                                                await hook(typedOptions);
                                            }
                                            const promise =
                                                asPromise(typedOptions);
                                            onCancel(() => {
                                                promise.catch(() => {});
                                                promise.cancel();
                                            });
                                            return promise;
                                        }
                                    );
                                }
                            } catch (error) {
                                request._beforeError(
                                    new types_1.RequestError(
                                        error.message,
                                        error,
                                        request
                                    )
                                );
                                return;
                            }
                            if (!is_response_ok_1.isResponseOk(response)) {
                                request._beforeError(
                                    new types_1.HTTPError(response)
                                );
                                return;
                            }
                            globalResponse = response;
                            resolve(
                                request.options.resolveBodyOnly
                                    ? response.body
                                    : response
                            );
                        });
                        const onError = (error) => {
                            if (promise.isCanceled) {
                                return;
                            }
                            const { options } = request;
                            if (
                                error instanceof types_1.HTTPError &&
                                !options.throwHttpErrors
                            ) {
                                const { response } = error;
                                resolve(
                                    request.options.resolveBodyOnly
                                        ? response.body
                                        : response
                                );
                                return;
                            }
                            reject(error);
                        };
                        request.once("error", onError);
                        const previousBody = request.options.body;
                        request.once("retry", (newRetryCount, error) => {
                            var _a, _b;
                            if (
                                previousBody ===
                                    ((_a = error.request) === null ||
                                    _a === void 0
                                        ? void 0
                                        : _a.options.body) &&
                                is_1.default.nodeStream(
                                    (_b = error.request) === null ||
                                        _b === void 0
                                        ? void 0
                                        : _b.options.body
                                )
                            ) {
                                onError(error);
                                return;
                            }
                            makeRequest(newRetryCount);
                        });
                        proxy_events_1.default(
                            request,
                            emitter,
                            proxiedRequestEvents
                        );
                    };
                    makeRequest(0);
                });
                promise.on = (event, fn) => {
                    emitter.on(event, fn);
                    return promise;
                };
                const shortcut = (responseType) => {
                    const newPromise = (async () => {
                        // Wait until downloading has ended
                        await promise;
                        const { options } = globalResponse.request;
                        return parse_body_1.default(
                            globalResponse,
                            responseType,
                            options.parseJson,
                            options.encoding
                        );
                    })();
                    Object.defineProperties(
                        newPromise,
                        Object.getOwnPropertyDescriptors(promise)
                    );
                    return newPromise;
                };
                promise.json = () => {
                    const { headers } = globalRequest.options;
                    if (
                        !globalRequest.writableFinished &&
                        headers.accept === undefined
                    ) {
                        headers.accept = "application/json";
                    }
                    return shortcut("json");
                };
                promise.buffer = () => shortcut("buffer");
                promise.text = () => shortcut("text");
                return promise;
            }
            exports.default = asPromise;
            __exportStar(__nccwpck_require__(4597), exports);

            /***/
        },

        /***/ 1048: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            const is_1 = __nccwpck_require__(7678);
            const normalizeArguments = (options, defaults) => {
                if (is_1.default.null_(options.encoding)) {
                    throw new TypeError(
                        "To get a Buffer, set `options.responseType` to `buffer` instead"
                    );
                }
                is_1.assert.any(
                    [is_1.default.string, is_1.default.undefined],
                    options.encoding
                );
                is_1.assert.any(
                    [is_1.default.boolean, is_1.default.undefined],
                    options.resolveBodyOnly
                );
                is_1.assert.any(
                    [is_1.default.boolean, is_1.default.undefined],
                    options.methodRewriting
                );
                is_1.assert.any(
                    [is_1.default.boolean, is_1.default.undefined],
                    options.isStream
                );
                is_1.assert.any(
                    [is_1.default.string, is_1.default.undefined],
                    options.responseType
                );
                // `options.responseType`
                if (options.responseType === undefined) {
                    options.responseType = "text";
                }
                // `options.retry`
                const { retry } = options;
                if (defaults) {
                    options.retry = { ...defaults.retry };
                } else {
                    options.retry = {
                        calculateDelay: (retryObject) =>
                            retryObject.computedValue,
                        limit: 0,
                        methods: [],
                        statusCodes: [],
                        errorCodes: [],
                        maxRetryAfter: undefined,
                    };
                }
                if (is_1.default.object(retry)) {
                    options.retry = {
                        ...options.retry,
                        ...retry,
                    };
                    options.retry.methods = [
                        ...new Set(
                            options.retry.methods.map((method) =>
                                method.toUpperCase()
                            )
                        ),
                    ];
                    options.retry.statusCodes = [
                        ...new Set(options.retry.statusCodes),
                    ];
                    options.retry.errorCodes = [
                        ...new Set(options.retry.errorCodes),
                    ];
                } else if (is_1.default.number(retry)) {
                    options.retry.limit = retry;
                }
                if (is_1.default.undefined(options.retry.maxRetryAfter)) {
                    options.retry.maxRetryAfter = Math.min(
                        // TypeScript is not smart enough to handle `.filter(x => is.number(x))`.
                        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator
                        ...[
                            options.timeout.request,
                            options.timeout.connect,
                        ].filter(is_1.default.number)
                    );
                }
                // `options.pagination`
                if (is_1.default.object(options.pagination)) {
                    if (defaults) {
                        options.pagination = {
                            ...defaults.pagination,
                            ...options.pagination,
                        };
                    }
                    const { pagination } = options;
                    if (!is_1.default.function_(pagination.transform)) {
                        throw new Error(
                            "`options.pagination.transform` must be implemented"
                        );
                    }
                    if (!is_1.default.function_(pagination.shouldContinue)) {
                        throw new Error(
                            "`options.pagination.shouldContinue` must be implemented"
                        );
                    }
                    if (!is_1.default.function_(pagination.filter)) {
                        throw new TypeError(
                            "`options.pagination.filter` must be implemented"
                        );
                    }
                    if (!is_1.default.function_(pagination.paginate)) {
                        throw new Error(
                            "`options.pagination.paginate` must be implemented"
                        );
                    }
                }
                // JSON mode
                if (
                    options.responseType === "json" &&
                    options.headers.accept === undefined
                ) {
                    options.headers.accept = "application/json";
                }
                return options;
            };
            exports.default = normalizeArguments;

            /***/
        },

        /***/ 8220: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            const types_1 = __nccwpck_require__(4597);
            const parseBody = (response, responseType, parseJson, encoding) => {
                const { rawBody } = response;
                try {
                    if (responseType === "text") {
                        return rawBody.toString(encoding);
                    }
                    if (responseType === "json") {
                        return rawBody.length === 0
                            ? ""
                            : parseJson(rawBody.toString());
                    }
                    if (responseType === "buffer") {
                        return rawBody;
                    }
                    throw new types_1.ParseError(
                        {
                            message: `Unknown body type '${responseType}'`,
                            name: "Error",
                        },
                        response
                    );
                } catch (error) {
                    throw new types_1.ParseError(error, response);
                }
            };
            exports.default = parseBody;

            /***/
        },

        /***/ 4597: /***/ function (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) {
            "use strict";

            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          Object.defineProperty(o, k2, {
                              enumerable: true,
                              get: function () {
                                  return m[k];
                              },
                          });
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __exportStar =
                (this && this.__exportStar) ||
                function (m, exports) {
                    for (var p in m)
                        if (
                            p !== "default" &&
                            !Object.prototype.hasOwnProperty.call(exports, p)
                        )
                            __createBinding(exports, m, p);
                };
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.CancelError = exports.ParseError = void 0;
            const core_1 = __nccwpck_require__(94);
            /**
An error to be thrown when server response code is 2xx, and parsing body fails.
Includes a `response` property.
*/
            class ParseError extends core_1.RequestError {
                constructor(error, response) {
                    const { options } = response.request;
                    super(
                        `${error.message} in "${options.url.toString()}"`,
                        error,
                        response.request
                    );
                    this.name = "ParseError";
                }
            }
            exports.ParseError = ParseError;
            /**
An error to be thrown when the request is aborted with `.cancel()`.
*/
            class CancelError extends core_1.RequestError {
                constructor(request) {
                    super("Promise was canceled", {}, request);
                    this.name = "CancelError";
                }
                get isCanceled() {
                    return true;
                }
            }
            exports.CancelError = CancelError;
            __exportStar(__nccwpck_require__(94), exports);

            /***/
        },

        /***/ 3462: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            exports.retryAfterStatusCodes = void 0;
            exports.retryAfterStatusCodes = new Set([413, 429, 503]);
            const calculateRetryDelay = ({
                attemptCount,
                retryOptions,
                error,
                retryAfter,
            }) => {
                if (attemptCount > retryOptions.limit) {
                    return 0;
                }
                const hasMethod = retryOptions.methods.includes(
                    error.options.method
                );
                const hasErrorCode = retryOptions.errorCodes.includes(
                    error.code
                );
                const hasStatusCode =
                    error.response &&
                    retryOptions.statusCodes.includes(
                        error.response.statusCode
                    );
                if (!hasMethod || (!hasErrorCode && !hasStatusCode)) {
                    return 0;
                }
                if (error.response) {
                    if (retryAfter) {
                        if (
                            retryOptions.maxRetryAfter === undefined ||
                            retryAfter > retryOptions.maxRetryAfter
                        ) {
                            return 0;
                        }
                        return retryAfter;
                    }
                    if (error.response.statusCode === 413) {
                        return 0;
                    }
                }
                const noise = Math.random() * 100;
                return 2 ** (attemptCount - 1) * 1000 + noise;
            };
            exports.default = calculateRetryDelay;

            /***/
        },

        /***/ 94: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            exports.UnsupportedProtocolError =
                exports.ReadError =
                exports.TimeoutError =
                exports.UploadError =
                exports.CacheError =
                exports.HTTPError =
                exports.MaxRedirectsError =
                exports.RequestError =
                exports.setNonEnumerableProperties =
                exports.knownHookEvents =
                exports.withoutBody =
                exports.kIsNormalizedAlready =
                    void 0;
            const util_1 = __nccwpck_require__(1669);
            const stream_1 = __nccwpck_require__(2413);
            const fs_1 = __nccwpck_require__(5747);
            const url_1 = __nccwpck_require__(8835);
            const http = __nccwpck_require__(8605);
            const http_1 = __nccwpck_require__(8605);
            const https = __nccwpck_require__(7211);
            const http_timer_1 = __nccwpck_require__(8097);
            const cacheable_lookup_1 = __nccwpck_require__(2286);
            const CacheableRequest = __nccwpck_require__(8116);
            const decompressResponse = __nccwpck_require__(2391);
            // @ts-expect-error Missing types
            const http2wrapper = __nccwpck_require__(4645);
            const lowercaseKeys = __nccwpck_require__(9662);
            const is_1 = __nccwpck_require__(7678);
            const get_body_size_1 = __nccwpck_require__(4564);
            const is_form_data_1 = __nccwpck_require__(40);
            const proxy_events_1 = __nccwpck_require__(3021);
            const timed_out_1 = __nccwpck_require__(2454);
            const url_to_options_1 = __nccwpck_require__(8026);
            const options_to_url_1 = __nccwpck_require__(9219);
            const weakable_map_1 = __nccwpck_require__(7288);
            const get_buffer_1 = __nccwpck_require__(4500);
            const dns_ip_version_1 = __nccwpck_require__(4993);
            const is_response_ok_1 = __nccwpck_require__(9298);
            const deprecation_warning_1 = __nccwpck_require__(397);
            const normalize_arguments_1 = __nccwpck_require__(1048);
            const calculate_retry_delay_1 = __nccwpck_require__(3462);
            let globalDnsCache;
            const kRequest = Symbol("request");
            const kResponse = Symbol("response");
            const kResponseSize = Symbol("responseSize");
            const kDownloadedSize = Symbol("downloadedSize");
            const kBodySize = Symbol("bodySize");
            const kUploadedSize = Symbol("uploadedSize");
            const kServerResponsesPiped = Symbol("serverResponsesPiped");
            const kUnproxyEvents = Symbol("unproxyEvents");
            const kIsFromCache = Symbol("isFromCache");
            const kCancelTimeouts = Symbol("cancelTimeouts");
            const kStartedReading = Symbol("startedReading");
            const kStopReading = Symbol("stopReading");
            const kTriggerRead = Symbol("triggerRead");
            const kBody = Symbol("body");
            const kJobs = Symbol("jobs");
            const kOriginalResponse = Symbol("originalResponse");
            const kRetryTimeout = Symbol("retryTimeout");
            exports.kIsNormalizedAlready = Symbol("isNormalizedAlready");
            const supportsBrotli = is_1.default.string(process.versions.brotli);
            exports.withoutBody = new Set(["GET", "HEAD"]);
            exports.knownHookEvents = [
                "init",
                "beforeRequest",
                "beforeRedirect",
                "beforeError",
                "beforeRetry",
                // Promise-Only
                "afterResponse",
            ];
            function validateSearchParameters(searchParameters) {
                // eslint-disable-next-line guard-for-in
                for (const key in searchParameters) {
                    const value = searchParameters[key];
                    if (
                        !is_1.default.string(value) &&
                        !is_1.default.number(value) &&
                        !is_1.default.boolean(value) &&
                        !is_1.default.null_(value) &&
                        !is_1.default.undefined(value)
                    ) {
                        throw new TypeError(
                            `The \`searchParams\` value '${String(
                                value
                            )}' must be a string, number, boolean or null`
                        );
                    }
                }
            }
            function isClientRequest(clientRequest) {
                return (
                    is_1.default.object(clientRequest) &&
                    !("statusCode" in clientRequest)
                );
            }
            const cacheableStore = new weakable_map_1.default();
            const waitForOpenFile = async (file) =>
                new Promise((resolve, reject) => {
                    const onError = (error) => {
                        reject(error);
                    };
                    // Node.js 12 has incomplete types
                    if (!file.pending) {
                        resolve();
                    }
                    file.once("error", onError);
                    file.once("ready", () => {
                        file.off("error", onError);
                        resolve();
                    });
                });
            const redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);
            const nonEnumerableProperties = ["context", "body", "json", "form"];
            exports.setNonEnumerableProperties = (sources, to) => {
                // Non enumerable properties shall not be merged
                const properties = {};
                for (const source of sources) {
                    if (!source) {
                        continue;
                    }
                    for (const name of nonEnumerableProperties) {
                        if (!(name in source)) {
                            continue;
                        }
                        properties[name] = {
                            writable: true,
                            configurable: true,
                            enumerable: false,
                            // @ts-expect-error TS doesn't see the check above
                            value: source[name],
                        };
                    }
                }
                Object.defineProperties(to, properties);
            };
            /**
An error to be thrown when a request fails.
Contains a `code` property with error class code, like `ECONNREFUSED`.
*/
            class RequestError extends Error {
                constructor(message, error, self) {
                    var _a;
                    super(message);
                    Error.captureStackTrace(this, this.constructor);
                    this.name = "RequestError";
                    this.code = error.code;
                    if (self instanceof Request) {
                        Object.defineProperty(this, "request", {
                            enumerable: false,
                            value: self,
                        });
                        Object.defineProperty(this, "response", {
                            enumerable: false,
                            value: self[kResponse],
                        });
                        Object.defineProperty(this, "options", {
                            // This fails because of TS 3.7.2 useDefineForClassFields
                            // Ref: https://github.com/microsoft/TypeScript/issues/34972
                            enumerable: false,
                            value: self.options,
                        });
                    } else {
                        Object.defineProperty(this, "options", {
                            // This fails because of TS 3.7.2 useDefineForClassFields
                            // Ref: https://github.com/microsoft/TypeScript/issues/34972
                            enumerable: false,
                            value: self,
                        });
                    }
                    this.timings =
                        (_a = this.request) === null || _a === void 0
                            ? void 0
                            : _a.timings;
                    // Recover the original stacktrace
                    if (
                        is_1.default.string(error.stack) &&
                        is_1.default.string(this.stack)
                    ) {
                        const indexOfMessage =
                            this.stack.indexOf(this.message) +
                            this.message.length;
                        const thisStackTrace = this.stack
                            .slice(indexOfMessage)
                            .split("\n")
                            .reverse();
                        const errorStackTrace = error.stack
                            .slice(
                                error.stack.indexOf(error.message) +
                                    error.message.length
                            )
                            .split("\n")
                            .reverse();
                        // Remove duplicated traces
                        while (
                            errorStackTrace.length !== 0 &&
                            errorStackTrace[0] === thisStackTrace[0]
                        ) {
                            thisStackTrace.shift();
                        }
                        this.stack = `${this.stack.slice(
                            0,
                            indexOfMessage
                        )}${thisStackTrace
                            .reverse()
                            .join("\n")}${errorStackTrace
                            .reverse()
                            .join("\n")}`;
                    }
                }
            }
            exports.RequestError = RequestError;
            /**
An error to be thrown when the server redirects you more than ten times.
Includes a `response` property.
*/
            class MaxRedirectsError extends RequestError {
                constructor(request) {
                    super(
                        `Redirected ${request.options.maxRedirects} times. Aborting.`,
                        {},
                        request
                    );
                    this.name = "MaxRedirectsError";
                }
            }
            exports.MaxRedirectsError = MaxRedirectsError;
            /**
An error to be thrown when the server response code is not 2xx nor 3xx if `options.followRedirect` is `true`, but always except for 304.
Includes a `response` property.
*/
            class HTTPError extends RequestError {
                constructor(response) {
                    super(
                        `Response code ${response.statusCode} (${response.statusMessage})`,
                        {},
                        response.request
                    );
                    this.name = "HTTPError";
                }
            }
            exports.HTTPError = HTTPError;
            /**
An error to be thrown when a cache method fails.
For example, if the database goes down or there's a filesystem error.
*/
            class CacheError extends RequestError {
                constructor(error, request) {
                    super(error.message, error, request);
                    this.name = "CacheError";
                }
            }
            exports.CacheError = CacheError;
            /**
An error to be thrown when the request body is a stream and an error occurs while reading from that stream.
*/
            class UploadError extends RequestError {
                constructor(error, request) {
                    super(error.message, error, request);
                    this.name = "UploadError";
                }
            }
            exports.UploadError = UploadError;
            /**
An error to be thrown when the request is aborted due to a timeout.
Includes an `event` and `timings` property.
*/
            class TimeoutError extends RequestError {
                constructor(error, timings, request) {
                    super(error.message, error, request);
                    this.name = "TimeoutError";
                    this.event = error.event;
                    this.timings = timings;
                }
            }
            exports.TimeoutError = TimeoutError;
            /**
An error to be thrown when reading from response stream fails.
*/
            class ReadError extends RequestError {
                constructor(error, request) {
                    super(error.message, error, request);
                    this.name = "ReadError";
                }
            }
            exports.ReadError = ReadError;
            /**
An error to be thrown when given an unsupported protocol.
*/
            class UnsupportedProtocolError extends RequestError {
                constructor(options) {
                    super(
                        `Unsupported protocol "${options.url.protocol}"`,
                        {},
                        options
                    );
                    this.name = "UnsupportedProtocolError";
                }
            }
            exports.UnsupportedProtocolError = UnsupportedProtocolError;
            const proxiedRequestEvents = [
                "socket",
                "connect",
                "continue",
                "information",
                "upgrade",
                "timeout",
            ];
            class Request extends stream_1.Duplex {
                constructor(url, options = {}, defaults) {
                    super({
                        // This must be false, to enable throwing after destroy
                        // It is used for retry logic in Promise API
                        autoDestroy: false,
                        // It needs to be zero because we're just proxying the data to another stream
                        highWaterMark: 0,
                    });
                    this[kDownloadedSize] = 0;
                    this[kUploadedSize] = 0;
                    this.requestInitialized = false;
                    this[kServerResponsesPiped] = new Set();
                    this.redirects = [];
                    this[kStopReading] = false;
                    this[kTriggerRead] = false;
                    this[kJobs] = [];
                    this.retryCount = 0;
                    // TODO: Remove this when targeting Node.js >= 12
                    this._progressCallbacks = [];
                    const unlockWrite = () => this._unlockWrite();
                    const lockWrite = () => this._lockWrite();
                    this.on("pipe", (source) => {
                        source.prependListener("data", unlockWrite);
                        source.on("data", lockWrite);
                        source.prependListener("end", unlockWrite);
                        source.on("end", lockWrite);
                    });
                    this.on("unpipe", (source) => {
                        source.off("data", unlockWrite);
                        source.off("data", lockWrite);
                        source.off("end", unlockWrite);
                        source.off("end", lockWrite);
                    });
                    this.on("pipe", (source) => {
                        if (source instanceof http_1.IncomingMessage) {
                            this.options.headers = {
                                ...source.headers,
                                ...this.options.headers,
                            };
                        }
                    });
                    const { json, body, form } = options;
                    if (json || body || form) {
                        this._lockWrite();
                    }
                    if (exports.kIsNormalizedAlready in options) {
                        this.options = options;
                    } else {
                        try {
                            // @ts-expect-error Common TypeScript bug saying that `this.constructor` is not accessible
                            this.options = this.constructor.normalizeArguments(
                                url,
                                options,
                                defaults
                            );
                        } catch (error) {
                            // TODO: Move this to `_destroy()`
                            if (is_1.default.nodeStream(options.body)) {
                                options.body.destroy();
                            }
                            this.destroy(error);
                            return;
                        }
                    }
                    (async () => {
                        var _a;
                        try {
                            if (this.options.body instanceof fs_1.ReadStream) {
                                await waitForOpenFile(this.options.body);
                            }
                            const { url: normalizedURL } = this.options;
                            if (!normalizedURL) {
                                throw new TypeError("Missing `url` property");
                            }
                            this.requestUrl = normalizedURL.toString();
                            decodeURI(this.requestUrl);
                            await this._finalizeBody();
                            await this._makeRequest();
                            if (this.destroyed) {
                                (_a = this[kRequest]) === null || _a === void 0
                                    ? void 0
                                    : _a.destroy();
                                return;
                            }
                            // Queued writes etc.
                            for (const job of this[kJobs]) {
                                job();
                            }
                            // Prevent memory leak
                            this[kJobs].length = 0;
                            this.requestInitialized = true;
                        } catch (error) {
                            if (error instanceof RequestError) {
                                this._beforeError(error);
                                return;
                            }
                            // This is a workaround for https://github.com/nodejs/node/issues/33335
                            if (!this.destroyed) {
                                this.destroy(error);
                            }
                        }
                    })();
                }
                static normalizeArguments(url, options, defaults) {
                    var _a, _b, _c, _d, _e;
                    const rawOptions = options;
                    if (
                        is_1.default.object(url) &&
                        !is_1.default.urlInstance(url)
                    ) {
                        options = { ...defaults, ...url, ...options };
                    } else {
                        if (url && options && options.url !== undefined) {
                            throw new TypeError(
                                "The `url` option is mutually exclusive with the `input` argument"
                            );
                        }
                        options = { ...defaults, ...options };
                        if (url !== undefined) {
                            options.url = url;
                        }
                        if (is_1.default.urlInstance(options.url)) {
                            options.url = new url_1.URL(options.url.toString());
                        }
                    }
                    // TODO: Deprecate URL options in Got 12.
                    // Support extend-specific options
                    if (options.cache === false) {
                        options.cache = undefined;
                    }
                    if (options.dnsCache === false) {
                        options.dnsCache = undefined;
                    }
                    // Nice type assertions
                    is_1.assert.any(
                        [is_1.default.string, is_1.default.undefined],
                        options.method
                    );
                    is_1.assert.any(
                        [is_1.default.object, is_1.default.undefined],
                        options.headers
                    );
                    is_1.assert.any(
                        [
                            is_1.default.string,
                            is_1.default.urlInstance,
                            is_1.default.undefined,
                        ],
                        options.prefixUrl
                    );
                    is_1.assert.any(
                        [is_1.default.object, is_1.default.undefined],
                        options.cookieJar
                    );
                    is_1.assert.any(
                        [
                            is_1.default.object,
                            is_1.default.string,
                            is_1.default.undefined,
                        ],
                        options.searchParams
                    );
                    is_1.assert.any(
                        [
                            is_1.default.object,
                            is_1.default.string,
                            is_1.default.undefined,
                        ],
                        options.cache
                    );
                    is_1.assert.any(
                        [
                            is_1.default.object,
                            is_1.default.number,
                            is_1.default.undefined,
                        ],
                        options.timeout
                    );
                    is_1.assert.any(
                        [is_1.default.object, is_1.default.undefined],
                        options.context
                    );
                    is_1.assert.any(
                        [is_1.default.object, is_1.default.undefined],
                        options.hooks
                    );
                    is_1.assert.any(
                        [is_1.default.boolean, is_1.default.undefined],
                        options.decompress
                    );
                    is_1.assert.any(
                        [is_1.default.boolean, is_1.default.undefined],
                        options.ignoreInvalidCookies
                    );
                    is_1.assert.any(
                        [is_1.default.boolean, is_1.default.undefined],
                        options.followRedirect
                    );
                    is_1.assert.any(
                        [is_1.default.number, is_1.default.undefined],
                        options.maxRedirects
                    );
                    is_1.assert.any(
                        [is_1.default.boolean, is_1.default.undefined],
                        options.throwHttpErrors
                    );
                    is_1.assert.any(
                        [is_1.default.boolean, is_1.default.undefined],
                        options.http2
                    );
                    is_1.assert.any(
                        [is_1.default.boolean, is_1.default.undefined],
                        options.allowGetBody
                    );
                    is_1.assert.any(
                        [is_1.default.string, is_1.default.undefined],
                        options.localAddress
                    );
                    is_1.assert.any(
                        [
                            dns_ip_version_1.isDnsLookupIpVersion,
                            is_1.default.undefined,
                        ],
                        options.dnsLookupIpVersion
                    );
                    is_1.assert.any(
                        [is_1.default.object, is_1.default.undefined],
                        options.https
                    );
                    is_1.assert.any(
                        [is_1.default.boolean, is_1.default.undefined],
                        options.rejectUnauthorized
                    );
                    if (options.https) {
                        is_1.assert.any(
                            [is_1.default.boolean, is_1.default.undefined],
                            options.https.rejectUnauthorized
                        );
                        is_1.assert.any(
                            [is_1.default.function_, is_1.default.undefined],
                            options.https.checkServerIdentity
                        );
                        is_1.assert.any(
                            [
                                is_1.default.string,
                                is_1.default.object,
                                is_1.default.array,
                                is_1.default.undefined,
                            ],
                            options.https.certificateAuthority
                        );
                        is_1.assert.any(
                            [
                                is_1.default.string,
                                is_1.default.object,
                                is_1.default.array,
                                is_1.default.undefined,
                            ],
                            options.https.key
                        );
                        is_1.assert.any(
                            [
                                is_1.default.string,
                                is_1.default.object,
                                is_1.default.array,
                                is_1.default.undefined,
                            ],
                            options.https.certificate
                        );
                        is_1.assert.any(
                            [is_1.default.string, is_1.default.undefined],
                            options.https.passphrase
                        );
                        is_1.assert.any(
                            [
                                is_1.default.string,
                                is_1.default.buffer,
                                is_1.default.array,
                                is_1.default.undefined,
                            ],
                            options.https.pfx
                        );
                    }
                    is_1.assert.any(
                        [is_1.default.object, is_1.default.undefined],
                        options.cacheOptions
                    );
                    // `options.method`
                    if (is_1.default.string(options.method)) {
                        options.method = options.method.toUpperCase();
                    } else {
                        options.method = "GET";
                    }
                    // `options.headers`
                    if (
                        options.headers ===
                        (defaults === null || defaults === void 0
                            ? void 0
                            : defaults.headers)
                    ) {
                        options.headers = { ...options.headers };
                    } else {
                        options.headers = lowercaseKeys({
                            ...(defaults === null || defaults === void 0
                                ? void 0
                                : defaults.headers),
                            ...options.headers,
                        });
                    }
                    // Disallow legacy `url.Url`
                    if ("slashes" in options) {
                        throw new TypeError(
                            "The legacy `url.Url` has been deprecated. Use `URL` instead."
                        );
                    }
                    // `options.auth`
                    if ("auth" in options) {
                        throw new TypeError(
                            "Parameter `auth` is deprecated. Use `username` / `password` instead."
                        );
                    }
                    // `options.searchParams`
                    if ("searchParams" in options) {
                        if (
                            options.searchParams &&
                            options.searchParams !==
                                (defaults === null || defaults === void 0
                                    ? void 0
                                    : defaults.searchParams)
                        ) {
                            let searchParameters;
                            if (
                                is_1.default.string(options.searchParams) ||
                                options.searchParams instanceof
                                    url_1.URLSearchParams
                            ) {
                                searchParameters = new url_1.URLSearchParams(
                                    options.searchParams
                                );
                            } else {
                                validateSearchParameters(options.searchParams);
                                searchParameters = new url_1.URLSearchParams();
                                // eslint-disable-next-line guard-for-in
                                for (const key in options.searchParams) {
                                    const value = options.searchParams[key];
                                    if (value === null) {
                                        searchParameters.append(key, "");
                                    } else if (value !== undefined) {
                                        searchParameters.append(key, value);
                                    }
                                }
                            }
                            // `normalizeArguments()` is also used to merge options
                            (_a =
                                defaults === null || defaults === void 0
                                    ? void 0
                                    : defaults.searchParams) === null ||
                            _a === void 0
                                ? void 0
                                : _a.forEach((value, key) => {
                                      // Only use default if one isn't already defined
                                      if (!searchParameters.has(key)) {
                                          searchParameters.append(key, value);
                                      }
                                  });
                            options.searchParams = searchParameters;
                        }
                    }
                    // `options.username` & `options.password`
                    options.username =
                        (_b = options.username) !== null && _b !== void 0
                            ? _b
                            : "";
                    options.password =
                        (_c = options.password) !== null && _c !== void 0
                            ? _c
                            : "";
                    // `options.prefixUrl` & `options.url`
                    if (is_1.default.undefined(options.prefixUrl)) {
                        options.prefixUrl =
                            (_d =
                                defaults === null || defaults === void 0
                                    ? void 0
                                    : defaults.prefixUrl) !== null &&
                            _d !== void 0
                                ? _d
                                : "";
                    } else {
                        options.prefixUrl = options.prefixUrl.toString();
                        if (
                            options.prefixUrl !== "" &&
                            !options.prefixUrl.endsWith("/")
                        ) {
                            options.prefixUrl += "/";
                        }
                    }
                    if (is_1.default.string(options.url)) {
                        if (options.url.startsWith("/")) {
                            throw new Error(
                                "`input` must not start with a slash when using `prefixUrl`"
                            );
                        }
                        options.url = options_to_url_1.default(
                            options.prefixUrl + options.url,
                            options
                        );
                    } else if (
                        (is_1.default.undefined(options.url) &&
                            options.prefixUrl !== "") ||
                        options.protocol
                    ) {
                        options.url = options_to_url_1.default(
                            options.prefixUrl,
                            options
                        );
                    }
                    if (options.url) {
                        if ("port" in options) {
                            delete options.port;
                        }
                        // Make it possible to change `options.prefixUrl`
                        let { prefixUrl } = options;
                        Object.defineProperty(options, "prefixUrl", {
                            set: (value) => {
                                const url = options.url;
                                if (!url.href.startsWith(value)) {
                                    throw new Error(
                                        `Cannot change \`prefixUrl\` from ${prefixUrl} to ${value}: ${url.href}`
                                    );
                                }
                                options.url = new url_1.URL(
                                    value + url.href.slice(prefixUrl.length)
                                );
                                prefixUrl = value;
                            },
                            get: () => prefixUrl,
                        });
                        // Support UNIX sockets
                        let { protocol } = options.url;
                        if (protocol === "unix:") {
                            protocol = "http:";
                            options.url = new url_1.URL(
                                `http://unix${options.url.pathname}${options.url.search}`
                            );
                        }
                        // Set search params
                        if (options.searchParams) {
                            // eslint-disable-next-line @typescript-eslint/no-base-to-string
                            options.url.search =
                                options.searchParams.toString();
                        }
                        // Protocol check
                        if (protocol !== "http:" && protocol !== "https:") {
                            throw new UnsupportedProtocolError(options);
                        }
                        // Update `username`
                        if (options.username === "") {
                            options.username = options.url.username;
                        } else {
                            options.url.username = options.username;
                        }
                        // Update `password`
                        if (options.password === "") {
                            options.password = options.url.password;
                        } else {
                            options.url.password = options.password;
                        }
                    }
                    // `options.cookieJar`
                    const { cookieJar } = options;
                    if (cookieJar) {
                        let { setCookie, getCookieString } = cookieJar;
                        is_1.assert.function_(setCookie);
                        is_1.assert.function_(getCookieString);
                        /* istanbul ignore next: Horrible `tough-cookie` v3 check */
                        if (
                            setCookie.length === 4 &&
                            getCookieString.length === 0
                        ) {
                            setCookie = util_1.promisify(
                                setCookie.bind(options.cookieJar)
                            );
                            getCookieString = util_1.promisify(
                                getCookieString.bind(options.cookieJar)
                            );
                            options.cookieJar = {
                                setCookie,
                                getCookieString: getCookieString,
                            };
                        }
                    }
                    // `options.cache`
                    const { cache } = options;
                    if (cache) {
                        if (!cacheableStore.has(cache)) {
                            cacheableStore.set(
                                cache,
                                new CacheableRequest(
                                    (requestOptions, handler) => {
                                        const result = requestOptions[kRequest](
                                            requestOptions,
                                            handler
                                        );
                                        // TODO: remove this when `cacheable-request` supports async request functions.
                                        if (is_1.default.promise(result)) {
                                            // @ts-expect-error
                                            // We only need to implement the error handler in order to support HTTP2 caching.
                                            // The result will be a promise anyway.
                                            result.once = (event, handler) => {
                                                if (event === "error") {
                                                    result.catch(handler);
                                                } else if (event === "abort") {
                                                    // The empty catch is needed here in case when
                                                    // it rejects before it's `await`ed in `_makeRequest`.
                                                    (async () => {
                                                        try {
                                                            const request =
                                                                await result;
                                                            request.once(
                                                                "abort",
                                                                handler
                                                            );
                                                        } catch (_a) {}
                                                    })();
                                                } else {
                                                    /* istanbul ignore next: safety check */
                                                    throw new Error(
                                                        `Unknown HTTP2 promise event: ${event}`
                                                    );
                                                }
                                                return result;
                                            };
                                        }
                                        return result;
                                    },
                                    cache
                                )
                            );
                        }
                    }
                    // `options.cacheOptions`
                    options.cacheOptions = { ...options.cacheOptions };
                    // `options.dnsCache`
                    if (options.dnsCache === true) {
                        if (!globalDnsCache) {
                            globalDnsCache = new cacheable_lookup_1.default();
                        }
                        options.dnsCache = globalDnsCache;
                    } else if (
                        !is_1.default.undefined(options.dnsCache) &&
                        !options.dnsCache.lookup
                    ) {
                        throw new TypeError(
                            `Parameter \`dnsCache\` must be a CacheableLookup instance or a boolean, got ${is_1.default(
                                options.dnsCache
                            )}`
                        );
                    }
                    // `options.timeout`
                    if (is_1.default.number(options.timeout)) {
                        options.timeout = { request: options.timeout };
                    } else if (
                        defaults &&
                        options.timeout !== defaults.timeout
                    ) {
                        options.timeout = {
                            ...defaults.timeout,
                            ...options.timeout,
                        };
                    } else {
                        options.timeout = { ...options.timeout };
                    }
                    // `options.context`
                    if (!options.context) {
                        options.context = {};
                    }
                    // `options.hooks`
                    const areHooksDefault =
                        options.hooks ===
                        (defaults === null || defaults === void 0
                            ? void 0
                            : defaults.hooks);
                    options.hooks = { ...options.hooks };
                    for (const event of exports.knownHookEvents) {
                        if (event in options.hooks) {
                            if (is_1.default.array(options.hooks[event])) {
                                // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044
                                options.hooks[event] = [
                                    ...options.hooks[event],
                                ];
                            } else {
                                throw new TypeError(
                                    `Parameter \`${event}\` must be an Array, got ${is_1.default(
                                        options.hooks[event]
                                    )}`
                                );
                            }
                        } else {
                            options.hooks[event] = [];
                        }
                    }
                    if (defaults && !areHooksDefault) {
                        for (const event of exports.knownHookEvents) {
                            const defaultHooks = defaults.hooks[event];
                            if (defaultHooks.length > 0) {
                                // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044
                                options.hooks[event] = [
                                    ...defaults.hooks[event],
                                    ...options.hooks[event],
                                ];
                            }
                        }
                    }
                    // DNS options
                    if ("family" in options) {
                        deprecation_warning_1.default(
                            '"options.family" was never documented, please use "options.dnsLookupIpVersion"'
                        );
                    }
                    // HTTPS options
                    if (
                        defaults === null || defaults === void 0
                            ? void 0
                            : defaults.https
                    ) {
                        options.https = { ...defaults.https, ...options.https };
                    }
                    if ("rejectUnauthorized" in options) {
                        deprecation_warning_1.default(
                            '"options.rejectUnauthorized" is now deprecated, please use "options.https.rejectUnauthorized"'
                        );
                    }
                    if ("checkServerIdentity" in options) {
                        deprecation_warning_1.default(
                            '"options.checkServerIdentity" was never documented, please use "options.https.checkServerIdentity"'
                        );
                    }
                    if ("ca" in options) {
                        deprecation_warning_1.default(
                            '"options.ca" was never documented, please use "options.https.certificateAuthority"'
                        );
                    }
                    if ("key" in options) {
                        deprecation_warning_1.default(
                            '"options.key" was never documented, please use "options.https.key"'
                        );
                    }
                    if ("cert" in options) {
                        deprecation_warning_1.default(
                            '"options.cert" was never documented, please use "options.https.certificate"'
                        );
                    }
                    if ("passphrase" in options) {
                        deprecation_warning_1.default(
                            '"options.passphrase" was never documented, please use "options.https.passphrase"'
                        );
                    }
                    if ("pfx" in options) {
                        deprecation_warning_1.default(
                            '"options.pfx" was never documented, please use "options.https.pfx"'
                        );
                    }
                    // Other options
                    if ("followRedirects" in options) {
                        throw new TypeError(
                            "The `followRedirects` option does not exist. Use `followRedirect` instead."
                        );
                    }
                    if (options.agent) {
                        for (const key in options.agent) {
                            if (
                                key !== "http" &&
                                key !== "https" &&
                                key !== "http2"
                            ) {
                                throw new TypeError(
                                    `Expected the \`options.agent\` properties to be \`http\`, \`https\` or \`http2\`, got \`${key}\``
                                );
                            }
                        }
                    }
                    options.maxRedirects =
                        (_e = options.maxRedirects) !== null && _e !== void 0
                            ? _e
                            : 0;
                    // Set non-enumerable properties
                    exports.setNonEnumerableProperties(
                        [defaults, rawOptions],
                        options
                    );
                    return normalize_arguments_1.default(options, defaults);
                }
                _lockWrite() {
                    const onLockedWrite = () => {
                        throw new TypeError(
                            "The payload has been already provided"
                        );
                    };
                    this.write = onLockedWrite;
                    this.end = onLockedWrite;
                }
                _unlockWrite() {
                    this.write = super.write;
                    this.end = super.end;
                }
                async _finalizeBody() {
                    const { options } = this;
                    const { headers } = options;
                    const isForm = !is_1.default.undefined(options.form);
                    const isJSON = !is_1.default.undefined(options.json);
                    const isBody = !is_1.default.undefined(options.body);
                    const hasPayload = isForm || isJSON || isBody;
                    const cannotHaveBody =
                        exports.withoutBody.has(options.method) &&
                        !(options.method === "GET" && options.allowGetBody);
                    this._cannotHaveBody = cannotHaveBody;
                    if (hasPayload) {
                        if (cannotHaveBody) {
                            throw new TypeError(
                                `The \`${options.method}\` method cannot be used with a body`
                            );
                        }
                        if (
                            [isBody, isForm, isJSON].filter((isTrue) => isTrue)
                                .length > 1
                        ) {
                            throw new TypeError(
                                "The `body`, `json` and `form` options are mutually exclusive"
                            );
                        }
                        if (
                            isBody &&
                            !(options.body instanceof stream_1.Readable) &&
                            !is_1.default.string(options.body) &&
                            !is_1.default.buffer(options.body) &&
                            !is_form_data_1.default(options.body)
                        ) {
                            throw new TypeError(
                                "The `body` option must be a stream.Readable, string or Buffer"
                            );
                        }
                        if (isForm && !is_1.default.object(options.form)) {
                            throw new TypeError(
                                "The `form` option must be an Object"
                            );
                        }
                        {
                            // Serialize body
                            const noContentType = !is_1.default.string(
                                headers["content-type"]
                            );
                            if (isBody) {
                                // Special case for https://github.com/form-data/form-data
                                if (
                                    is_form_data_1.default(options.body) &&
                                    noContentType
                                ) {
                                    headers[
                                        "content-type"
                                    ] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
                                }
                                this[kBody] = options.body;
                            } else if (isForm) {
                                if (noContentType) {
                                    headers["content-type"] =
                                        "application/x-www-form-urlencoded";
                                }
                                this[kBody] = new url_1.URLSearchParams(
                                    options.form
                                ).toString();
                            } else {
                                if (noContentType) {
                                    headers["content-type"] =
                                        "application/json";
                                }
                                this[kBody] = options.stringifyJson(
                                    options.json
                                );
                            }
                            const uploadBodySize =
                                await get_body_size_1.default(
                                    this[kBody],
                                    options.headers
                                );
                            // See https://tools.ietf.org/html/rfc7230#section-3.3.2
                            // A user agent SHOULD send a Content-Length in a request message when
                            // no Transfer-Encoding is sent and the request method defines a meaning
                            // for an enclosed payload body.  For example, a Content-Length header
                            // field is normally sent in a POST request even when the value is 0
                            // (indicating an empty payload body).  A user agent SHOULD NOT send a
                            // Content-Length header field when the request message does not contain
                            // a payload body and the method semantics do not anticipate such a
                            // body.
                            if (
                                is_1.default.undefined(
                                    headers["content-length"]
                                ) &&
                                is_1.default.undefined(
                                    headers["transfer-encoding"]
                                )
                            ) {
                                if (
                                    !cannotHaveBody &&
                                    !is_1.default.undefined(uploadBodySize)
                                ) {
                                    headers["content-length"] =
                                        String(uploadBodySize);
                                }
                            }
                        }
                    } else if (cannotHaveBody) {
                        this._lockWrite();
                    } else {
                        this._unlockWrite();
                    }
                    this[kBodySize] =
                        Number(headers["content-length"]) || undefined;
                }
                async _onResponseBase(response) {
                    const { options } = this;
                    const { url } = options;
                    this[kOriginalResponse] = response;
                    if (options.decompress) {
                        response = decompressResponse(response);
                    }
                    const statusCode = response.statusCode;
                    const typedResponse = response;
                    typedResponse.statusMessage = typedResponse.statusMessage
                        ? typedResponse.statusMessage
                        : http.STATUS_CODES[statusCode];
                    typedResponse.url = options.url.toString();
                    typedResponse.requestUrl = this.requestUrl;
                    typedResponse.redirectUrls = this.redirects;
                    typedResponse.request = this;
                    typedResponse.isFromCache = response.fromCache || false;
                    typedResponse.ip = this.ip;
                    typedResponse.retryCount = this.retryCount;
                    this[kIsFromCache] = typedResponse.isFromCache;
                    this[kResponseSize] =
                        Number(response.headers["content-length"]) || undefined;
                    this[kResponse] = response;
                    response.once("end", () => {
                        this[kResponseSize] = this[kDownloadedSize];
                        this.emit("downloadProgress", this.downloadProgress);
                    });
                    response.once("error", (error) => {
                        // Force clean-up, because some packages don't do this.
                        // TODO: Fix decompress-response
                        response.destroy();
                        this._beforeError(new ReadError(error, this));
                    });
                    response.once("aborted", () => {
                        this._beforeError(
                            new ReadError(
                                {
                                    name: "Error",
                                    message:
                                        "The server aborted pending request",
                                    code: "ECONNRESET",
                                },
                                this
                            )
                        );
                    });
                    this.emit("downloadProgress", this.downloadProgress);
                    const rawCookies = response.headers["set-cookie"];
                    if (is_1.default.object(options.cookieJar) && rawCookies) {
                        let promises = rawCookies.map(async (rawCookie) =>
                            options.cookieJar.setCookie(
                                rawCookie,
                                url.toString()
                            )
                        );
                        if (options.ignoreInvalidCookies) {
                            promises = promises.map(async (p) =>
                                p.catch(() => {})
                            );
                        }
                        try {
                            await Promise.all(promises);
                        } catch (error) {
                            this._beforeError(error);
                            return;
                        }
                    }
                    if (
                        options.followRedirect &&
                        response.headers.location &&
                        redirectCodes.has(statusCode)
                    ) {
                        // We're being redirected, we don't care about the response.
                        // It'd be best to abort the request, but we can't because
                        // we would have to sacrifice the TCP connection. We don't want that.
                        response.resume();
                        if (this[kRequest]) {
                            this[kCancelTimeouts]();
                            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                            delete this[kRequest];
                            this[kUnproxyEvents]();
                        }
                        const shouldBeGet =
                            statusCode === 303 &&
                            options.method !== "GET" &&
                            options.method !== "HEAD";
                        if (shouldBeGet || !options.methodRewriting) {
                            // Server responded with "see other", indicating that the resource exists at another location,
                            // and the client should request it from that location via GET or HEAD.
                            options.method = "GET";
                            if ("body" in options) {
                                delete options.body;
                            }
                            if ("json" in options) {
                                delete options.json;
                            }
                            if ("form" in options) {
                                delete options.form;
                            }
                            this[kBody] = undefined;
                            delete options.headers["content-length"];
                        }
                        if (this.redirects.length >= options.maxRedirects) {
                            this._beforeError(new MaxRedirectsError(this));
                            return;
                        }
                        try {
                            // Do not remove. See https://github.com/sindresorhus/got/pull/214
                            const redirectBuffer = Buffer.from(
                                response.headers.location,
                                "binary"
                            ).toString();
                            // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604
                            const redirectUrl = new url_1.URL(
                                redirectBuffer,
                                url
                            );
                            const redirectString = redirectUrl.toString();
                            decodeURI(redirectString);
                            // Redirecting to a different site, clear sensitive data.
                            if (
                                redirectUrl.hostname !== url.hostname ||
                                redirectUrl.port !== url.port
                            ) {
                                if ("host" in options.headers) {
                                    delete options.headers.host;
                                }
                                if ("cookie" in options.headers) {
                                    delete options.headers.cookie;
                                }
                                if ("authorization" in options.headers) {
                                    delete options.headers.authorization;
                                }
                                if (options.username || options.password) {
                                    options.username = "";
                                    options.password = "";
                                }
                            } else {
                                redirectUrl.username = options.username;
                                redirectUrl.password = options.password;
                            }
                            this.redirects.push(redirectString);
                            options.url = redirectUrl;
                            for (const hook of options.hooks.beforeRedirect) {
                                // eslint-disable-next-line no-await-in-loop
                                await hook(options, typedResponse);
                            }
                            this.emit("redirect", typedResponse, options);
                            await this._makeRequest();
                        } catch (error) {
                            this._beforeError(error);
                            return;
                        }
                        return;
                    }
                    if (
                        options.isStream &&
                        options.throwHttpErrors &&
                        !is_response_ok_1.isResponseOk(typedResponse)
                    ) {
                        this._beforeError(new HTTPError(typedResponse));
                        return;
                    }
                    response.on("readable", () => {
                        if (this[kTriggerRead]) {
                            this._read();
                        }
                    });
                    this.on("resume", () => {
                        response.resume();
                    });
                    this.on("pause", () => {
                        response.pause();
                    });
                    response.once("end", () => {
                        this.push(null);
                    });
                    this.emit("response", response);
                    for (const destination of this[kServerResponsesPiped]) {
                        if (destination.headersSent) {
                            continue;
                        }
                        // eslint-disable-next-line guard-for-in
                        for (const key in response.headers) {
                            const isAllowed = options.decompress
                                ? key !== "content-encoding"
                                : true;
                            const value = response.headers[key];
                            if (isAllowed) {
                                destination.setHeader(key, value);
                            }
                        }
                        destination.statusCode = statusCode;
                    }
                }
                async _onResponse(response) {
                    try {
                        await this._onResponseBase(response);
                    } catch (error) {
                        /* istanbul ignore next: better safe than sorry */
                        this._beforeError(error);
                    }
                }
                _onRequest(request) {
                    const { options } = this;
                    const { timeout, url } = options;
                    http_timer_1.default(request);
                    this[kCancelTimeouts] = timed_out_1.default(
                        request,
                        timeout,
                        url
                    );
                    const responseEventName = options.cache
                        ? "cacheableResponse"
                        : "response";
                    request.once(responseEventName, (response) => {
                        void this._onResponse(response);
                    });
                    request.once("error", (error) => {
                        var _a;
                        // Force clean-up, because some packages (e.g. nock) don't do this.
                        request.destroy();
                        // Node.js <= 12.18.2 mistakenly emits the response `end` first.
                        (_a = request.res) === null || _a === void 0
                            ? void 0
                            : _a.removeAllListeners("end");
                        error =
                            error instanceof timed_out_1.TimeoutError
                                ? new TimeoutError(error, this.timings, this)
                                : new RequestError(error.message, error, this);
                        this._beforeError(error);
                    });
                    this[kUnproxyEvents] = proxy_events_1.default(
                        request,
                        this,
                        proxiedRequestEvents
                    );
                    this[kRequest] = request;
                    this.emit("uploadProgress", this.uploadProgress);
                    // Send body
                    const body = this[kBody];
                    const currentRequest =
                        this.redirects.length === 0 ? this : request;
                    if (is_1.default.nodeStream(body)) {
                        body.pipe(currentRequest);
                        body.once("error", (error) => {
                            this._beforeError(new UploadError(error, this));
                        });
                    } else {
                        this._unlockWrite();
                        if (!is_1.default.undefined(body)) {
                            this._writeRequest(body, undefined, () => {});
                            currentRequest.end();
                            this._lockWrite();
                        } else if (this._cannotHaveBody || this._noPipe) {
                            currentRequest.end();
                            this._lockWrite();
                        }
                    }
                    this.emit("request", request);
                }
                async _createCacheableRequest(url, options) {
                    return new Promise((resolve, reject) => {
                        // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed
                        Object.assign(options, url_to_options_1.default(url));
                        // `http-cache-semantics` checks this
                        // TODO: Fix this ignore.
                        // @ts-expect-error
                        delete options.url;
                        let request;
                        // This is ugly
                        const cacheRequest = cacheableStore.get(options.cache)(
                            options,
                            async (response) => {
                                // TODO: Fix `cacheable-response`
                                response._readableState.autoDestroy = false;
                                if (request) {
                                    (await request).emit(
                                        "cacheableResponse",
                                        response
                                    );
                                }
                                resolve(response);
                            }
                        );
                        // Restore options
                        options.url = url;
                        cacheRequest.once("error", reject);
                        cacheRequest.once(
                            "request",
                            async (requestOrPromise) => {
                                request = requestOrPromise;
                                resolve(request);
                            }
                        );
                    });
                }
                async _makeRequest() {
                    var _a, _b, _c, _d, _e;
                    const { options } = this;
                    const { headers } = options;
                    for (const key in headers) {
                        if (is_1.default.undefined(headers[key])) {
                            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                            delete headers[key];
                        } else if (is_1.default.null_(headers[key])) {
                            throw new TypeError(
                                `Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`
                            );
                        }
                    }
                    if (
                        options.decompress &&
                        is_1.default.undefined(headers["accept-encoding"])
                    ) {
                        headers["accept-encoding"] = supportsBrotli
                            ? "gzip, deflate, br"
                            : "gzip, deflate";
                    }
                    // Set cookies
                    if (options.cookieJar) {
                        const cookieString =
                            await options.cookieJar.getCookieString(
                                options.url.toString()
                            );
                        if (is_1.default.nonEmptyString(cookieString)) {
                            options.headers.cookie = cookieString;
                        }
                    }
                    for (const hook of options.hooks.beforeRequest) {
                        // eslint-disable-next-line no-await-in-loop
                        const result = await hook(options);
                        if (!is_1.default.undefined(result)) {
                            // @ts-expect-error Skip the type mismatch to support abstract responses
                            options.request = () => result;
                            break;
                        }
                    }
                    if (options.body && this[kBody] !== options.body) {
                        this[kBody] = options.body;
                    }
                    const { agent, request, timeout, url } = options;
                    if (options.dnsCache && !("lookup" in options)) {
                        options.lookup = options.dnsCache.lookup;
                    }
                    // UNIX sockets
                    if (url.hostname === "unix") {
                        const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(
                            `${url.pathname}${url.search}`
                        );
                        if (
                            matches === null || matches === void 0
                                ? void 0
                                : matches.groups
                        ) {
                            const { socketPath, path } = matches.groups;
                            Object.assign(options, {
                                socketPath,
                                path,
                                host: "",
                            });
                        }
                    }
                    const isHttps = url.protocol === "https:";
                    // Fallback function
                    let fallbackFn;
                    if (options.http2) {
                        fallbackFn = http2wrapper.auto;
                    } else {
                        fallbackFn = isHttps ? https.request : http.request;
                    }
                    const realFn =
                        (_a = options.request) !== null && _a !== void 0
                            ? _a
                            : fallbackFn;
                    // Cache support
                    const fn = options.cache
                        ? this._createCacheableRequest
                        : realFn;
                    // Pass an agent directly when HTTP2 is disabled
                    if (agent && !options.http2) {
                        options.agent = agent[isHttps ? "https" : "http"];
                    }
                    // Prepare plain HTTP request options
                    options[kRequest] = realFn;
                    delete options.request;
                    // TODO: Fix this ignore.
                    // @ts-expect-error
                    delete options.timeout;
                    const requestOptions = options;
                    requestOptions.shared =
                        (_b = options.cacheOptions) === null || _b === void 0
                            ? void 0
                            : _b.shared;
                    requestOptions.cacheHeuristic =
                        (_c = options.cacheOptions) === null || _c === void 0
                            ? void 0
                            : _c.cacheHeuristic;
                    requestOptions.immutableMinTimeToLive =
                        (_d = options.cacheOptions) === null || _d === void 0
                            ? void 0
                            : _d.immutableMinTimeToLive;
                    requestOptions.ignoreCargoCult =
                        (_e = options.cacheOptions) === null || _e === void 0
                            ? void 0
                            : _e.ignoreCargoCult;
                    // If `dnsLookupIpVersion` is not present do not override `family`
                    if (options.dnsLookupIpVersion !== undefined) {
                        try {
                            requestOptions.family =
                                dns_ip_version_1.dnsLookupIpVersionToFamily(
                                    options.dnsLookupIpVersion
                                );
                        } catch (_f) {
                            throw new Error(
                                "Invalid `dnsLookupIpVersion` option value"
                            );
                        }
                    }
                    // HTTPS options remapping
                    if (options.https) {
                        if ("rejectUnauthorized" in options.https) {
                            requestOptions.rejectUnauthorized =
                                options.https.rejectUnauthorized;
                        }
                        if (options.https.checkServerIdentity) {
                            requestOptions.checkServerIdentity =
                                options.https.checkServerIdentity;
                        }
                        if (options.https.certificateAuthority) {
                            requestOptions.ca =
                                options.https.certificateAuthority;
                        }
                        if (options.https.certificate) {
                            requestOptions.cert = options.https.certificate;
                        }
                        if (options.https.key) {
                            requestOptions.key = options.https.key;
                        }
                        if (options.https.passphrase) {
                            requestOptions.passphrase =
                                options.https.passphrase;
                        }
                        if (options.https.pfx) {
                            requestOptions.pfx = options.https.pfx;
                        }
                    }
                    try {
                        let requestOrResponse = await fn(url, requestOptions);
                        if (is_1.default.undefined(requestOrResponse)) {
                            requestOrResponse = fallbackFn(url, requestOptions);
                        }
                        // Restore options
                        options.request = request;
                        options.timeout = timeout;
                        options.agent = agent;
                        // HTTPS options restore
                        if (options.https) {
                            if ("rejectUnauthorized" in options.https) {
                                delete requestOptions.rejectUnauthorized;
                            }
                            if (options.https.checkServerIdentity) {
                                // @ts-expect-error - This one will be removed when we remove the alias.
                                delete requestOptions.checkServerIdentity;
                            }
                            if (options.https.certificateAuthority) {
                                delete requestOptions.ca;
                            }
                            if (options.https.certificate) {
                                delete requestOptions.cert;
                            }
                            if (options.https.key) {
                                delete requestOptions.key;
                            }
                            if (options.https.passphrase) {
                                delete requestOptions.passphrase;
                            }
                            if (options.https.pfx) {
                                delete requestOptions.pfx;
                            }
                        }
                        if (isClientRequest(requestOrResponse)) {
                            this._onRequest(requestOrResponse);
                            // Emit the response after the stream has been ended
                        } else if (this.writable) {
                            this.once("finish", () => {
                                void this._onResponse(requestOrResponse);
                            });
                            this._unlockWrite();
                            this.end();
                            this._lockWrite();
                        } else {
                            void this._onResponse(requestOrResponse);
                        }
                    } catch (error) {
                        if (error instanceof CacheableRequest.CacheError) {
                            throw new CacheError(error, this);
                        }
                        throw new RequestError(error.message, error, this);
                    }
                }
                async _error(error) {
                    try {
                        for (const hook of this.options.hooks.beforeError) {
                            // eslint-disable-next-line no-await-in-loop
                            error = await hook(error);
                        }
                    } catch (error_) {
                        error = new RequestError(error_.message, error_, this);
                    }
                    this.destroy(error);
                }
                _beforeError(error) {
                    if (this[kStopReading]) {
                        return;
                    }
                    const { options } = this;
                    const retryCount = this.retryCount + 1;
                    this[kStopReading] = true;
                    if (!(error instanceof RequestError)) {
                        error = new RequestError(error.message, error, this);
                    }
                    const typedError = error;
                    const { response } = typedError;
                    void (async () => {
                        if (response && !response.body) {
                            response.setEncoding(this._readableState.encoding);
                            try {
                                response.rawBody = await get_buffer_1.default(
                                    response
                                );
                                response.body = response.rawBody.toString();
                            } catch (_a) {}
                        }
                        if (this.listenerCount("retry") !== 0) {
                            let backoff;
                            try {
                                let retryAfter;
                                if (
                                    response &&
                                    "retry-after" in response.headers
                                ) {
                                    retryAfter = Number(
                                        response.headers["retry-after"]
                                    );
                                    if (Number.isNaN(retryAfter)) {
                                        retryAfter =
                                            Date.parse(
                                                response.headers["retry-after"]
                                            ) - Date.now();
                                        if (retryAfter <= 0) {
                                            retryAfter = 1;
                                        }
                                    } else {
                                        retryAfter *= 1000;
                                    }
                                }
                                backoff = await options.retry.calculateDelay({
                                    attemptCount: retryCount,
                                    retryOptions: options.retry,
                                    error: typedError,
                                    retryAfter,
                                    computedValue:
                                        calculate_retry_delay_1.default({
                                            attemptCount: retryCount,
                                            retryOptions: options.retry,
                                            error: typedError,
                                            retryAfter,
                                            computedValue: 0,
                                        }),
                                });
                            } catch (error_) {
                                void this._error(
                                    new RequestError(
                                        error_.message,
                                        error_,
                                        this
                                    )
                                );
                                return;
                            }
                            if (backoff) {
                                const retry = async () => {
                                    try {
                                        for (const hook of this.options.hooks
                                            .beforeRetry) {
                                            // eslint-disable-next-line no-await-in-loop
                                            await hook(
                                                this.options,
                                                typedError,
                                                retryCount
                                            );
                                        }
                                    } catch (error_) {
                                        void this._error(
                                            new RequestError(
                                                error_.message,
                                                error,
                                                this
                                            )
                                        );
                                        return;
                                    }
                                    // Something forced us to abort the retry
                                    if (this.destroyed) {
                                        return;
                                    }
                                    this.destroy();
                                    this.emit("retry", retryCount, error);
                                };
                                this[kRetryTimeout] = setTimeout(
                                    retry,
                                    backoff
                                );
                                return;
                            }
                        }
                        void this._error(typedError);
                    })();
                }
                _read() {
                    this[kTriggerRead] = true;
                    const response = this[kResponse];
                    if (response && !this[kStopReading]) {
                        // We cannot put this in the `if` above
                        // because `.read()` also triggers the `end` event
                        if (response.readableLength) {
                            this[kTriggerRead] = false;
                        }
                        let data;
                        while ((data = response.read()) !== null) {
                            this[kDownloadedSize] += data.length;
                            this[kStartedReading] = true;
                            const progress = this.downloadProgress;
                            if (progress.percent < 1) {
                                this.emit("downloadProgress", progress);
                            }
                            this.push(data);
                        }
                    }
                }
                // Node.js 12 has incorrect types, so the encoding must be a string
                _write(chunk, encoding, callback) {
                    const write = () => {
                        this._writeRequest(chunk, encoding, callback);
                    };
                    if (this.requestInitialized) {
                        write();
                    } else {
                        this[kJobs].push(write);
                    }
                }
                _writeRequest(chunk, encoding, callback) {
                    if (this[kRequest].destroyed) {
                        // Probably the `ClientRequest` instance will throw
                        return;
                    }
                    this._progressCallbacks.push(() => {
                        this[kUploadedSize] += Buffer.byteLength(
                            chunk,
                            encoding
                        );
                        const progress = this.uploadProgress;
                        if (progress.percent < 1) {
                            this.emit("uploadProgress", progress);
                        }
                    });
                    // TODO: What happens if it's from cache? Then this[kRequest] won't be defined.
                    this[kRequest].write(chunk, encoding, (error) => {
                        if (!error && this._progressCallbacks.length > 0) {
                            this._progressCallbacks.shift()();
                        }
                        callback(error);
                    });
                }
                _final(callback) {
                    const endRequest = () => {
                        // FIX: Node.js 10 calls the write callback AFTER the end callback!
                        while (this._progressCallbacks.length !== 0) {
                            this._progressCallbacks.shift()();
                        }
                        // We need to check if `this[kRequest]` is present,
                        // because it isn't when we use cache.
                        if (!(kRequest in this)) {
                            callback();
                            return;
                        }
                        if (this[kRequest].destroyed) {
                            callback();
                            return;
                        }
                        this[kRequest].end((error) => {
                            if (!error) {
                                this[kBodySize] = this[kUploadedSize];
                                this.emit(
                                    "uploadProgress",
                                    this.uploadProgress
                                );
                                this[kRequest].emit("upload-complete");
                            }
                            callback(error);
                        });
                    };
                    if (this.requestInitialized) {
                        endRequest();
                    } else {
                        this[kJobs].push(endRequest);
                    }
                }
                _destroy(error, callback) {
                    var _a;
                    this[kStopReading] = true;
                    // Prevent further retries
                    clearTimeout(this[kRetryTimeout]);
                    if (kRequest in this) {
                        this[kCancelTimeouts]();
                        // TODO: Remove the next `if` when these get fixed:
                        // - https://github.com/nodejs/node/issues/32851
                        if (
                            !((_a = this[kResponse]) === null || _a === void 0
                                ? void 0
                                : _a.complete)
                        ) {
                            this[kRequest].destroy();
                        }
                    }
                    if (
                        error !== null &&
                        !is_1.default.undefined(error) &&
                        !(error instanceof RequestError)
                    ) {
                        error = new RequestError(error.message, error, this);
                    }
                    callback(error);
                }
                get _isAboutToError() {
                    return this[kStopReading];
                }
                /**
    The remote IP address.
    */
                get ip() {
                    var _a;
                    return (_a = this.socket) === null || _a === void 0
                        ? void 0
                        : _a.remoteAddress;
                }
                /**
    Indicates whether the request has been aborted or not.
    */
                get aborted() {
                    var _a, _b, _c;
                    return (
                        ((_b =
                            (_a = this[kRequest]) === null || _a === void 0
                                ? void 0
                                : _a.destroyed) !== null && _b !== void 0
                            ? _b
                            : this.destroyed) &&
                        !((_c = this[kOriginalResponse]) === null ||
                        _c === void 0
                            ? void 0
                            : _c.complete)
                    );
                }
                get socket() {
                    var _a, _b;
                    return (_b =
                        (_a = this[kRequest]) === null || _a === void 0
                            ? void 0
                            : _a.socket) !== null && _b !== void 0
                        ? _b
                        : undefined;
                }
                /**
    Progress event for downloading (receiving a response).
    */
                get downloadProgress() {
                    let percent;
                    if (this[kResponseSize]) {
                        percent = this[kDownloadedSize] / this[kResponseSize];
                    } else if (this[kResponseSize] === this[kDownloadedSize]) {
                        percent = 1;
                    } else {
                        percent = 0;
                    }
                    return {
                        percent,
                        transferred: this[kDownloadedSize],
                        total: this[kResponseSize],
                    };
                }
                /**
    Progress event for uploading (sending a request).
    */
                get uploadProgress() {
                    let percent;
                    if (this[kBodySize]) {
                        percent = this[kUploadedSize] / this[kBodySize];
                    } else if (this[kBodySize] === this[kUploadedSize]) {
                        percent = 1;
                    } else {
                        percent = 0;
                    }
                    return {
                        percent,
                        transferred: this[kUploadedSize],
                        total: this[kBodySize],
                    };
                }
                /**
    The object contains the following properties:

    - `start` - Time when the request started.
    - `socket` - Time when a socket was assigned to the request.
    - `lookup` - Time when the DNS lookup finished.
    - `connect` - Time when the socket successfully connected.
    - `secureConnect` - Time when the socket securely connected.
    - `upload` - Time when the request finished uploading.
    - `response` - Time when the request fired `response` event.
    - `end` - Time when the response fired `end` event.
    - `error` - Time when the request fired `error` event.
    - `abort` - Time when the request fired `abort` event.
    - `phases`
        - `wait` - `timings.socket - timings.start`
        - `dns` - `timings.lookup - timings.socket`
        - `tcp` - `timings.connect - timings.lookup`
        - `tls` - `timings.secureConnect - timings.connect`
        - `request` - `timings.upload - (timings.secureConnect || timings.connect)`
        - `firstByte` - `timings.response - timings.upload`
        - `download` - `timings.end - timings.response`
        - `total` - `(timings.end || timings.error || timings.abort) - timings.start`

    If something has not been measured yet, it will be `undefined`.

    __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.
    */
                get timings() {
                    var _a;
                    return (_a = this[kRequest]) === null || _a === void 0
                        ? void 0
                        : _a.timings;
                }
                /**
    Whether the response was retrieved from the cache.
    */
                get isFromCache() {
                    return this[kIsFromCache];
                }
                pipe(destination, options) {
                    if (this[kStartedReading]) {
                        throw new Error(
                            "Failed to pipe. The response has been emitted already."
                        );
                    }
                    if (destination instanceof http_1.ServerResponse) {
                        this[kServerResponsesPiped].add(destination);
                    }
                    return super.pipe(destination, options);
                }
                unpipe(destination) {
                    if (destination instanceof http_1.ServerResponse) {
                        this[kServerResponsesPiped].delete(destination);
                    }
                    super.unpipe(destination);
                    return this;
                }
            }
            exports.default = Request;

            /***/
        },

        /***/ 4993: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            exports.dnsLookupIpVersionToFamily = exports.isDnsLookupIpVersion =
                void 0;
            const conversionTable = {
                auto: 0,
                ipv4: 4,
                ipv6: 6,
            };
            exports.isDnsLookupIpVersion = (value) => {
                return value in conversionTable;
            };
            exports.dnsLookupIpVersionToFamily = (dnsLookupIpVersion) => {
                if (exports.isDnsLookupIpVersion(dnsLookupIpVersion)) {
                    return conversionTable[dnsLookupIpVersion];
                }
                throw new Error("Invalid DNS lookup IP version");
            };

            /***/
        },

        /***/ 4564: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            const fs_1 = __nccwpck_require__(5747);
            const util_1 = __nccwpck_require__(1669);
            const is_1 = __nccwpck_require__(7678);
            const is_form_data_1 = __nccwpck_require__(40);
            const statAsync = util_1.promisify(fs_1.stat);
            exports.default = async (body, headers) => {
                if (headers && "content-length" in headers) {
                    return Number(headers["content-length"]);
                }
                if (!body) {
                    return 0;
                }
                if (is_1.default.string(body)) {
                    return Buffer.byteLength(body);
                }
                if (is_1.default.buffer(body)) {
                    return body.length;
                }
                if (is_form_data_1.default(body)) {
                    return util_1.promisify(body.getLength.bind(body))();
                }
                if (body instanceof fs_1.ReadStream) {
                    const { size } = await statAsync(body.path);
                    if (size === 0) {
                        return undefined;
                    }
                    return size;
                }
                return undefined;
            };

            /***/
        },

        /***/ 4500: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            // TODO: Update https://github.com/sindresorhus/get-stream
            const getBuffer = async (stream) => {
                const chunks = [];
                let length = 0;
                for await (const chunk of stream) {
                    chunks.push(chunk);
                    length += Buffer.byteLength(chunk);
                }
                if (Buffer.isBuffer(chunks[0])) {
                    return Buffer.concat(chunks, length);
                }
                return Buffer.from(chunks.join(""));
            };
            exports.default = getBuffer;

            /***/
        },

        /***/ 40: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            const is_1 = __nccwpck_require__(7678);
            exports.default = (body) =>
                is_1.default.nodeStream(body) &&
                is_1.default.function_(body.getBoundary);

            /***/
        },

        /***/ 9298: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            exports.isResponseOk = void 0;
            exports.isResponseOk = (response) => {
                const { statusCode } = response;
                const limitStatusCode = response.request.options.followRedirect
                    ? 299
                    : 399;
                return (
                    (statusCode >= 200 && statusCode <= limitStatusCode) ||
                    statusCode === 304
                );
            };

            /***/
        },

        /***/ 9219: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            /* istanbul ignore file: deprecated */
            const url_1 = __nccwpck_require__(8835);
            const keys = [
                "protocol",
                "host",
                "hostname",
                "port",
                "pathname",
                "search",
            ];
            exports.default = (origin, options) => {
                var _a, _b;
                if (options.path) {
                    if (options.pathname) {
                        throw new TypeError(
                            "Parameters `path` and `pathname` are mutually exclusive."
                        );
                    }
                    if (options.search) {
                        throw new TypeError(
                            "Parameters `path` and `search` are mutually exclusive."
                        );
                    }
                    if (options.searchParams) {
                        throw new TypeError(
                            "Parameters `path` and `searchParams` are mutually exclusive."
                        );
                    }
                }
                if (options.search && options.searchParams) {
                    throw new TypeError(
                        "Parameters `search` and `searchParams` are mutually exclusive."
                    );
                }
                if (!origin) {
                    if (!options.protocol) {
                        throw new TypeError("No URL protocol specified");
                    }
                    origin = `${options.protocol}//${
                        (_b =
                            (_a = options.hostname) !== null && _a !== void 0
                                ? _a
                                : options.host) !== null && _b !== void 0
                            ? _b
                            : ""
                    }`;
                }
                const url = new url_1.URL(origin);
                if (options.path) {
                    const searchIndex = options.path.indexOf("?");
                    if (searchIndex === -1) {
                        options.pathname = options.path;
                    } else {
                        options.pathname = options.path.slice(0, searchIndex);
                        options.search = options.path.slice(searchIndex + 1);
                    }
                    delete options.path;
                }
                for (const key of keys) {
                    if (options[key]) {
                        url[key] = options[key].toString();
                    }
                }
                return url;
            };

            /***/
        },

        /***/ 3021: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            function default_1(from, to, events) {
                const fns = {};
                for (const event of events) {
                    fns[event] = (...args) => {
                        to.emit(event, ...args);
                    };
                    from.on(event, fns[event]);
                }
                return () => {
                    for (const event of events) {
                        from.off(event, fns[event]);
                    }
                };
            }
            exports.default = default_1;

            /***/
        },

        /***/ 2454: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            exports.TimeoutError = void 0;
            const net = __nccwpck_require__(1631);
            const unhandle_1 = __nccwpck_require__(1593);
            const reentry = Symbol("reentry");
            const noop = () => {};
            class TimeoutError extends Error {
                constructor(threshold, event) {
                    super(`Timeout awaiting '${event}' for ${threshold}ms`);
                    this.event = event;
                    this.name = "TimeoutError";
                    this.code = "ETIMEDOUT";
                }
            }
            exports.TimeoutError = TimeoutError;
            exports.default = (request, delays, options) => {
                if (reentry in request) {
                    return noop;
                }
                request[reentry] = true;
                const cancelers = [];
                const { once, unhandleAll } = unhandle_1.default();
                const addTimeout = (delay, callback, event) => {
                    var _a;
                    const timeout = setTimeout(callback, delay, delay, event);
                    (_a = timeout.unref) === null || _a === void 0
                        ? void 0
                        : _a.call(timeout);
                    const cancel = () => {
                        clearTimeout(timeout);
                    };
                    cancelers.push(cancel);
                    return cancel;
                };
                const { host, hostname } = options;
                const timeoutHandler = (delay, event) => {
                    request.destroy(new TimeoutError(delay, event));
                };
                const cancelTimeouts = () => {
                    for (const cancel of cancelers) {
                        cancel();
                    }
                    unhandleAll();
                };
                request.once("error", (error) => {
                    cancelTimeouts();
                    // Save original behavior
                    /* istanbul ignore next */
                    if (request.listenerCount("error") === 0) {
                        throw error;
                    }
                });
                request.once("close", cancelTimeouts);
                once(request, "response", (response) => {
                    once(response, "end", cancelTimeouts);
                });
                if (typeof delays.request !== "undefined") {
                    addTimeout(delays.request, timeoutHandler, "request");
                }
                if (typeof delays.socket !== "undefined") {
                    const socketTimeoutHandler = () => {
                        timeoutHandler(delays.socket, "socket");
                    };
                    request.setTimeout(delays.socket, socketTimeoutHandler);
                    // `request.setTimeout(0)` causes a memory leak.
                    // We can just remove the listener and forget about the timer - it's unreffed.
                    // See https://github.com/sindresorhus/got/issues/690
                    cancelers.push(() => {
                        request.removeListener("timeout", socketTimeoutHandler);
                    });
                }
                once(request, "socket", (socket) => {
                    var _a;
                    const { socketPath } = request;
                    /* istanbul ignore next: hard to test */
                    if (socket.connecting) {
                        const hasPath = Boolean(
                            socketPath !== null && socketPath !== void 0
                                ? socketPath
                                : net.isIP(
                                      (_a =
                                          hostname !== null &&
                                          hostname !== void 0
                                              ? hostname
                                              : host) !== null && _a !== void 0
                                          ? _a
                                          : ""
                                  ) !== 0
                        );
                        if (
                            typeof delays.lookup !== "undefined" &&
                            !hasPath &&
                            typeof socket.address().address === "undefined"
                        ) {
                            const cancelTimeout = addTimeout(
                                delays.lookup,
                                timeoutHandler,
                                "lookup"
                            );
                            once(socket, "lookup", cancelTimeout);
                        }
                        if (typeof delays.connect !== "undefined") {
                            const timeConnect = () =>
                                addTimeout(
                                    delays.connect,
                                    timeoutHandler,
                                    "connect"
                                );
                            if (hasPath) {
                                once(socket, "connect", timeConnect());
                            } else {
                                once(socket, "lookup", (error) => {
                                    if (error === null) {
                                        once(socket, "connect", timeConnect());
                                    }
                                });
                            }
                        }
                        if (
                            typeof delays.secureConnect !== "undefined" &&
                            options.protocol === "https:"
                        ) {
                            once(socket, "connect", () => {
                                const cancelTimeout = addTimeout(
                                    delays.secureConnect,
                                    timeoutHandler,
                                    "secureConnect"
                                );
                                once(socket, "secureConnect", cancelTimeout);
                            });
                        }
                    }
                    if (typeof delays.send !== "undefined") {
                        const timeRequest = () =>
                            addTimeout(delays.send, timeoutHandler, "send");
                        /* istanbul ignore next: hard to test */
                        if (socket.connecting) {
                            once(socket, "connect", () => {
                                once(request, "upload-complete", timeRequest());
                            });
                        } else {
                            once(request, "upload-complete", timeRequest());
                        }
                    }
                });
                if (typeof delays.response !== "undefined") {
                    once(request, "upload-complete", () => {
                        const cancelTimeout = addTimeout(
                            delays.response,
                            timeoutHandler,
                            "response"
                        );
                        once(request, "response", cancelTimeout);
                    });
                }
                return cancelTimeouts;
            };

            /***/
        },

        /***/ 1593: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            // When attaching listeners, it's very easy to forget about them.
            // Especially if you do error handling and set timeouts.
            // So instead of checking if it's proper to throw an error on every timeout ever,
            // use this simple tool which will remove all listeners you have attached.
            exports.default = () => {
                const handlers = [];
                return {
                    once(origin, event, fn) {
                        origin.once(event, fn);
                        handlers.push({ origin, event, fn });
                    },
                    unhandleAll() {
                        for (const handler of handlers) {
                            const { origin, event, fn } = handler;
                            origin.removeListener(event, fn);
                        }
                        handlers.length = 0;
                    },
                };
            };

            /***/
        },

        /***/ 8026: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            const is_1 = __nccwpck_require__(7678);
            exports.default = (url) => {
                // Cast to URL
                url = url;
                const options = {
                    protocol: url.protocol,
                    hostname:
                        is_1.default.string(url.hostname) &&
                        url.hostname.startsWith("[")
                            ? url.hostname.slice(1, -1)
                            : url.hostname,
                    host: url.host,
                    hash: url.hash,
                    search: url.search,
                    pathname: url.pathname,
                    href: url.href,
                    path: `${url.pathname || ""}${url.search || ""}`,
                };
                if (is_1.default.string(url.port) && url.port.length > 0) {
                    options.port = Number(url.port);
                }
                if (url.username || url.password) {
                    options.auth = `${url.username || ""}:${
                        url.password || ""
                    }`;
                }
                return options;
            };

            /***/
        },

        /***/ 7288: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            class WeakableMap {
                constructor() {
                    this.weakMap = new WeakMap();
                    this.map = new Map();
                }
                set(key, value) {
                    if (typeof key === "object") {
                        this.weakMap.set(key, value);
                    } else {
                        this.map.set(key, value);
                    }
                }
                get(key) {
                    if (typeof key === "object") {
                        return this.weakMap.get(key);
                    }
                    return this.map.get(key);
                }
                has(key) {
                    if (typeof key === "object") {
                        return this.weakMap.has(key);
                    }
                    return this.map.has(key);
                }
            }
            exports.default = WeakableMap;

            /***/
        },

        /***/ 4337: /***/ function (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) {
            "use strict";

            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          Object.defineProperty(o, k2, {
                              enumerable: true,
                              get: function () {
                                  return m[k];
                              },
                          });
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __exportStar =
                (this && this.__exportStar) ||
                function (m, exports) {
                    for (var p in m)
                        if (
                            p !== "default" &&
                            !Object.prototype.hasOwnProperty.call(exports, p)
                        )
                            __createBinding(exports, m, p);
                };
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.defaultHandler = void 0;
            const is_1 = __nccwpck_require__(7678);
            const as_promise_1 = __nccwpck_require__(6056);
            const create_rejection_1 = __nccwpck_require__(6457);
            const core_1 = __nccwpck_require__(94);
            const deep_freeze_1 = __nccwpck_require__(285);
            const errors = {
                RequestError: as_promise_1.RequestError,
                CacheError: as_promise_1.CacheError,
                ReadError: as_promise_1.ReadError,
                HTTPError: as_promise_1.HTTPError,
                MaxRedirectsError: as_promise_1.MaxRedirectsError,
                TimeoutError: as_promise_1.TimeoutError,
                ParseError: as_promise_1.ParseError,
                CancelError: as_promise_1.CancelError,
                UnsupportedProtocolError: as_promise_1.UnsupportedProtocolError,
                UploadError: as_promise_1.UploadError,
            };
            // The `delay` package weighs 10KB (!)
            const delay = async (ms) =>
                new Promise((resolve) => {
                    setTimeout(resolve, ms);
                });
            const { normalizeArguments } = core_1.default;
            const mergeOptions = (...sources) => {
                let mergedOptions;
                for (const source of sources) {
                    mergedOptions = normalizeArguments(
                        undefined,
                        source,
                        mergedOptions
                    );
                }
                return mergedOptions;
            };
            const getPromiseOrStream = (options) =>
                options.isStream
                    ? new core_1.default(undefined, options)
                    : as_promise_1.default(options);
            const isGotInstance = (value) =>
                "defaults" in value && "options" in value.defaults;
            const aliases = ["get", "post", "put", "patch", "head", "delete"];
            exports.defaultHandler = (options, next) => next(options);
            const callInitHooks = (hooks, options) => {
                if (hooks) {
                    for (const hook of hooks) {
                        hook(options);
                    }
                }
            };
            const create = (defaults) => {
                // Proxy properties from next handlers
                defaults._rawHandlers = defaults.handlers;
                defaults.handlers = defaults.handlers.map(
                    (fn) => (options, next) => {
                        // This will be assigned by assigning result
                        let root;
                        const result = fn(options, (newOptions) => {
                            root = next(newOptions);
                            return root;
                        });
                        if (result !== root && !options.isStream && root) {
                            const typedResult = result;
                            const {
                                then: promiseThen,
                                catch: promiseCatch,
                                finally: promiseFianlly,
                            } = typedResult;
                            Object.setPrototypeOf(
                                typedResult,
                                Object.getPrototypeOf(root)
                            );
                            Object.defineProperties(
                                typedResult,
                                Object.getOwnPropertyDescriptors(root)
                            );
                            // These should point to the new promise
                            // eslint-disable-next-line promise/prefer-await-to-then
                            typedResult.then = promiseThen;
                            typedResult.catch = promiseCatch;
                            typedResult.finally = promiseFianlly;
                        }
                        return result;
                    }
                );
                // Got interface
                const got = (url, options = {}, _defaults) => {
                    var _a, _b;
                    let iteration = 0;
                    const iterateHandlers = (newOptions) => {
                        return defaults.handlers[iteration++](
                            newOptions,
                            iteration === defaults.handlers.length
                                ? getPromiseOrStream
                                : iterateHandlers
                        );
                    };
                    // TODO: Remove this in Got 12.
                    if (is_1.default.plainObject(url)) {
                        const mergedOptions = {
                            ...url,
                            ...options,
                        };
                        core_1.setNonEnumerableProperties(
                            [url, options],
                            mergedOptions
                        );
                        options = mergedOptions;
                        url = undefined;
                    }
                    try {
                        // Call `init` hooks
                        let initHookError;
                        try {
                            callInitHooks(defaults.options.hooks.init, options);
                            callInitHooks(
                                (_a = options.hooks) === null || _a === void 0
                                    ? void 0
                                    : _a.init,
                                options
                            );
                        } catch (error) {
                            initHookError = error;
                        }
                        // Normalize options & call handlers
                        const normalizedOptions = normalizeArguments(
                            url,
                            options,
                            _defaults !== null && _defaults !== void 0
                                ? _defaults
                                : defaults.options
                        );
                        normalizedOptions[core_1.kIsNormalizedAlready] = true;
                        if (initHookError) {
                            throw new as_promise_1.RequestError(
                                initHookError.message,
                                initHookError,
                                normalizedOptions
                            );
                        }
                        return iterateHandlers(normalizedOptions);
                    } catch (error) {
                        if (options.isStream) {
                            throw error;
                        } else {
                            return create_rejection_1.default(
                                error,
                                defaults.options.hooks.beforeError,
                                (_b = options.hooks) === null || _b === void 0
                                    ? void 0
                                    : _b.beforeError
                            );
                        }
                    }
                };
                got.extend = (...instancesOrOptions) => {
                    const optionsArray = [defaults.options];
                    let handlers = [...defaults._rawHandlers];
                    let isMutableDefaults;
                    for (const value of instancesOrOptions) {
                        if (isGotInstance(value)) {
                            optionsArray.push(value.defaults.options);
                            handlers.push(...value.defaults._rawHandlers);
                            isMutableDefaults = value.defaults.mutableDefaults;
                        } else {
                            optionsArray.push(value);
                            if ("handlers" in value) {
                                handlers.push(...value.handlers);
                            }
                            isMutableDefaults = value.mutableDefaults;
                        }
                    }
                    handlers = handlers.filter(
                        (handler) => handler !== exports.defaultHandler
                    );
                    if (handlers.length === 0) {
                        handlers.push(exports.defaultHandler);
                    }
                    return create({
                        options: mergeOptions(...optionsArray),
                        handlers,
                        mutableDefaults: Boolean(isMutableDefaults),
                    });
                };
                // Pagination
                const paginateEach = async function* (url, options) {
                    // TODO: Remove this `@ts-expect-error` when upgrading to TypeScript 4.
                    // Error: Argument of type 'Merge<Options, PaginationOptions<T, R>> | undefined' is not assignable to parameter of type 'Options | undefined'.
                    // @ts-expect-error
                    let normalizedOptions = normalizeArguments(
                        url,
                        options,
                        defaults.options
                    );
                    normalizedOptions.resolveBodyOnly = false;
                    const pagination = normalizedOptions.pagination;
                    if (!is_1.default.object(pagination)) {
                        throw new TypeError(
                            "`options.pagination` must be implemented"
                        );
                    }
                    const all = [];
                    let { countLimit } = pagination;
                    let numberOfRequests = 0;
                    while (numberOfRequests < pagination.requestLimit) {
                        if (numberOfRequests !== 0) {
                            // eslint-disable-next-line no-await-in-loop
                            await delay(pagination.backoff);
                        }
                        // @ts-expect-error FIXME!
                        // TODO: Throw when result is not an instance of Response
                        // eslint-disable-next-line no-await-in-loop
                        const result = await got(
                            undefined,
                            undefined,
                            normalizedOptions
                        );
                        // eslint-disable-next-line no-await-in-loop
                        const parsed = await pagination.transform(result);
                        const current = [];
                        for (const item of parsed) {
                            if (pagination.filter(item, all, current)) {
                                if (
                                    !pagination.shouldContinue(
                                        item,
                                        all,
                                        current
                                    )
                                ) {
                                    return;
                                }
                                yield item;
                                if (pagination.stackAllItems) {
                                    all.push(item);
                                }
                                current.push(item);
                                if (--countLimit <= 0) {
                                    return;
                                }
                            }
                        }
                        const optionsToMerge = pagination.paginate(
                            result,
                            all,
                            current
                        );
                        if (optionsToMerge === false) {
                            return;
                        }
                        if (optionsToMerge === result.request.options) {
                            normalizedOptions = result.request.options;
                        } else if (optionsToMerge !== undefined) {
                            normalizedOptions = normalizeArguments(
                                undefined,
                                optionsToMerge,
                                normalizedOptions
                            );
                        }
                        numberOfRequests++;
                    }
                };
                got.paginate = paginateEach;
                got.paginate.all = async (url, options) => {
                    const results = [];
                    for await (const item of paginateEach(url, options)) {
                        results.push(item);
                    }
                    return results;
                };
                // For those who like very descriptive names
                got.paginate.each = paginateEach;
                // Stream API
                got.stream = (url, options) =>
                    got(url, { ...options, isStream: true });
                // Shortcuts
                for (const method of aliases) {
                    got[method] = (url, options) =>
                        got(url, { ...options, method });
                    got.stream[method] = (url, options) => {
                        return got(url, { ...options, method, isStream: true });
                    };
                }
                Object.assign(got, errors);
                Object.defineProperty(got, "defaults", {
                    value: defaults.mutableDefaults
                        ? defaults
                        : deep_freeze_1.default(defaults),
                    writable: defaults.mutableDefaults,
                    configurable: defaults.mutableDefaults,
                    enumerable: true,
                });
                got.mergeOptions = mergeOptions;
                return got;
            };
            exports.default = create;
            __exportStar(__nccwpck_require__(2613), exports);

            /***/
        },

        /***/ 3061: /***/ function (module, exports, __nccwpck_require__) {
            "use strict";

            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          Object.defineProperty(o, k2, {
                              enumerable: true,
                              get: function () {
                                  return m[k];
                              },
                          });
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __exportStar =
                (this && this.__exportStar) ||
                function (m, exports) {
                    for (var p in m)
                        if (
                            p !== "default" &&
                            !Object.prototype.hasOwnProperty.call(exports, p)
                        )
                            __createBinding(exports, m, p);
                };
            Object.defineProperty(exports, "__esModule", { value: true });
            const url_1 = __nccwpck_require__(8835);
            const create_1 = __nccwpck_require__(4337);
            const defaults = {
                options: {
                    method: "GET",
                    retry: {
                        limit: 2,
                        methods: [
                            "GET",
                            "PUT",
                            "HEAD",
                            "DELETE",
                            "OPTIONS",
                            "TRACE",
                        ],
                        statusCodes: [
                            408, 413, 429, 500, 502, 503, 504, 521, 522, 524,
                        ],
                        errorCodes: [
                            "ETIMEDOUT",
                            "ECONNRESET",
                            "EADDRINUSE",
                            "ECONNREFUSED",
                            "EPIPE",
                            "ENOTFOUND",
                            "ENETUNREACH",
                            "EAI_AGAIN",
                        ],
                        maxRetryAfter: undefined,
                        calculateDelay: ({ computedValue }) => computedValue,
                    },
                    timeout: {},
                    headers: {
                        "user-agent":
                            "got (https://github.com/sindresorhus/got)",
                    },
                    hooks: {
                        init: [],
                        beforeRequest: [],
                        beforeRedirect: [],
                        beforeRetry: [],
                        beforeError: [],
                        afterResponse: [],
                    },
                    cache: undefined,
                    dnsCache: undefined,
                    decompress: true,
                    throwHttpErrors: true,
                    followRedirect: true,
                    isStream: false,
                    responseType: "text",
                    resolveBodyOnly: false,
                    maxRedirects: 10,
                    prefixUrl: "",
                    methodRewriting: true,
                    ignoreInvalidCookies: false,
                    context: {},
                    // TODO: Set this to `true` when Got 12 gets released
                    http2: false,
                    allowGetBody: false,
                    https: undefined,
                    pagination: {
                        transform: (response) => {
                            if (
                                response.request.options.responseType === "json"
                            ) {
                                return response.body;
                            }
                            return JSON.parse(response.body);
                        },
                        paginate: (response) => {
                            if (!Reflect.has(response.headers, "link")) {
                                return false;
                            }
                            const items = response.headers.link.split(",");
                            let next;
                            for (const item of items) {
                                const parsed = item.split(";");
                                if (parsed[1].includes("next")) {
                                    next = parsed[0].trimStart().trim();
                                    next = next.slice(1, -1);
                                    break;
                                }
                            }
                            if (next) {
                                const options = {
                                    url: new url_1.URL(next),
                                };
                                return options;
                            }
                            return false;
                        },
                        filter: () => true,
                        shouldContinue: () => true,
                        countLimit: Infinity,
                        backoff: 0,
                        requestLimit: 10000,
                        stackAllItems: true,
                    },
                    parseJson: (text) => JSON.parse(text),
                    stringifyJson: (object) => JSON.stringify(object),
                    cacheOptions: {},
                },
                handlers: [create_1.defaultHandler],
                mutableDefaults: false,
            };
            const got = create_1.default(defaults);
            exports.default = got;
            // For CommonJS default export support
            module.exports = got;
            module.exports.default = got;
            module.exports.__esModule = true; // Workaround for TS issue: https://github.com/sindresorhus/got/pull/1267
            __exportStar(__nccwpck_require__(4337), exports);
            __exportStar(__nccwpck_require__(6056), exports);

            /***/
        },

        /***/ 2613: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });

            /***/
        },

        /***/ 285: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            const is_1 = __nccwpck_require__(7678);
            function deepFreeze(object) {
                for (const value of Object.values(object)) {
                    if (
                        is_1.default.plainObject(value) ||
                        is_1.default.array(value)
                    ) {
                        deepFreeze(value);
                    }
                }
                return Object.freeze(object);
            }
            exports.default = deepFreeze;

            /***/
        },

        /***/ 397: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            const alreadyWarned = new Set();
            exports.default = (message) => {
                if (alreadyWarned.has(message)) {
                    return;
                }
                alreadyWarned.add(message);
                // @ts-expect-error Missing types.
                process.emitWarning(`Got: ${message}`, {
                    type: "DeprecationWarning",
                });
            };

            /***/
        },

        /***/ 1002: /***/ (module) => {
            "use strict";

            // rfc7231 6.1
            const statusCodeCacheableByDefault = new Set([
                200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501,
            ]);

            // This implementation does not understand partial responses (206)
            const understoodStatuses = new Set([
                200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414,
                501,
            ]);

            const errorStatusCodes = new Set([500, 502, 503, 504]);

            const hopByHopHeaders = {
                date: true, // included, because we add Age update Date
                connection: true,
                "keep-alive": true,
                "proxy-authenticate": true,
                "proxy-authorization": true,
                te: true,
                trailer: true,
                "transfer-encoding": true,
                upgrade: true,
            };

            const excludedFromRevalidationUpdate = {
                // Since the old body is reused, it doesn't make sense to change properties of the body
                "content-length": true,
                "content-encoding": true,
                "transfer-encoding": true,
                "content-range": true,
            };

            function toNumberOrZero(s) {
                const n = parseInt(s, 10);
                return isFinite(n) ? n : 0;
            }

            // RFC 5861
            function isErrorResponse(response) {
                // consider undefined response as faulty
                if (!response) {
                    return true;
                }
                return errorStatusCodes.has(response.status);
            }

            function parseCacheControl(header) {
                const cc = {};
                if (!header) return cc;

                // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),
                // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale
                const parts = header.trim().split(/\s*,\s*/); // TODO: lame parsing
                for (const part of parts) {
                    const [k, v] = part.split(/\s*=\s*/, 2);
                    cc[k] = v === undefined ? true : v.replace(/^"|"$/g, ""); // TODO: lame unquoting
                }

                return cc;
            }

            function formatCacheControl(cc) {
                let parts = [];
                for (const k in cc) {
                    const v = cc[k];
                    parts.push(v === true ? k : k + "=" + v);
                }
                if (!parts.length) {
                    return undefined;
                }
                return parts.join(", ");
            }

            module.exports = class CachePolicy {
                constructor(
                    req,
                    res,
                    {
                        shared,
                        cacheHeuristic,
                        immutableMinTimeToLive,
                        ignoreCargoCult,
                        _fromObject,
                    } = {}
                ) {
                    if (_fromObject) {
                        this._fromObject(_fromObject);
                        return;
                    }

                    if (!res || !res.headers) {
                        throw Error("Response headers missing");
                    }
                    this._assertRequestHasHeaders(req);

                    this._responseTime = this.now();
                    this._isShared = shared !== false;
                    this._cacheHeuristic =
                        undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE
                    this._immutableMinTtl =
                        undefined !== immutableMinTimeToLive
                            ? immutableMinTimeToLive
                            : 24 * 3600 * 1000;

                    this._status = "status" in res ? res.status : 200;
                    this._resHeaders = res.headers;
                    this._rescc = parseCacheControl(
                        res.headers["cache-control"]
                    );
                    this._method = "method" in req ? req.method : "GET";
                    this._url = req.url;
                    this._host = req.headers.host;
                    this._noAuthorization = !req.headers.authorization;
                    this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used
                    this._reqcc = parseCacheControl(
                        req.headers["cache-control"]
                    );

                    // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,
                    // so there's no point stricly adhering to the blindly copy&pasted directives.
                    if (
                        ignoreCargoCult &&
                        "pre-check" in this._rescc &&
                        "post-check" in this._rescc
                    ) {
                        delete this._rescc["pre-check"];
                        delete this._rescc["post-check"];
                        delete this._rescc["no-cache"];
                        delete this._rescc["no-store"];
                        delete this._rescc["must-revalidate"];
                        this._resHeaders = Object.assign({}, this._resHeaders, {
                            "cache-control": formatCacheControl(this._rescc),
                        });
                        delete this._resHeaders.expires;
                        delete this._resHeaders.pragma;
                    }

                    // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive
                    // as having the same effect as if "Cache-Control: no-cache" were present (see Section 5.2.1).
                    if (
                        res.headers["cache-control"] == null &&
                        /no-cache/.test(res.headers.pragma)
                    ) {
                        this._rescc["no-cache"] = true;
                    }
                }

                now() {
                    return Date.now();
                }

                storable() {
                    // The "no-store" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.
                    return !!(
                        !this._reqcc["no-store"] &&
                        // A cache MUST NOT store a response to any request, unless:
                        // The request method is understood by the cache and defined as being cacheable, and
                        ("GET" === this._method ||
                            "HEAD" === this._method ||
                            ("POST" === this._method &&
                                this._hasExplicitExpiration())) &&
                        // the response status code is understood by the cache, and
                        understoodStatuses.has(this._status) &&
                        // the "no-store" cache directive does not appear in request or response header fields, and
                        !this._rescc["no-store"] &&
                        // the "private" response directive does not appear in the response, if the cache is shared, and
                        (!this._isShared || !this._rescc.private) &&
                        // the Authorization header field does not appear in the request, if the cache is shared,
                        (!this._isShared ||
                            this._noAuthorization ||
                            this._allowsStoringAuthenticated()) &&
                        // the response either:
                        // contains an Expires header field, or
                        (this._resHeaders.expires ||
                            // contains a max-age response directive, or
                            // contains a s-maxage response directive and the cache is shared, or
                            // contains a public response directive.
                            this._rescc["max-age"] ||
                            (this._isShared && this._rescc["s-maxage"]) ||
                            this._rescc.public ||
                            // has a status code that is defined as cacheable by default
                            statusCodeCacheableByDefault.has(this._status))
                    );
                }

                _hasExplicitExpiration() {
                    // 4.2.1 Calculating Freshness Lifetime
                    return (
                        (this._isShared && this._rescc["s-maxage"]) ||
                        this._rescc["max-age"] ||
                        this._resHeaders.expires
                    );
                }

                _assertRequestHasHeaders(req) {
                    if (!req || !req.headers) {
                        throw Error("Request headers missing");
                    }
                }

                satisfiesWithoutRevalidation(req) {
                    this._assertRequestHasHeaders(req);

                    // When presented with a request, a cache MUST NOT reuse a stored response, unless:
                    // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,
                    // unless the stored response is successfully validated (Section 4.3), and
                    const requestCC = parseCacheControl(
                        req.headers["cache-control"]
                    );
                    if (
                        requestCC["no-cache"] ||
                        /no-cache/.test(req.headers.pragma)
                    ) {
                        return false;
                    }

                    if (
                        requestCC["max-age"] &&
                        this.age() > requestCC["max-age"]
                    ) {
                        return false;
                    }

                    if (
                        requestCC["min-fresh"] &&
                        this.timeToLive() < 1000 * requestCC["min-fresh"]
                    ) {
                        return false;
                    }

                    // the stored response is either:
                    // fresh, or allowed to be served stale
                    if (this.stale()) {
                        const allowsStale =
                            requestCC["max-stale"] &&
                            !this._rescc["must-revalidate"] &&
                            (true === requestCC["max-stale"] ||
                                requestCC["max-stale"] >
                                    this.age() - this.maxAge());
                        if (!allowsStale) {
                            return false;
                        }
                    }

                    return this._requestMatches(req, false);
                }

                _requestMatches(req, allowHeadMethod) {
                    // The presented effective request URI and that of the stored response match, and
                    return (
                        (!this._url || this._url === req.url) &&
                        this._host === req.headers.host &&
                        // the request method associated with the stored response allows it to be used for the presented request, and
                        (!req.method ||
                            this._method === req.method ||
                            (allowHeadMethod && "HEAD" === req.method)) &&
                        // selecting header fields nominated by the stored response (if any) match those presented, and
                        this._varyMatches(req)
                    );
                }

                _allowsStoringAuthenticated() {
                    //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.
                    return (
                        this._rescc["must-revalidate"] ||
                        this._rescc.public ||
                        this._rescc["s-maxage"]
                    );
                }

                _varyMatches(req) {
                    if (!this._resHeaders.vary) {
                        return true;
                    }

                    // A Vary header field-value of "*" always fails to match
                    if (this._resHeaders.vary === "*") {
                        return false;
                    }

                    const fields = this._resHeaders.vary
                        .trim()
                        .toLowerCase()
                        .split(/\s*,\s*/);
                    for (const name of fields) {
                        if (req.headers[name] !== this._reqHeaders[name])
                            return false;
                    }
                    return true;
                }

                _copyWithoutHopByHopHeaders(inHeaders) {
                    const headers = {};
                    for (const name in inHeaders) {
                        if (hopByHopHeaders[name]) continue;
                        headers[name] = inHeaders[name];
                    }
                    // 9.1.  Connection
                    if (inHeaders.connection) {
                        const tokens = inHeaders.connection
                            .trim()
                            .split(/\s*,\s*/);
                        for (const name of tokens) {
                            delete headers[name];
                        }
                    }
                    if (headers.warning) {
                        const warnings = headers.warning
                            .split(/,/)
                            .filter((warning) => {
                                return !/^\s*1[0-9][0-9]/.test(warning);
                            });
                        if (!warnings.length) {
                            delete headers.warning;
                        } else {
                            headers.warning = warnings.join(",").trim();
                        }
                    }
                    return headers;
                }

                responseHeaders() {
                    const headers = this._copyWithoutHopByHopHeaders(
                        this._resHeaders
                    );
                    const age = this.age();

                    // A cache SHOULD generate 113 warning if it heuristically chose a freshness
                    // lifetime greater than 24 hours and the response's age is greater than 24 hours.
                    if (
                        age > 3600 * 24 &&
                        !this._hasExplicitExpiration() &&
                        this.maxAge() > 3600 * 24
                    ) {
                        headers.warning =
                            (headers.warning ? `${headers.warning}, ` : "") +
                            '113 - "rfc7234 5.5.4"';
                    }
                    headers.age = `${Math.round(age)}`;
                    headers.date = new Date(this.now()).toUTCString();
                    return headers;
                }

                /**
                 * Value of the Date response header or current time if Date was invalid
                 * @return timestamp
                 */
                date() {
                    const serverDate = Date.parse(this._resHeaders.date);
                    if (isFinite(serverDate)) {
                        return serverDate;
                    }
                    return this._responseTime;
                }

                /**
                 * Value of the Age header, in seconds, updated for the current time.
                 * May be fractional.
                 *
                 * @return Number
                 */
                age() {
                    let age = this._ageValue();

                    const residentTime =
                        (this.now() - this._responseTime) / 1000;
                    return age + residentTime;
                }

                _ageValue() {
                    return toNumberOrZero(this._resHeaders.age);
                }

                /**
                 * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.
                 *
                 * For an up-to-date value, see `timeToLive()`.
                 *
                 * @return Number
                 */
                maxAge() {
                    if (!this.storable() || this._rescc["no-cache"]) {
                        return 0;
                    }

                    // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default
                    // so this implementation requires explicit opt-in via public header
                    if (
                        this._isShared &&
                        this._resHeaders["set-cookie"] &&
                        !this._rescc.public &&
                        !this._rescc.immutable
                    ) {
                        return 0;
                    }

                    if (this._resHeaders.vary === "*") {
                        return 0;
                    }

                    if (this._isShared) {
                        if (this._rescc["proxy-revalidate"]) {
                            return 0;
                        }
                        // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.
                        if (this._rescc["s-maxage"]) {
                            return toNumberOrZero(this._rescc["s-maxage"]);
                        }
                    }

                    // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.
                    if (this._rescc["max-age"]) {
                        return toNumberOrZero(this._rescc["max-age"]);
                    }

                    const defaultMinTtl = this._rescc.immutable
                        ? this._immutableMinTtl
                        : 0;

                    const serverDate = this.date();
                    if (this._resHeaders.expires) {
                        const expires = Date.parse(this._resHeaders.expires);
                        // A cache recipient MUST interpret invalid date formats, especially the value "0", as representing a time in the past (i.e., "already expired").
                        if (Number.isNaN(expires) || expires < serverDate) {
                            return 0;
                        }
                        return Math.max(
                            defaultMinTtl,
                            (expires - serverDate) / 1000
                        );
                    }

                    if (this._resHeaders["last-modified"]) {
                        const lastModified = Date.parse(
                            this._resHeaders["last-modified"]
                        );
                        if (
                            isFinite(lastModified) &&
                            serverDate > lastModified
                        ) {
                            return Math.max(
                                defaultMinTtl,
                                ((serverDate - lastModified) / 1000) *
                                    this._cacheHeuristic
                            );
                        }
                    }

                    return defaultMinTtl;
                }

                timeToLive() {
                    const age = this.maxAge() - this.age();
                    const staleIfErrorAge =
                        age + toNumberOrZero(this._rescc["stale-if-error"]);
                    const staleWhileRevalidateAge =
                        age +
                        toNumberOrZero(this._rescc["stale-while-revalidate"]);
                    return (
                        Math.max(
                            0,
                            age,
                            staleIfErrorAge,
                            staleWhileRevalidateAge
                        ) * 1000
                    );
                }

                stale() {
                    return this.maxAge() <= this.age();
                }

                _useStaleIfError() {
                    return (
                        this.maxAge() +
                            toNumberOrZero(this._rescc["stale-if-error"]) >
                        this.age()
                    );
                }

                useStaleWhileRevalidate() {
                    return (
                        this.maxAge() +
                            toNumberOrZero(
                                this._rescc["stale-while-revalidate"]
                            ) >
                        this.age()
                    );
                }

                static fromObject(obj) {
                    return new this(undefined, undefined, { _fromObject: obj });
                }

                _fromObject(obj) {
                    if (this._responseTime) throw Error("Reinitialized");
                    if (!obj || obj.v !== 1)
                        throw Error("Invalid serialization");

                    this._responseTime = obj.t;
                    this._isShared = obj.sh;
                    this._cacheHeuristic = obj.ch;
                    this._immutableMinTtl =
                        obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;
                    this._status = obj.st;
                    this._resHeaders = obj.resh;
                    this._rescc = obj.rescc;
                    this._method = obj.m;
                    this._url = obj.u;
                    this._host = obj.h;
                    this._noAuthorization = obj.a;
                    this._reqHeaders = obj.reqh;
                    this._reqcc = obj.reqcc;
                }

                toObject() {
                    return {
                        v: 1,
                        t: this._responseTime,
                        sh: this._isShared,
                        ch: this._cacheHeuristic,
                        imm: this._immutableMinTtl,
                        st: this._status,
                        resh: this._resHeaders,
                        rescc: this._rescc,
                        m: this._method,
                        u: this._url,
                        h: this._host,
                        a: this._noAuthorization,
                        reqh: this._reqHeaders,
                        reqcc: this._reqcc,
                    };
                }

                /**
                 * Headers for sending to the origin server to revalidate stale response.
                 * Allows server to return 304 to allow reuse of the previous response.
                 *
                 * Hop by hop headers are always stripped.
                 * Revalidation headers may be added or removed, depending on request.
                 */
                revalidationHeaders(incomingReq) {
                    this._assertRequestHasHeaders(incomingReq);
                    const headers = this._copyWithoutHopByHopHeaders(
                        incomingReq.headers
                    );

                    // This implementation does not understand range requests
                    delete headers["if-range"];

                    if (
                        !this._requestMatches(incomingReq, true) ||
                        !this.storable()
                    ) {
                        // revalidation allowed via HEAD
                        // not for the same resource, or wasn't allowed to be cached anyway
                        delete headers["if-none-match"];
                        delete headers["if-modified-since"];
                        return headers;
                    }

                    /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */
                    if (this._resHeaders.etag) {
                        headers["if-none-match"] = headers["if-none-match"]
                            ? `${headers["if-none-match"]}, ${this._resHeaders.etag}`
                            : this._resHeaders.etag;
                    }

                    // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.
                    const forbidsWeakValidators =
                        headers["accept-ranges"] ||
                        headers["if-match"] ||
                        headers["if-unmodified-since"] ||
                        (this._method && this._method != "GET");

                    /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.
        Note: This implementation does not understand partial responses (206) */
                    if (forbidsWeakValidators) {
                        delete headers["if-modified-since"];

                        if (headers["if-none-match"]) {
                            const etags = headers["if-none-match"]
                                .split(/,/)
                                .filter((etag) => {
                                    return !/^\s*W\//.test(etag);
                                });
                            if (!etags.length) {
                                delete headers["if-none-match"];
                            } else {
                                headers["if-none-match"] = etags
                                    .join(",")
                                    .trim();
                            }
                        }
                    } else if (
                        this._resHeaders["last-modified"] &&
                        !headers["if-modified-since"]
                    ) {
                        headers["if-modified-since"] =
                            this._resHeaders["last-modified"];
                    }

                    return headers;
                }

                /**
                 * Creates new CachePolicy with information combined from the previews response,
                 * and the new revalidation response.
                 *
                 * Returns {policy, modified} where modified is a boolean indicating
                 * whether the response body has been modified, and old cached body can't be used.
                 *
                 * @return {Object} {policy: CachePolicy, modified: Boolean}
                 */
                revalidatedPolicy(request, response) {
                    this._assertRequestHasHeaders(request);
                    if (this._useStaleIfError() && isErrorResponse(response)) {
                        // I consider the revalidation request unsuccessful
                        return {
                            modified: false,
                            matches: false,
                            policy: this,
                        };
                    }
                    if (!response || !response.headers) {
                        throw Error("Response headers missing");
                    }

                    // These aren't going to be supported exactly, since one CachePolicy object
                    // doesn't know about all the other cached objects.
                    let matches = false;
                    if (
                        response.status !== undefined &&
                        response.status != 304
                    ) {
                        matches = false;
                    } else if (
                        response.headers.etag &&
                        !/^\s*W\//.test(response.headers.etag)
                    ) {
                        // "All of the stored responses with the same strong validator are selected.
                        // If none of the stored responses contain the same strong validator,
                        // then the cache MUST NOT use the new response to update any stored responses."
                        matches =
                            this._resHeaders.etag &&
                            this._resHeaders.etag.replace(/^\s*W\//, "") ===
                                response.headers.etag;
                    } else if (this._resHeaders.etag && response.headers.etag) {
                        // "If the new response contains a weak validator and that validator corresponds
                        // to one of the cache's stored responses,
                        // then the most recent of those matching stored responses is selected for update."
                        matches =
                            this._resHeaders.etag.replace(/^\s*W\//, "") ===
                            response.headers.etag.replace(/^\s*W\//, "");
                    } else if (this._resHeaders["last-modified"]) {
                        matches =
                            this._resHeaders["last-modified"] ===
                            response.headers["last-modified"];
                    } else {
                        // If the new response does not include any form of validator (such as in the case where
                        // a client generates an If-Modified-Since request from a source other than the Last-Modified
                        // response header field), and there is only one stored response, and that stored response also
                        // lacks a validator, then that stored response is selected for update.
                        if (
                            !this._resHeaders.etag &&
                            !this._resHeaders["last-modified"] &&
                            !response.headers.etag &&
                            !response.headers["last-modified"]
                        ) {
                            matches = true;
                        }
                    }

                    if (!matches) {
                        return {
                            policy: new this.constructor(request, response),
                            // Client receiving 304 without body, even if it's invalid/mismatched has no option
                            // but to reuse a cached body. We don't have a good way to tell clients to do
                            // error recovery in such case.
                            modified: response.status != 304,
                            matches: false,
                        };
                    }

                    // use other header fields provided in the 304 (Not Modified) response to replace all instances
                    // of the corresponding header fields in the stored response.
                    const headers = {};
                    for (const k in this._resHeaders) {
                        headers[k] =
                            k in response.headers &&
                            !excludedFromRevalidationUpdate[k]
                                ? response.headers[k]
                                : this._resHeaders[k];
                    }

                    const newResponse = Object.assign({}, response, {
                        status: this._status,
                        method: this._method,
                        headers,
                    });
                    return {
                        policy: new this.constructor(request, newResponse, {
                            shared: this._isShared,
                            cacheHeuristic: this._cacheHeuristic,
                            immutableMinTimeToLive: this._immutableMinTtl,
                        }),
                        modified: false,
                        matches: true,
                    };
                }
            };

            /***/
        },

        /***/ 9898: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            "use strict";

            const EventEmitter = __nccwpck_require__(8614);
            const tls = __nccwpck_require__(4016);
            const http2 = __nccwpck_require__(7565);
            const QuickLRU = __nccwpck_require__(9273);

            const kCurrentStreamsCount = Symbol("currentStreamsCount");
            const kRequest = Symbol("request");
            const kOriginSet = Symbol("cachedOriginSet");
            const kGracefullyClosing = Symbol("gracefullyClosing");

            const nameKeys = [
                // `http2.connect()` options
                "maxDeflateDynamicTableSize",
                "maxSessionMemory",
                "maxHeaderListPairs",
                "maxOutstandingPings",
                "maxReservedRemoteStreams",
                "maxSendHeaderBlockLength",
                "paddingStrategy",

                // `tls.connect()` options
                "localAddress",
                "path",
                "rejectUnauthorized",
                "minDHSize",

                // `tls.createSecureContext()` options
                "ca",
                "cert",
                "clientCertEngine",
                "ciphers",
                "key",
                "pfx",
                "servername",
                "minVersion",
                "maxVersion",
                "secureProtocol",
                "crl",
                "honorCipherOrder",
                "ecdhCurve",
                "dhparam",
                "secureOptions",
                "sessionIdContext",
            ];

            const getSortedIndex = (array, value, compare) => {
                let low = 0;
                let high = array.length;

                while (low < high) {
                    const mid = (low + high) >>> 1;

                    /* istanbul ignore next */
                    if (compare(array[mid], value)) {
                        // This never gets called because we use descending sort. Better to have this anyway.
                        low = mid + 1;
                    } else {
                        high = mid;
                    }
                }

                return low;
            };

            const compareSessions = (a, b) => {
                return (
                    a.remoteSettings.maxConcurrentStreams >
                    b.remoteSettings.maxConcurrentStreams
                );
            };

            // See https://tools.ietf.org/html/rfc8336
            const closeCoveredSessions = (where, session) => {
                // Clients SHOULD NOT emit new requests on any connection whose Origin
                // Set is a proper subset of another connection's Origin Set, and they
                // SHOULD close it once all outstanding requests are satisfied.
                for (const coveredSession of where) {
                    if (
                        // The set is a proper subset when its length is less than the other set.
                        coveredSession[kOriginSet].length <
                            session[kOriginSet].length &&
                        // And the other set includes all elements of the subset.
                        coveredSession[kOriginSet].every((origin) =>
                            session[kOriginSet].includes(origin)
                        ) &&
                        // Makes sure that the session can handle all requests from the covered session.
                        coveredSession[kCurrentStreamsCount] +
                            session[kCurrentStreamsCount] <=
                            session.remoteSettings.maxConcurrentStreams
                    ) {
                        // This allows pending requests to finish and prevents making new requests.
                        gracefullyClose(coveredSession);
                    }
                }
            };

            // This is basically inverted `closeCoveredSessions(...)`.
            const closeSessionIfCovered = (where, coveredSession) => {
                for (const session of where) {
                    if (
                        coveredSession[kOriginSet].length <
                            session[kOriginSet].length &&
                        coveredSession[kOriginSet].every((origin) =>
                            session[kOriginSet].includes(origin)
                        ) &&
                        coveredSession[kCurrentStreamsCount] +
                            session[kCurrentStreamsCount] <=
                            session.remoteSettings.maxConcurrentStreams
                    ) {
                        gracefullyClose(coveredSession);
                    }
                }
            };

            const getSessions = ({ agent, isFree }) => {
                const result = {};

                // eslint-disable-next-line guard-for-in
                for (const normalizedOptions in agent.sessions) {
                    const sessions = agent.sessions[normalizedOptions];

                    const filtered = sessions.filter((session) => {
                        const result =
                            session[Agent.kCurrentStreamsCount] <
                            session.remoteSettings.maxConcurrentStreams;

                        return isFree ? result : !result;
                    });

                    if (filtered.length !== 0) {
                        result[normalizedOptions] = filtered;
                    }
                }

                return result;
            };

            const gracefullyClose = (session) => {
                session[kGracefullyClosing] = true;

                if (session[kCurrentStreamsCount] === 0) {
                    session.close();
                }
            };

            class Agent extends EventEmitter {
                constructor({
                    timeout = 60000,
                    maxSessions = Infinity,
                    maxFreeSessions = 10,
                    maxCachedTlsSessions = 100,
                } = {}) {
                    super();

                    // A session is considered busy when its current streams count
                    // is equal to or greater than the `maxConcurrentStreams` value.

                    // A session is considered free when its current streams count
                    // is less than the `maxConcurrentStreams` value.

                    // SESSIONS[NORMALIZED_OPTIONS] = [];
                    this.sessions = {};

                    // The queue for creating new sessions. It looks like this:
                    // QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION
                    //
                    // The entry function has `listeners`, `completed` and `destroyed` properties.
                    // `listeners` is an array of objects containing `resolve` and `reject` functions.
                    // `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.
                    // `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.
                    this.queue = {};

                    // Each session will use this timeout value.
                    this.timeout = timeout;

                    // Max sessions in total
                    this.maxSessions = maxSessions;

                    // Max free sessions in total
                    // TODO: decreasing `maxFreeSessions` should close some sessions
                    this.maxFreeSessions = maxFreeSessions;

                    this._freeSessionsCount = 0;
                    this._sessionsCount = 0;

                    // We don't support push streams by default.
                    this.settings = {
                        enablePush: false,
                    };

                    // Reusing TLS sessions increases performance.
                    this.tlsSessionCache = new QuickLRU({
                        maxSize: maxCachedTlsSessions,
                    });
                }

                static normalizeOrigin(url, servername) {
                    if (typeof url === "string") {
                        url = new URL(url);
                    }

                    if (servername && url.hostname !== servername) {
                        url.hostname = servername;
                    }

                    return url.origin;
                }

                normalizeOptions(options) {
                    let normalized = "";

                    if (options) {
                        for (const key of nameKeys) {
                            if (options[key]) {
                                normalized += `:${options[key]}`;
                            }
                        }
                    }

                    return normalized;
                }

                _tryToCreateNewSession(normalizedOptions, normalizedOrigin) {
                    if (
                        !(normalizedOptions in this.queue) ||
                        !(normalizedOrigin in this.queue[normalizedOptions])
                    ) {
                        return;
                    }

                    const item =
                        this.queue[normalizedOptions][normalizedOrigin];

                    // The entry function can be run only once.
                    // BUG: The session may be never created when:
                    // - the first condition is false AND
                    // - this function is never called with the same arguments in the future.
                    if (
                        this._sessionsCount < this.maxSessions &&
                        !item.completed
                    ) {
                        item.completed = true;

                        item();
                    }
                }

                getSession(origin, options, listeners) {
                    return new Promise((resolve, reject) => {
                        if (Array.isArray(listeners)) {
                            listeners = [...listeners];

                            // Resolve the current promise ASAP, we're just moving the listeners.
                            // They will be executed at a different time.
                            resolve();
                        } else {
                            listeners = [{ resolve, reject }];
                        }

                        const normalizedOptions =
                            this.normalizeOptions(options);
                        const normalizedOrigin = Agent.normalizeOrigin(
                            origin,
                            options && options.servername
                        );

                        if (normalizedOrigin === undefined) {
                            for (const { reject } of listeners) {
                                reject(
                                    new TypeError(
                                        "The `origin` argument needs to be a string or an URL object"
                                    )
                                );
                            }

                            return;
                        }

                        if (normalizedOptions in this.sessions) {
                            const sessions = this.sessions[normalizedOptions];

                            let maxConcurrentStreams = -1;
                            let currentStreamsCount = -1;
                            let optimalSession;

                            // We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.
                            // Additionally, we are looking for session which has biggest current pending streams count.
                            for (const session of sessions) {
                                const sessionMaxConcurrentStreams =
                                    session.remoteSettings.maxConcurrentStreams;

                                if (
                                    sessionMaxConcurrentStreams <
                                    maxConcurrentStreams
                                ) {
                                    break;
                                }

                                if (
                                    session[kOriginSet].includes(
                                        normalizedOrigin
                                    )
                                ) {
                                    const sessionCurrentStreamsCount =
                                        session[kCurrentStreamsCount];

                                    if (
                                        sessionCurrentStreamsCount >=
                                            sessionMaxConcurrentStreams ||
                                        session[kGracefullyClosing] ||
                                        // Unfortunately the `close` event isn't called immediately,
                                        // so `session.destroyed` is `true`, but `session.closed` is `false`.
                                        session.destroyed
                                    ) {
                                        continue;
                                    }

                                    // We only need set this once.
                                    if (!optimalSession) {
                                        maxConcurrentStreams =
                                            sessionMaxConcurrentStreams;
                                    }

                                    // We're looking for the session which has biggest current pending stream count,
                                    // in order to minimalize the amount of active sessions.
                                    if (
                                        sessionCurrentStreamsCount >
                                        currentStreamsCount
                                    ) {
                                        optimalSession = session;
                                        currentStreamsCount =
                                            sessionCurrentStreamsCount;
                                    }
                                }
                            }

                            if (optimalSession) {
                                /* istanbul ignore next: safety check */
                                if (listeners.length !== 1) {
                                    for (const { reject } of listeners) {
                                        const error = new Error(
                                            `Expected the length of listeners to be 1, got ${listeners.length}.\n` +
                                                "Please report this to https://github.com/szmarczak/http2-wrapper/"
                                        );

                                        reject(error);
                                    }

                                    return;
                                }

                                listeners[0].resolve(optimalSession);
                                return;
                            }
                        }

                        if (normalizedOptions in this.queue) {
                            if (
                                normalizedOrigin in
                                this.queue[normalizedOptions]
                            ) {
                                // There's already an item in the queue, just attach ourselves to it.
                                this.queue[normalizedOptions][
                                    normalizedOrigin
                                ].listeners.push(...listeners);

                                // This shouldn't be executed here.
                                // See the comment inside _tryToCreateNewSession.
                                this._tryToCreateNewSession(
                                    normalizedOptions,
                                    normalizedOrigin
                                );
                                return;
                            }
                        } else {
                            this.queue[normalizedOptions] = {};
                        }

                        // The entry must be removed from the queue IMMEDIATELY when:
                        // 1. the session connects successfully,
                        // 2. an error occurs.
                        const removeFromQueue = () => {
                            // Our entry can be replaced. We cannot remove the new one.
                            if (
                                normalizedOptions in this.queue &&
                                this.queue[normalizedOptions][
                                    normalizedOrigin
                                ] === entry
                            ) {
                                delete this.queue[normalizedOptions][
                                    normalizedOrigin
                                ];

                                if (
                                    Object.keys(this.queue[normalizedOptions])
                                        .length === 0
                                ) {
                                    delete this.queue[normalizedOptions];
                                }
                            }
                        };

                        // The main logic is here
                        const entry = () => {
                            const name = `${normalizedOrigin}:${normalizedOptions}`;
                            let receivedSettings = false;

                            try {
                                const session = http2.connect(origin, {
                                    createConnection: this.createConnection,
                                    settings: this.settings,
                                    session: this.tlsSessionCache.get(name),
                                    ...options,
                                });
                                session[kCurrentStreamsCount] = 0;
                                session[kGracefullyClosing] = false;

                                const isFree = () =>
                                    session[kCurrentStreamsCount] <
                                    session.remoteSettings.maxConcurrentStreams;
                                let wasFree = true;

                                session.socket.once("session", (tlsSession) => {
                                    this.tlsSessionCache.set(name, tlsSession);
                                });

                                session.once("error", (error) => {
                                    // Listeners are empty when the session successfully connected.
                                    for (const { reject } of listeners) {
                                        reject(error);
                                    }

                                    // The connection got broken, purge the cache.
                                    this.tlsSessionCache.delete(name);
                                });

                                session.setTimeout(this.timeout, () => {
                                    // Terminates all streams owned by this session.
                                    // TODO: Maybe the streams should have a "Session timed out" error?
                                    session.destroy();
                                });

                                session.once("close", () => {
                                    if (receivedSettings) {
                                        // 1. If it wasn't free then no need to decrease because
                                        //    it has been decreased already in session.request().
                                        // 2. `stream.once('close')` won't increment the count
                                        //    because the session is already closed.
                                        if (wasFree) {
                                            this._freeSessionsCount--;
                                        }

                                        this._sessionsCount--;

                                        // This cannot be moved to the stream logic,
                                        // because there may be a session that hadn't made a single request.
                                        const where =
                                            this.sessions[normalizedOptions];
                                        where.splice(where.indexOf(session), 1);

                                        if (where.length === 0) {
                                            delete this.sessions[
                                                normalizedOptions
                                            ];
                                        }
                                    } else {
                                        // Broken connection
                                        const error = new Error(
                                            "Session closed without receiving a SETTINGS frame"
                                        );
                                        error.code = "HTTP2WRAPPER_NOSETTINGS";

                                        for (const { reject } of listeners) {
                                            reject(error);
                                        }

                                        removeFromQueue();
                                    }

                                    // There may be another session awaiting.
                                    this._tryToCreateNewSession(
                                        normalizedOptions,
                                        normalizedOrigin
                                    );
                                });

                                // Iterates over the queue and processes listeners.
                                const processListeners = () => {
                                    if (
                                        !(normalizedOptions in this.queue) ||
                                        !isFree()
                                    ) {
                                        return;
                                    }

                                    for (const origin of session[kOriginSet]) {
                                        if (
                                            origin in
                                            this.queue[normalizedOptions]
                                        ) {
                                            const { listeners } =
                                                this.queue[normalizedOptions][
                                                    origin
                                                ];

                                            // Prevents session overloading.
                                            while (
                                                listeners.length !== 0 &&
                                                isFree()
                                            ) {
                                                // We assume `resolve(...)` calls `request(...)` *directly*,
                                                // otherwise the session will get overloaded.
                                                listeners
                                                    .shift()
                                                    .resolve(session);
                                            }

                                            const where =
                                                this.queue[normalizedOptions];
                                            if (
                                                where[origin].listeners
                                                    .length === 0
                                            ) {
                                                delete where[origin];

                                                if (
                                                    Object.keys(where)
                                                        .length === 0
                                                ) {
                                                    delete this.queue[
                                                        normalizedOptions
                                                    ];
                                                    break;
                                                }
                                            }

                                            // We're no longer free, no point in continuing.
                                            if (!isFree()) {
                                                break;
                                            }
                                        }
                                    }
                                };

                                // The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.
                                session.on("origin", () => {
                                    session[kOriginSet] = session.originSet;

                                    if (!isFree()) {
                                        // The session is full.
                                        return;
                                    }

                                    processListeners();

                                    // Close covered sessions (if possible).
                                    closeCoveredSessions(
                                        this.sessions[normalizedOptions],
                                        session
                                    );
                                });

                                session.once("remoteSettings", () => {
                                    // Fix Node.js bug preventing the process from exiting
                                    session.ref();
                                    session.unref();

                                    this._sessionsCount++;

                                    // The Agent could have been destroyed already.
                                    if (entry.destroyed) {
                                        const error = new Error(
                                            "Agent has been destroyed"
                                        );

                                        for (const listener of listeners) {
                                            listener.reject(error);
                                        }

                                        session.destroy();
                                        return;
                                    }

                                    session[kOriginSet] = session.originSet;

                                    {
                                        const where = this.sessions;

                                        if (normalizedOptions in where) {
                                            const sessions =
                                                where[normalizedOptions];
                                            sessions.splice(
                                                getSortedIndex(
                                                    sessions,
                                                    session,
                                                    compareSessions
                                                ),
                                                0,
                                                session
                                            );
                                        } else {
                                            where[normalizedOptions] = [
                                                session,
                                            ];
                                        }
                                    }

                                    this._freeSessionsCount += 1;
                                    receivedSettings = true;

                                    this.emit("session", session);

                                    processListeners();
                                    removeFromQueue();

                                    // TODO: Close last recently used (or least used?) session
                                    if (
                                        session[kCurrentStreamsCount] === 0 &&
                                        this._freeSessionsCount >
                                            this.maxFreeSessions
                                    ) {
                                        session.close();
                                    }

                                    // Check if we haven't managed to execute all listeners.
                                    if (listeners.length !== 0) {
                                        // Request for a new session with predefined listeners.
                                        this.getSession(
                                            normalizedOrigin,
                                            options,
                                            listeners
                                        );
                                        listeners.length = 0;
                                    }

                                    // `session.remoteSettings.maxConcurrentStreams` might get increased
                                    session.on("remoteSettings", () => {
                                        processListeners();

                                        // In case the Origin Set changes
                                        closeCoveredSessions(
                                            this.sessions[normalizedOptions],
                                            session
                                        );
                                    });
                                });

                                // Shim `session.request()` in order to catch all streams
                                session[kRequest] = session.request;
                                session.request = (headers, streamOptions) => {
                                    if (session[kGracefullyClosing]) {
                                        throw new Error(
                                            "The session is gracefully closing. No new streams are allowed."
                                        );
                                    }

                                    const stream = session[kRequest](
                                        headers,
                                        streamOptions
                                    );

                                    // The process won't exit until the session is closed or all requests are gone.
                                    session.ref();

                                    ++session[kCurrentStreamsCount];

                                    if (
                                        session[kCurrentStreamsCount] ===
                                        session.remoteSettings
                                            .maxConcurrentStreams
                                    ) {
                                        this._freeSessionsCount--;
                                    }

                                    stream.once("close", () => {
                                        wasFree = isFree();

                                        --session[kCurrentStreamsCount];

                                        if (
                                            !session.destroyed &&
                                            !session.closed
                                        ) {
                                            closeSessionIfCovered(
                                                this.sessions[
                                                    normalizedOptions
                                                ],
                                                session
                                            );

                                            if (isFree() && !session.closed) {
                                                if (!wasFree) {
                                                    this._freeSessionsCount++;

                                                    wasFree = true;
                                                }

                                                const isEmpty =
                                                    session[
                                                        kCurrentStreamsCount
                                                    ] === 0;

                                                if (isEmpty) {
                                                    session.unref();
                                                }

                                                if (
                                                    isEmpty &&
                                                    (this._freeSessionsCount >
                                                        this.maxFreeSessions ||
                                                        session[
                                                            kGracefullyClosing
                                                        ])
                                                ) {
                                                    session.close();
                                                } else {
                                                    closeCoveredSessions(
                                                        this.sessions[
                                                            normalizedOptions
                                                        ],
                                                        session
                                                    );
                                                    processListeners();
                                                }
                                            }
                                        }
                                    });

                                    return stream;
                                };
                            } catch (error) {
                                for (const listener of listeners) {
                                    listener.reject(error);
                                }

                                removeFromQueue();
                            }
                        };

                        entry.listeners = listeners;
                        entry.completed = false;
                        entry.destroyed = false;

                        this.queue[normalizedOptions][normalizedOrigin] = entry;
                        this._tryToCreateNewSession(
                            normalizedOptions,
                            normalizedOrigin
                        );
                    });
                }

                request(origin, options, headers, streamOptions) {
                    return new Promise((resolve, reject) => {
                        this.getSession(origin, options, [
                            {
                                reject,
                                resolve: (session) => {
                                    try {
                                        resolve(
                                            session.request(
                                                headers,
                                                streamOptions
                                            )
                                        );
                                    } catch (error) {
                                        reject(error);
                                    }
                                },
                            },
                        ]);
                    });
                }

                createConnection(origin, options) {
                    return Agent.connect(origin, options);
                }

                static connect(origin, options) {
                    options.ALPNProtocols = ["h2"];

                    const port = origin.port || 443;
                    const host = origin.hostname || origin.host;

                    if (typeof options.servername === "undefined") {
                        options.servername = host;
                    }

                    return tls.connect(port, host, options);
                }

                closeFreeSessions() {
                    for (const sessions of Object.values(this.sessions)) {
                        for (const session of sessions) {
                            if (session[kCurrentStreamsCount] === 0) {
                                session.close();
                            }
                        }
                    }
                }

                destroy(reason) {
                    for (const sessions of Object.values(this.sessions)) {
                        for (const session of sessions) {
                            session.destroy(reason);
                        }
                    }

                    for (const entriesOfAuthority of Object.values(
                        this.queue
                    )) {
                        for (const entry of Object.values(entriesOfAuthority)) {
                            entry.destroyed = true;
                        }
                    }

                    // New requests should NOT attach to destroyed sessions
                    this.queue = {};
                }

                get freeSessions() {
                    return getSessions({ agent: this, isFree: true });
                }

                get busySessions() {
                    return getSessions({ agent: this, isFree: false });
                }
            }

            Agent.kCurrentStreamsCount = kCurrentStreamsCount;
            Agent.kGracefullyClosing = kGracefullyClosing;

            module.exports = {
                Agent,
                globalAgent: new Agent(),
            };

            /***/
        },

        /***/ 7167: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            "use strict";

            const http = __nccwpck_require__(8605);
            const https = __nccwpck_require__(7211);
            const resolveALPN = __nccwpck_require__(6624);
            const QuickLRU = __nccwpck_require__(9273);
            const Http2ClientRequest = __nccwpck_require__(9632);
            const calculateServerName = __nccwpck_require__(1982);
            const urlToOptions = __nccwpck_require__(2686);

            const cache = new QuickLRU({ maxSize: 100 });
            const queue = new Map();

            const installSocket = (agent, socket, options) => {
                socket._httpMessage = { shouldKeepAlive: true };

                const onFree = () => {
                    agent.emit("free", socket, options);
                };

                socket.on("free", onFree);

                const onClose = () => {
                    agent.removeSocket(socket, options);
                };

                socket.on("close", onClose);

                const onRemove = () => {
                    agent.removeSocket(socket, options);
                    socket.off("close", onClose);
                    socket.off("free", onFree);
                    socket.off("agentRemove", onRemove);
                };

                socket.on("agentRemove", onRemove);

                agent.emit("free", socket, options);
            };

            const resolveProtocol = async (options) => {
                const name = `${options.host}:${
                    options.port
                }:${options.ALPNProtocols.sort()}`;

                if (!cache.has(name)) {
                    if (queue.has(name)) {
                        const result = await queue.get(name);
                        return result.alpnProtocol;
                    }

                    const { path, agent } = options;
                    options.path = options.socketPath;

                    const resultPromise = resolveALPN(options);
                    queue.set(name, resultPromise);

                    try {
                        const { socket, alpnProtocol } = await resultPromise;
                        cache.set(name, alpnProtocol);

                        options.path = path;

                        if (alpnProtocol === "h2") {
                            // https://github.com/nodejs/node/issues/33343
                            socket.destroy();
                        } else {
                            const { globalAgent } = https;
                            const defaultCreateConnection =
                                https.Agent.prototype.createConnection;

                            if (agent) {
                                if (
                                    agent.createConnection ===
                                    defaultCreateConnection
                                ) {
                                    installSocket(agent, socket, options);
                                } else {
                                    socket.destroy();
                                }
                            } else if (
                                globalAgent.createConnection ===
                                defaultCreateConnection
                            ) {
                                installSocket(globalAgent, socket, options);
                            } else {
                                socket.destroy();
                            }
                        }

                        queue.delete(name);

                        return alpnProtocol;
                    } catch (error) {
                        queue.delete(name);

                        throw error;
                    }
                }

                return cache.get(name);
            };

            module.exports = async (input, options, callback) => {
                if (typeof input === "string" || input instanceof URL) {
                    input = urlToOptions(new URL(input));
                }

                if (typeof options === "function") {
                    callback = options;
                    options = undefined;
                }

                options = {
                    ALPNProtocols: ["h2", "http/1.1"],
                    ...input,
                    ...options,
                    resolveSocket: true,
                };

                if (
                    !Array.isArray(options.ALPNProtocols) ||
                    options.ALPNProtocols.length === 0
                ) {
                    throw new Error(
                        "The `ALPNProtocols` option must be an Array with at least one entry"
                    );
                }

                options.protocol = options.protocol || "https:";
                const isHttps = options.protocol === "https:";

                options.host = options.hostname || options.host || "localhost";
                options.session = options.tlsSession;
                options.servername =
                    options.servername || calculateServerName(options);
                options.port = options.port || (isHttps ? 443 : 80);
                options._defaultAgent = isHttps
                    ? https.globalAgent
                    : http.globalAgent;

                const agents = options.agent;

                if (agents) {
                    if (agents.addRequest) {
                        throw new Error(
                            "The `options.agent` object can contain only `http`, `https` or `http2` properties"
                        );
                    }

                    options.agent = agents[isHttps ? "https" : "http"];
                }

                if (isHttps) {
                    const protocol = await resolveProtocol(options);

                    if (protocol === "h2") {
                        if (agents) {
                            options.agent = agents.http2;
                        }

                        return new Http2ClientRequest(options, callback);
                    }
                }

                return http.request(options, callback);
            };

            module.exports.protocolCache = cache;

            /***/
        },

        /***/ 9632: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            "use strict";

            const http2 = __nccwpck_require__(7565);
            const { Writable } = __nccwpck_require__(2413);
            const { Agent, globalAgent } = __nccwpck_require__(9898);
            const IncomingMessage = __nccwpck_require__(2575);
            const urlToOptions = __nccwpck_require__(2686);
            const proxyEvents = __nccwpck_require__(1818);
            const isRequestPseudoHeader = __nccwpck_require__(1199);
            const {
                ERR_INVALID_ARG_TYPE,
                ERR_INVALID_PROTOCOL,
                ERR_HTTP_HEADERS_SENT,
                ERR_INVALID_HTTP_TOKEN,
                ERR_HTTP_INVALID_HEADER_VALUE,
                ERR_INVALID_CHAR,
            } = __nccwpck_require__(7087);

            const {
                HTTP2_HEADER_STATUS,
                HTTP2_HEADER_METHOD,
                HTTP2_HEADER_PATH,
                HTTP2_METHOD_CONNECT,
            } = http2.constants;

            const kHeaders = Symbol("headers");
            const kOrigin = Symbol("origin");
            const kSession = Symbol("session");
            const kOptions = Symbol("options");
            const kFlushedHeaders = Symbol("flushedHeaders");
            const kJobs = Symbol("jobs");

            const isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
            const isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;

            class ClientRequest extends Writable {
                constructor(input, options, callback) {
                    super({
                        autoDestroy: false,
                    });

                    const hasInput =
                        typeof input === "string" || input instanceof URL;
                    if (hasInput) {
                        input = urlToOptions(
                            input instanceof URL ? input : new URL(input)
                        );
                    }

                    if (
                        typeof options === "function" ||
                        options === undefined
                    ) {
                        // (options, callback)
                        callback = options;
                        options = hasInput ? input : { ...input };
                    } else {
                        // (input, options, callback)
                        options = { ...input, ...options };
                    }

                    if (options.h2session) {
                        this[kSession] = options.h2session;
                    } else if (options.agent === false) {
                        this.agent = new Agent({ maxFreeSessions: 0 });
                    } else if (
                        typeof options.agent === "undefined" ||
                        options.agent === null
                    ) {
                        if (typeof options.createConnection === "function") {
                            // This is a workaround - we don't have to create the session on our own.
                            this.agent = new Agent({ maxFreeSessions: 0 });
                            this.agent.createConnection =
                                options.createConnection;
                        } else {
                            this.agent = globalAgent;
                        }
                    } else if (typeof options.agent.request === "function") {
                        this.agent = options.agent;
                    } else {
                        throw new ERR_INVALID_ARG_TYPE(
                            "options.agent",
                            ["Agent-like Object", "undefined", "false"],
                            options.agent
                        );
                    }

                    if (options.protocol && options.protocol !== "https:") {
                        throw new ERR_INVALID_PROTOCOL(
                            options.protocol,
                            "https:"
                        );
                    }

                    const port =
                        options.port ||
                        options.defaultPort ||
                        (this.agent && this.agent.defaultPort) ||
                        443;
                    const host =
                        options.hostname || options.host || "localhost";

                    // Don't enforce the origin via options. It may be changed in an Agent.
                    delete options.hostname;
                    delete options.host;
                    delete options.port;

                    const { timeout } = options;
                    options.timeout = undefined;

                    this[kHeaders] = Object.create(null);
                    this[kJobs] = [];

                    this.socket = null;
                    this.connection = null;

                    this.method = options.method || "GET";
                    this.path = options.path;

                    this.res = null;
                    this.aborted = false;
                    this.reusedSocket = false;

                    if (options.headers) {
                        for (const [header, value] of Object.entries(
                            options.headers
                        )) {
                            this.setHeader(header, value);
                        }
                    }

                    if (options.auth && !("authorization" in this[kHeaders])) {
                        this[kHeaders].authorization =
                            "Basic " +
                            Buffer.from(options.auth).toString("base64");
                    }

                    options.session = options.tlsSession;
                    options.path = options.socketPath;

                    this[kOptions] = options;

                    // Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field.
                    if (port === 443) {
                        this[kOrigin] = `https://${host}`;

                        if (!(":authority" in this[kHeaders])) {
                            this[kHeaders][":authority"] = host;
                        }
                    } else {
                        this[kOrigin] = `https://${host}:${port}`;

                        if (!(":authority" in this[kHeaders])) {
                            this[kHeaders][":authority"] = `${host}:${port}`;
                        }
                    }

                    if (timeout) {
                        this.setTimeout(timeout);
                    }

                    if (callback) {
                        this.once("response", callback);
                    }

                    this[kFlushedHeaders] = false;
                }

                get method() {
                    return this[kHeaders][HTTP2_HEADER_METHOD];
                }

                set method(value) {
                    if (value) {
                        this[kHeaders][HTTP2_HEADER_METHOD] =
                            value.toUpperCase();
                    }
                }

                get path() {
                    return this[kHeaders][HTTP2_HEADER_PATH];
                }

                set path(value) {
                    if (value) {
                        this[kHeaders][HTTP2_HEADER_PATH] = value;
                    }
                }

                get _mustNotHaveABody() {
                    return (
                        this.method === "GET" ||
                        this.method === "HEAD" ||
                        this.method === "DELETE"
                    );
                }

                _write(chunk, encoding, callback) {
                    // https://github.com/nodejs/node/blob/654df09ae0c5e17d1b52a900a545f0664d8c7627/lib/internal/http2/util.js#L148-L156
                    if (this._mustNotHaveABody) {
                        callback(
                            new Error(
                                "The GET, HEAD and DELETE methods must NOT have a body"
                            )
                        );
                        /* istanbul ignore next: Node.js 12 throws directly */
                        return;
                    }

                    this.flushHeaders();

                    const callWrite = () =>
                        this._request.write(chunk, encoding, callback);
                    if (this._request) {
                        callWrite();
                    } else {
                        this[kJobs].push(callWrite);
                    }
                }

                _final(callback) {
                    if (this.destroyed) {
                        return;
                    }

                    this.flushHeaders();

                    const callEnd = () => {
                        // For GET, HEAD and DELETE
                        if (this._mustNotHaveABody) {
                            callback();
                            return;
                        }

                        this._request.end(callback);
                    };

                    if (this._request) {
                        callEnd();
                    } else {
                        this[kJobs].push(callEnd);
                    }
                }

                abort() {
                    if (this.res && this.res.complete) {
                        return;
                    }

                    if (!this.aborted) {
                        process.nextTick(() => this.emit("abort"));
                    }

                    this.aborted = true;

                    this.destroy();
                }

                _destroy(error, callback) {
                    if (this.res) {
                        this.res._dump();
                    }

                    if (this._request) {
                        this._request.destroy();
                    }

                    callback(error);
                }

                async flushHeaders() {
                    if (this[kFlushedHeaders] || this.destroyed) {
                        return;
                    }

                    this[kFlushedHeaders] = true;

                    const isConnectMethod =
                        this.method === HTTP2_METHOD_CONNECT;

                    // The real magic is here
                    const onStream = (stream) => {
                        this._request = stream;

                        if (this.destroyed) {
                            stream.destroy();
                            return;
                        }

                        // Forwards `timeout`, `continue`, `close` and `error` events to this instance.
                        if (!isConnectMethod) {
                            proxyEvents(stream, this, [
                                "timeout",
                                "continue",
                                "close",
                                "error",
                            ]);
                        }

                        // Wait for the `finish` event. We don't want to emit the `response` event
                        // before `request.end()` is called.
                        const waitForEnd = (fn) => {
                            return (...args) => {
                                if (!this.writable && !this.destroyed) {
                                    fn(...args);
                                } else {
                                    this.once("finish", () => {
                                        fn(...args);
                                    });
                                }
                            };
                        };

                        // This event tells we are ready to listen for the data.
                        stream.once(
                            "response",
                            waitForEnd((headers, flags, rawHeaders) => {
                                // If we were to emit raw request stream, it would be as fast as the native approach.
                                // Note that wrapping the raw stream in a Proxy instance won't improve the performance (already tested it).
                                const response = new IncomingMessage(
                                    this.socket,
                                    stream.readableHighWaterMark
                                );
                                this.res = response;

                                response.req = this;
                                response.statusCode =
                                    headers[HTTP2_HEADER_STATUS];
                                response.headers = headers;
                                response.rawHeaders = rawHeaders;

                                response.once("end", () => {
                                    if (this.aborted) {
                                        response.aborted = true;
                                        response.emit("aborted");
                                    } else {
                                        response.complete = true;

                                        // Has no effect, just be consistent with the Node.js behavior
                                        response.socket = null;
                                        response.connection = null;
                                    }
                                });

                                if (isConnectMethod) {
                                    response.upgrade = true;

                                    // The HTTP1 API says the socket is detached here,
                                    // but we can't do that so we pass the original HTTP2 request.
                                    if (
                                        this.emit(
                                            "connect",
                                            response,
                                            stream,
                                            Buffer.alloc(0)
                                        )
                                    ) {
                                        this.emit("close");
                                    } else {
                                        // No listeners attached, destroy the original request.
                                        stream.destroy();
                                    }
                                } else {
                                    // Forwards data
                                    stream.on("data", (chunk) => {
                                        if (
                                            !response._dumped &&
                                            !response.push(chunk)
                                        ) {
                                            stream.pause();
                                        }
                                    });

                                    stream.once("end", () => {
                                        response.push(null);
                                    });

                                    if (!this.emit("response", response)) {
                                        // No listeners attached, dump the response.
                                        response._dump();
                                    }
                                }
                            })
                        );

                        // Emits `information` event
                        stream.once(
                            "headers",
                            waitForEnd((headers) =>
                                this.emit("information", {
                                    statusCode: headers[HTTP2_HEADER_STATUS],
                                })
                            )
                        );

                        stream.once(
                            "trailers",
                            waitForEnd((trailers, flags, rawTrailers) => {
                                const { res } = this;

                                // Assigns trailers to the response object.
                                res.trailers = trailers;
                                res.rawTrailers = rawTrailers;
                            })
                        );

                        const { socket } = stream.session;
                        this.socket = socket;
                        this.connection = socket;

                        for (const job of this[kJobs]) {
                            job();
                        }

                        this.emit("socket", this.socket);
                    };

                    // Makes a HTTP2 request
                    if (this[kSession]) {
                        try {
                            onStream(this[kSession].request(this[kHeaders]));
                        } catch (error) {
                            this.emit("error", error);
                        }
                    } else {
                        this.reusedSocket = true;

                        try {
                            onStream(
                                await this.agent.request(
                                    this[kOrigin],
                                    this[kOptions],
                                    this[kHeaders]
                                )
                            );
                        } catch (error) {
                            this.emit("error", error);
                        }
                    }
                }

                getHeader(name) {
                    if (typeof name !== "string") {
                        throw new ERR_INVALID_ARG_TYPE("name", "string", name);
                    }

                    return this[kHeaders][name.toLowerCase()];
                }

                get headersSent() {
                    return this[kFlushedHeaders];
                }

                removeHeader(name) {
                    if (typeof name !== "string") {
                        throw new ERR_INVALID_ARG_TYPE("name", "string", name);
                    }

                    if (this.headersSent) {
                        throw new ERR_HTTP_HEADERS_SENT("remove");
                    }

                    delete this[kHeaders][name.toLowerCase()];
                }

                setHeader(name, value) {
                    if (this.headersSent) {
                        throw new ERR_HTTP_HEADERS_SENT("set");
                    }

                    if (
                        typeof name !== "string" ||
                        (!isValidHttpToken.test(name) &&
                            !isRequestPseudoHeader(name))
                    ) {
                        throw new ERR_INVALID_HTTP_TOKEN("Header name", name);
                    }

                    if (typeof value === "undefined") {
                        throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
                    }

                    if (isInvalidHeaderValue.test(value)) {
                        throw new ERR_INVALID_CHAR("header content", name);
                    }

                    this[kHeaders][name.toLowerCase()] = value;
                }

                setNoDelay() {
                    // HTTP2 sockets cannot be malformed, do nothing.
                }

                setSocketKeepAlive() {
                    // HTTP2 sockets cannot be malformed, do nothing.
                }

                setTimeout(ms, callback) {
                    const applyTimeout = () =>
                        this._request.setTimeout(ms, callback);

                    if (this._request) {
                        applyTimeout();
                    } else {
                        this[kJobs].push(applyTimeout);
                    }

                    return this;
                }

                get maxHeadersCount() {
                    if (!this.destroyed && this._request) {
                        return this._request.session.localSettings
                            .maxHeaderListSize;
                    }

                    return undefined;
                }

                set maxHeadersCount(_value) {
                    // Updating HTTP2 settings would affect all requests, do nothing.
                }
            }

            module.exports = ClientRequest;

            /***/
        },

        /***/ 2575: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            "use strict";

            const { Readable } = __nccwpck_require__(2413);

            class IncomingMessage extends Readable {
                constructor(socket, highWaterMark) {
                    super({
                        highWaterMark,
                        autoDestroy: false,
                    });

                    this.statusCode = null;
                    this.statusMessage = "";
                    this.httpVersion = "2.0";
                    this.httpVersionMajor = 2;
                    this.httpVersionMinor = 0;
                    this.headers = {};
                    this.trailers = {};
                    this.req = null;

                    this.aborted = false;
                    this.complete = false;
                    this.upgrade = null;

                    this.rawHeaders = [];
                    this.rawTrailers = [];

                    this.socket = socket;
                    this.connection = socket;

                    this._dumped = false;
                }

                _destroy(error) {
                    this.req._request.destroy(error);
                }

                setTimeout(ms, callback) {
                    this.req.setTimeout(ms, callback);
                    return this;
                }

                _dump() {
                    if (!this._dumped) {
                        this._dumped = true;

                        this.removeAllListeners("data");
                        this.resume();
                    }
                }

                _read() {
                    if (this.req) {
                        this.req._request.resume();
                    }
                }
            }

            module.exports = IncomingMessage;

            /***/
        },

        /***/ 4645: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            "use strict";

            const http2 = __nccwpck_require__(7565);
            const agent = __nccwpck_require__(9898);
            const ClientRequest = __nccwpck_require__(9632);
            const IncomingMessage = __nccwpck_require__(2575);
            const auto = __nccwpck_require__(7167);

            const request = (url, options, callback) => {
                return new ClientRequest(url, options, callback);
            };

            const get = (url, options, callback) => {
                // eslint-disable-next-line unicorn/prevent-abbreviations
                const req = new ClientRequest(url, options, callback);
                req.end();

                return req;
            };

            module.exports = {
                ...http2,
                ClientRequest,
                IncomingMessage,
                ...agent,
                request,
                get,
                auto,
            };

            /***/
        },

        /***/ 1982: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            "use strict";

            const net = __nccwpck_require__(1631);
            /* istanbul ignore file: https://github.com/nodejs/node/blob/v13.0.1/lib/_http_agent.js */

            module.exports = (options) => {
                let servername = options.host;
                const hostHeader = options.headers && options.headers.host;

                if (hostHeader) {
                    if (hostHeader.startsWith("[")) {
                        const index = hostHeader.indexOf("]");
                        if (index === -1) {
                            servername = hostHeader;
                        } else {
                            servername = hostHeader.slice(1, -1);
                        }
                    } else {
                        servername = hostHeader.split(":", 1)[0];
                    }
                }

                if (net.isIP(servername)) {
                    return "";
                }

                return servername;
            };

            /***/
        },

        /***/ 7087: /***/ (module) => {
            "use strict";

            /* istanbul ignore file: https://github.com/nodejs/node/blob/master/lib/internal/errors.js */

            const makeError = (Base, key, getMessage) => {
                module.exports[key] = class NodeError extends Base {
                    constructor(...args) {
                        super(
                            typeof getMessage === "string"
                                ? getMessage
                                : getMessage(args)
                        );
                        this.name = `${super.name} [${key}]`;
                        this.code = key;
                    }
                };
            };

            makeError(TypeError, "ERR_INVALID_ARG_TYPE", (args) => {
                const type = args[0].includes(".") ? "property" : "argument";

                let valid = args[1];
                const isManyTypes = Array.isArray(valid);

                if (isManyTypes) {
                    valid = `${valid.slice(0, -1).join(", ")} or ${valid.slice(
                        -1
                    )}`;
                }

                return `The "${args[0]}" ${type} must be ${
                    isManyTypes ? "one of" : "of"
                } type ${valid}. Received ${typeof args[2]}`;
            });

            makeError(TypeError, "ERR_INVALID_PROTOCOL", (args) => {
                return `Protocol "${args[0]}" not supported. Expected "${args[1]}"`;
            });

            makeError(Error, "ERR_HTTP_HEADERS_SENT", (args) => {
                return `Cannot ${args[0]} headers after they are sent to the client`;
            });

            makeError(TypeError, "ERR_INVALID_HTTP_TOKEN", (args) => {
                return `${args[0]} must be a valid HTTP token [${args[1]}]`;
            });

            makeError(TypeError, "ERR_HTTP_INVALID_HEADER_VALUE", (args) => {
                return `Invalid value "${args[0]} for header "${args[1]}"`;
            });

            makeError(TypeError, "ERR_INVALID_CHAR", (args) => {
                return `Invalid character in ${args[0]} [${args[1]}]`;
            });

            /***/
        },

        /***/ 1199: /***/ (module) => {
            "use strict";

            module.exports = (header) => {
                switch (header) {
                    case ":method":
                    case ":scheme":
                    case ":authority":
                    case ":path":
                        return true;
                    default:
                        return false;
                }
            };

            /***/
        },

        /***/ 1818: /***/ (module) => {
            "use strict";

            module.exports = (from, to, events) => {
                for (const event of events) {
                    from.on(event, (...args) => to.emit(event, ...args));
                }
            };

            /***/
        },

        /***/ 2686: /***/ (module) => {
            "use strict";

            /* istanbul ignore file: https://github.com/nodejs/node/blob/a91293d4d9ab403046ab5eb022332e4e3d249bd3/lib/internal/url.js#L1257 */

            module.exports = (url) => {
                const options = {
                    protocol: url.protocol,
                    hostname:
                        typeof url.hostname === "string" &&
                        url.hostname.startsWith("[")
                            ? url.hostname.slice(1, -1)
                            : url.hostname,
                    host: url.host,
                    hash: url.hash,
                    search: url.search,
                    pathname: url.pathname,
                    href: url.href,
                    path: `${url.pathname || ""}${url.search || ""}`,
                };

                if (typeof url.port === "string" && url.port.length !== 0) {
                    options.port = Number(url.port);
                }

                if (url.username || url.password) {
                    options.auth = `${url.username || ""}:${
                        url.password || ""
                    }`;
                }

                return options;
            };

            /***/
        },

        /***/ 3287: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });

            /*!
             * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
             *
             * Copyright (c) 2014-2017, Jon Schlinkert.
             * Released under the MIT License.
             */

            function isObject(o) {
                return Object.prototype.toString.call(o) === "[object Object]";
            }

            function isPlainObject(o) {
                var ctor, prot;

                if (isObject(o) === false) return false;

                // If has modified constructor
                ctor = o.constructor;
                if (ctor === undefined) return true;

                // If has modified prototype
                prot = ctor.prototype;
                if (isObject(prot) === false) return false;

                // If constructor does not have an Object-specific method
                if (prot.hasOwnProperty("isPrototypeOf") === false) {
                    return false;
                }

                // Most likely a plain Object
                return true;
            }

            exports.isPlainObject = isPlainObject;

            /***/
        },

        /***/ 3466: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            /**
             * Stringify an array of values.
             */
            exports.arrayToString = (array, space, next) => {
                // Map array values to their stringified values with correct indentation.
                const values = array
                    .map(function (value, index) {
                        const result = next(value, index);
                        if (result === undefined) return String(result);
                        return space + result.split("\n").join(`\n${space}`);
                    })
                    .join(space ? ",\n" : ",");
                const eol = space && values ? "\n" : "";
                return `[${eol}${values}${eol}]`;
            };
            //# sourceMappingURL=array.js.map

            /***/
        },

        /***/ 2711: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            const quote_1 = __nccwpck_require__(9121);
            /**
             * Used in function stringification.
             */
            /* istanbul ignore next */
            const METHOD_NAMES_ARE_QUOTED =
                {
                    " "() {
                        /* Empty. */
                    },
                }[" "]
                    .toString()
                    .charAt(0) === '"';
            const FUNCTION_PREFIXES = {
                Function: "function ",
                GeneratorFunction: "function* ",
                AsyncFunction: "async function ",
                AsyncGeneratorFunction: "async function* ",
            };
            const METHOD_PREFIXES = {
                Function: "",
                GeneratorFunction: "*",
                AsyncFunction: "async ",
                AsyncGeneratorFunction: "async *",
            };
            const TOKENS_PRECEDING_REGEXPS = new Set(
                (
                    "case delete else in instanceof new return throw typeof void " +
                    ", ; : + - ! ~ & | ^ * / % < > ? ="
                ).split(" ")
            );
            /**
             * Track function parser usage.
             */
            exports.USED_METHOD_KEY = new WeakSet();
            /**
             * Stringify a function.
             */
            exports.functionToString = (fn, space, next, key) => {
                const name = typeof key === "string" ? key : undefined;
                // Track in function parser for object stringify to avoid duplicate output.
                if (name !== undefined) exports.USED_METHOD_KEY.add(fn);
                return new FunctionParser(fn, space, next, name).stringify();
            };
            /**
             * Rewrite a stringified function to remove initial indentation.
             */
            function dedentFunction(fnString) {
                let found;
                for (const line of fnString.split("\n").slice(1)) {
                    const m = /^[\s\t]+/.exec(line);
                    if (!m) return fnString; // Early exit without indent.
                    const [str] = m;
                    if (found === undefined) found = str;
                    else if (str.length < found.length) found = str;
                }
                return found
                    ? fnString.split(`\n${found}`).join("\n")
                    : fnString;
            }
            exports.dedentFunction = dedentFunction;
            /**
             * Function parser and stringify.
             */
            class FunctionParser {
                constructor(fn, indent, next, key) {
                    this.fn = fn;
                    this.indent = indent;
                    this.next = next;
                    this.key = key;
                    this.pos = 0;
                    this.hadKeyword = false;
                    this.fnString = Function.prototype.toString.call(fn);
                    this.fnType = fn.constructor.name;
                    this.keyQuote =
                        key === undefined ? "" : quote_1.quoteKey(key, next);
                    this.keyPrefix =
                        key === undefined
                            ? ""
                            : `${this.keyQuote}:${indent ? " " : ""}`;
                    this.isMethodCandidate =
                        key === undefined
                            ? false
                            : this.fn.name === "" || this.fn.name === key;
                }
                stringify() {
                    const value = this.tryParse();
                    // If we can't stringify this function, return a void expression; for
                    // bonus help with debugging, include the function as a string literal.
                    if (!value) {
                        return `${this.keyPrefix}void ${this.next(
                            this.fnString
                        )}`;
                    }
                    return dedentFunction(value);
                }
                getPrefix() {
                    if (this.isMethodCandidate && !this.hadKeyword) {
                        return METHOD_PREFIXES[this.fnType] + this.keyQuote;
                    }
                    return this.keyPrefix + FUNCTION_PREFIXES[this.fnType];
                }
                tryParse() {
                    if (this.fnString[this.fnString.length - 1] !== "}") {
                        // Must be an arrow function.
                        return this.keyPrefix + this.fnString;
                    }
                    // Attempt to remove function prefix.
                    if (this.fn.name) {
                        const result = this.tryStrippingName();
                        if (result) return result;
                    }
                    // Support class expressions.
                    const prevPos = this.pos;
                    if (this.consumeSyntax() === "class") return this.fnString;
                    this.pos = prevPos;
                    if (this.tryParsePrefixTokens()) {
                        const result = this.tryStrippingName();
                        if (result) return result;
                        let offset = this.pos;
                        switch (this.consumeSyntax("WORD_LIKE")) {
                            case "WORD_LIKE":
                                if (
                                    this.isMethodCandidate &&
                                    !this.hadKeyword
                                ) {
                                    offset = this.pos;
                                }
                            // tslint:disable-next-line no-switch-case-fall-through
                            case "()":
                                if (
                                    this.fnString.substr(this.pos, 2) === "=>"
                                ) {
                                    return this.keyPrefix + this.fnString;
                                }
                                this.pos = offset;
                            // tslint:disable-next-line no-switch-case-fall-through
                            case '"':
                            case "'":
                            case "[]":
                                return (
                                    this.getPrefix() +
                                    this.fnString.substr(this.pos)
                                );
                        }
                    }
                }
                /**
                 * Attempt to parse the function from the current position by first stripping
                 * the function's name from the front. This is not a fool-proof method on all
                 * JavaScript engines, but yields good results on Node.js 4 (and slightly
                 * less good results on Node.js 6 and 8).
                 */
                tryStrippingName() {
                    if (METHOD_NAMES_ARE_QUOTED) {
                        // ... then this approach is unnecessary and yields false positives.
                        return;
                    }
                    let start = this.pos;
                    const prefix = this.fnString.substr(
                        this.pos,
                        this.fn.name.length
                    );
                    if (prefix === this.fn.name) {
                        this.pos += prefix.length;
                        if (
                            this.consumeSyntax() === "()" &&
                            this.consumeSyntax() === "{}" &&
                            this.pos === this.fnString.length
                        ) {
                            // Don't include the function's name if it will be included in the
                            // prefix, or if it's invalid as a name in a function expression.
                            if (
                                this.isMethodCandidate ||
                                !quote_1.isValidVariableName(prefix)
                            ) {
                                start += prefix.length;
                            }
                            return (
                                this.getPrefix() + this.fnString.substr(start)
                            );
                        }
                    }
                    this.pos = start;
                }
                /**
                 * Attempt to advance the parser past the keywords expected to be at the
                 * start of this function's definition. This method sets `this.hadKeyword`
                 * based on whether or not a `function` keyword is consumed.
                 *
                 * @return {boolean}
                 */
                tryParsePrefixTokens() {
                    let posPrev = this.pos;
                    this.hadKeyword = false;
                    switch (this.fnType) {
                        case "AsyncFunction":
                            if (this.consumeSyntax() !== "async") return false;
                            posPrev = this.pos;
                        // tslint:disable-next-line no-switch-case-fall-through
                        case "Function":
                            if (this.consumeSyntax() === "function") {
                                this.hadKeyword = true;
                            } else {
                                this.pos = posPrev;
                            }
                            return true;
                        case "AsyncGeneratorFunction":
                            if (this.consumeSyntax() !== "async") return false;
                        // tslint:disable-next-line no-switch-case-fall-through
                        case "GeneratorFunction":
                            let token = this.consumeSyntax();
                            if (token === "function") {
                                token = this.consumeSyntax();
                                this.hadKeyword = true;
                            }
                            return token === "*";
                    }
                }
                /**
                 * Advance the parser past one element of JavaScript syntax. This could be a
                 * matched pair of delimiters, like braces or parentheses, or an atomic unit
                 * like a keyword, variable, or operator. Return a normalized string
                 * representation of the element parsed--for example, returns '{}' for a
                 * matched pair of braces. Comments and whitespace are skipped.
                 *
                 * (This isn't a full parser, so the token scanning logic used here is as
                 * simple as it can be. As a consequence, some things that are one token in
                 * JavaScript, like decimal number literals or most multicharacter operators
                 * like '&&', are split into more than one token here. However, awareness of
                 * some multicharacter sequences like '=>' is necessary, so we match the few
                 * of them that we care about.)
                 */
                consumeSyntax(wordLikeToken) {
                    const m = this.consumeMatch(
                        /^(?:([A-Za-z_0-9$\xA0-\uFFFF]+)|=>|\+\+|\-\-|.)/
                    );
                    if (!m) return;
                    const [token, match] = m;
                    this.consumeWhitespace();
                    if (match) return wordLikeToken || match;
                    switch (token) {
                        case "(":
                            return this.consumeSyntaxUntil("(", ")");
                        case "[":
                            return this.consumeSyntaxUntil("[", "]");
                        case "{":
                            return this.consumeSyntaxUntil("{", "}");
                        case "`":
                            return this.consumeTemplate();
                        case '"':
                            return this.consumeRegExp(/^(?:[^\\"]|\\.)*"/, '"');
                        case "'":
                            return this.consumeRegExp(/^(?:[^\\']|\\.)*'/, "'");
                    }
                    return token;
                }
                consumeSyntaxUntil(startToken, endToken) {
                    let isRegExpAllowed = true;
                    for (;;) {
                        const token = this.consumeSyntax();
                        if (token === endToken) return startToken + endToken;
                        if (
                            !token ||
                            token === ")" ||
                            token === "]" ||
                            token === "}"
                        )
                            return;
                        if (
                            token === "/" &&
                            isRegExpAllowed &&
                            this.consumeMatch(
                                /^(?:\\.|[^\\\/\n[]|\[(?:\\.|[^\]])*\])+\/[a-z]*/
                            )
                        ) {
                            isRegExpAllowed = false;
                            this.consumeWhitespace();
                        } else {
                            isRegExpAllowed =
                                TOKENS_PRECEDING_REGEXPS.has(token);
                        }
                    }
                }
                consumeMatch(re) {
                    const m = re.exec(this.fnString.substr(this.pos));
                    if (m) this.pos += m[0].length;
                    return m;
                }
                /**
                 * Advance the parser past an arbitrary regular expression. Return `token`,
                 * or the match object of the regexp.
                 */
                consumeRegExp(re, token) {
                    const m = re.exec(this.fnString.substr(this.pos));
                    if (!m) return;
                    this.pos += m[0].length;
                    this.consumeWhitespace();
                    return token;
                }
                /**
                 * Advance the parser past a template string.
                 */
                consumeTemplate() {
                    for (;;) {
                        this.consumeMatch(/^(?:[^`$\\]|\\.|\$(?!{))*/);
                        if (this.fnString[this.pos] === "`") {
                            this.pos++;
                            this.consumeWhitespace();
                            return "`";
                        }
                        if (this.fnString.substr(this.pos, 2) === "${") {
                            this.pos += 2;
                            this.consumeWhitespace();
                            if (this.consumeSyntaxUntil("{", "}")) continue;
                        }
                        return;
                    }
                }
                /**
                 * Advance the parser past any whitespace or comments.
                 */
                consumeWhitespace() {
                    this.consumeMatch(/^(?:\s|\/\/.*|\/\*[^]*?\*\/)*/);
                }
            }
            exports.FunctionParser = FunctionParser;
            //# sourceMappingURL=function.js.map

            /***/
        },

        /***/ 5816: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            const stringify_1 = __nccwpck_require__(1662);
            const quote_1 = __nccwpck_require__(9121);
            /**
             * Root path node.
             */
            const ROOT_SENTINEL = Symbol("root");
            /**
             * Stringify any JavaScript value.
             */
            function stringify(value, replacer, indent, options = {}) {
                const space =
                    typeof indent === "string"
                        ? indent
                        : " ".repeat(indent || 0);
                const path = [];
                const stack = new Set();
                const tracking = new Map();
                const unpack = new Map();
                let valueCount = 0;
                const {
                    maxDepth = 100,
                    references = false,
                    skipUndefinedProperties = false,
                    maxValues = 100000,
                } = options;
                // Wrap replacer function to support falling back on supported stringify.
                const valueToString = replacerToString(replacer);
                // Every time you call `next(value)` execute this function.
                const onNext = (value, key) => {
                    if (++valueCount > maxValues) return;
                    if (skipUndefinedProperties && value === undefined) return;
                    if (path.length > maxDepth) return;
                    // An undefined key is treated as an out-of-band "value".
                    if (key === undefined)
                        return valueToString(value, space, onNext, key);
                    path.push(key);
                    const result = builder(
                        value,
                        key === ROOT_SENTINEL ? undefined : key
                    );
                    path.pop();
                    return result;
                };
                const builder = references
                    ? (value, key) => {
                          if (
                              value !== null &&
                              (typeof value === "object" ||
                                  typeof value === "function" ||
                                  typeof value === "symbol")
                          ) {
                              // Track nodes to restore later.
                              if (tracking.has(value)) {
                                  unpack.set(
                                      path.slice(1),
                                      tracking.get(value)
                                  );
                                  return; // Avoid serializing referenced nodes on an expression.
                              }
                              // Track encountered nodes.
                              tracking.set(value, path.slice(1));
                          }
                          return valueToString(value, space, onNext, key);
                      }
                    : (value, key) => {
                          // Stop on recursion.
                          if (stack.has(value)) return;
                          stack.add(value);
                          const result = valueToString(
                              value,
                              space,
                              onNext,
                              key
                          );
                          stack.delete(value);
                          return result;
                      };
                const result = onNext(value, ROOT_SENTINEL);
                // Attempt to restore circular references.
                if (unpack.size) {
                    const sp = space ? " " : "";
                    const eol = space ? "\n" : "";
                    let wrapper = `var x${sp}=${sp}${result};${eol}`;
                    for (const [key, value] of unpack.entries()) {
                        const keyPath = quote_1.stringifyPath(key, onNext);
                        const valuePath = quote_1.stringifyPath(value, onNext);
                        wrapper += `x${keyPath}${sp}=${sp}x${valuePath};${eol}`;
                    }
                    return `(function${sp}()${sp}{${eol}${wrapper}return x;${eol}}())`;
                }
                return result;
            }
            exports.stringify = stringify;
            /**
             * Create `toString()` function from replacer.
             */
            function replacerToString(replacer) {
                if (!replacer) return stringify_1.toString;
                return (value, space, next, key) => {
                    return replacer(
                        value,
                        space,
                        (value) =>
                            stringify_1.toString(value, space, next, key),
                        key
                    );
                };
            }
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ 5810: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            const quote_1 = __nccwpck_require__(9121);
            const function_1 = __nccwpck_require__(2711);
            const array_1 = __nccwpck_require__(3466);
            /**
             * Transform an object into a string.
             */
            exports.objectToString = (value, space, next, key) => {
                if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
                    return `new Buffer(${next(value.toString())})`;
                }
                // Use the internal object string to select stringify method.
                const toString =
                    OBJECT_TYPES[Object.prototype.toString.call(value)];
                return toString ? toString(value, space, next, key) : undefined;
            };
            /**
             * Stringify an object of keys and values.
             */
            const rawObjectToString = (obj, indent, next) => {
                const eol = indent ? "\n" : "";
                const space = indent ? " " : "";
                // Iterate over object keys and concat string together.
                const values = Object.keys(obj)
                    .reduce(function (values, key) {
                        const fn = obj[key];
                        const result = next(fn, key);
                        // Omit `undefined` object entries.
                        if (result === undefined) return values;
                        // String format the value data.
                        const value = result.split("\n").join(`\n${indent}`);
                        // Skip `key` prefix for function parser.
                        if (function_1.USED_METHOD_KEY.has(fn)) {
                            values.push(`${indent}${value}`);
                            return values;
                        }
                        values.push(
                            `${indent}${quote_1.quoteKey(
                                key,
                                next
                            )}:${space}${value}`
                        );
                        return values;
                    }, [])
                    .join(`,${eol}`);
                // Avoid new lines in an empty object.
                if (values === "") return "{}";
                return `{${eol}${values}${eol}}`;
            };
            /**
             * Stringify global variable access.
             */
            const globalToString = (value, space, next) => {
                return `Function(${next("return this")})()`;
            };
            /**
             * Convert JavaScript objects into strings.
             */
            const OBJECT_TYPES = {
                "[object Array]": array_1.arrayToString,
                "[object Object]": rawObjectToString,
                "[object Error]": (error, space, next) => {
                    return `new Error(${next(error.message)})`;
                },
                "[object Date]": (date) => {
                    return `new Date(${date.getTime()})`;
                },
                "[object String]": (str, space, next) => {
                    return `new String(${next(str.toString())})`;
                },
                "[object Number]": (num) => {
                    return `new Number(${num})`;
                },
                "[object Boolean]": (bool) => {
                    return `new Boolean(${bool})`;
                },
                "[object Set]": (set, space, next) => {
                    return `new Set(${next(Array.from(set))})`;
                },
                "[object Map]": (map, space, next) => {
                    return `new Map(${next(Array.from(map))})`;
                },
                "[object RegExp]": String,
                "[object global]": globalToString,
                "[object Window]": globalToString,
            };
            //# sourceMappingURL=object.js.map

            /***/
        },

        /***/ 9121: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            /**
             * Match all characters that need to be escaped in a string. Modified from
             * source to match single quotes instead of double.
             *
             * Source: https://github.com/douglascrockford/JSON-js/blob/master/json2.js
             */
            const ESCAPABLE =
                /[\\\'\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
            /**
             * Map of characters to escape characters.
             */
            const META_CHARS = new Map([
                ["\b", "\\b"],
                ["\t", "\\t"],
                ["\n", "\\n"],
                ["\f", "\\f"],
                ["\r", "\\r"],
                ["'", "\\'"],
                ['"', '\\"'],
                ["\\", "\\\\"],
            ]);
            /**
             * Escape any character into its literal JavaScript string.
             *
             * @param  {string} char
             * @return {string}
             */
            function escapeChar(char) {
                return (
                    META_CHARS.get(char) ||
                    `\\u${`0000${char.charCodeAt(0).toString(16)}`.slice(-4)}`
                );
            }
            /**
             * Quote a string.
             */
            function quoteString(str) {
                return `'${str.replace(ESCAPABLE, escapeChar)}'`;
            }
            exports.quoteString = quoteString;
            /**
             * JavaScript reserved keywords.
             */
            const RESERVED_WORDS = new Set(
                (
                    "break else new var case finally return void catch for switch while " +
                    "continue function this with default if throw delete in try " +
                    "do instanceof typeof abstract enum int short boolean export " +
                    "interface static byte extends long super char final native synchronized " +
                    "class float package throws const goto private transient debugger " +
                    "implements protected volatile double import public let yield"
                ).split(" ")
            );
            /**
             * Test for valid JavaScript identifier.
             */
            exports.IS_VALID_IDENTIFIER = /^[A-Za-z_$][A-Za-z0-9_$]*$/;
            /**
             * Check if a variable name is valid.
             */
            function isValidVariableName(name) {
                return (
                    typeof name === "string" &&
                    !RESERVED_WORDS.has(name) &&
                    exports.IS_VALID_IDENTIFIER.test(name)
                );
            }
            exports.isValidVariableName = isValidVariableName;
            /**
             * Quote JavaScript key access.
             */
            function quoteKey(key, next) {
                return isValidVariableName(key) ? key : next(key);
            }
            exports.quoteKey = quoteKey;
            /**
             * Serialize the path to a string.
             */
            function stringifyPath(path, next) {
                let result = "";
                for (const key of path) {
                    if (isValidVariableName(key)) {
                        result += `.${key}`;
                    } else {
                        result += `[${next(key)}]`;
                    }
                }
                return result;
            }
            exports.stringifyPath = stringifyPath;
            //# sourceMappingURL=quote.js.map

            /***/
        },

        /***/ 1662: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            const quote_1 = __nccwpck_require__(9121);
            const object_1 = __nccwpck_require__(5810);
            const function_1 = __nccwpck_require__(2711);
            /**
             * Stringify primitive values.
             */
            const PRIMITIVE_TYPES = {
                string: quote_1.quoteString,
                number: (value) =>
                    Object.is(value, -0) ? "-0" : String(value),
                boolean: String,
                symbol: (value, space, next) => {
                    const key = Symbol.keyFor(value);
                    if (key !== undefined) return `Symbol.for(${next(key)})`;
                    // ES2018 `Symbol.description`.
                    return `Symbol(${next(value.description)})`;
                },
                bigint: (value, space, next) => {
                    return `BigInt(${next(String(value))})`;
                },
                undefined: String,
                object: object_1.objectToString,
                function: function_1.functionToString,
            };
            /**
             * Stringify a value recursively.
             */
            exports.toString = (value, space, next, key) => {
                if (value === null) return "null";
                return PRIMITIVE_TYPES[typeof value](value, space, next, key);
            };
            //# sourceMappingURL=stringify.js.map

            /***/
        },

        /***/ 2820: /***/ (__unused_webpack_module, exports) => {
            //TODO: handle reviver/dehydrate function like normal
            //and handle indentation, like normal.
            //if anyone needs this... please send pull request.

            exports.stringify = function stringify(o) {
                if ("undefined" == typeof o) return o;

                if (o && Buffer.isBuffer(o))
                    return JSON.stringify(":base64:" + o.toString("base64"));

                if (o && o.toJSON) o = o.toJSON();

                if (o && "object" === typeof o) {
                    var s = "";
                    var array = Array.isArray(o);
                    s = array ? "[" : "{";
                    var first = true;

                    for (var k in o) {
                        var ignore =
                            "function" == typeof o[k] ||
                            (!array && "undefined" === typeof o[k]);
                        if (Object.hasOwnProperty.call(o, k) && !ignore) {
                            if (!first) s += ",";
                            first = false;
                            if (array) {
                                if (o[k] == undefined) s += "null";
                                else s += stringify(o[k]);
                            } else if (o[k] !== void 0) {
                                s += stringify(k) + ":" + stringify(o[k]);
                            }
                        }
                    }

                    s += array ? "]" : "}";

                    return s;
                } else if ("string" === typeof o) {
                    return JSON.stringify(/^:/.test(o) ? ":" + o : o);
                } else if ("undefined" === typeof o) {
                    return "null";
                } else return JSON.stringify(o);
            };

            exports.parse = function (s) {
                return JSON.parse(s, function (key, value) {
                    if ("string" === typeof value) {
                        if (/^:base64:/.test(value))
                            return Buffer.from(value.substring(8), "base64");
                        else
                            return /^:/.test(value)
                                ? value.substring(1)
                                : value;
                    }
                    return value;
                });
            };

            /***/
        },

        /***/ 1531: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            "use strict";

            const EventEmitter = __nccwpck_require__(8614);
            const JSONB = __nccwpck_require__(2820);

            const loadStore = (opts) => {
                const adapters = {
                    redis: "@keyv/redis",
                    mongodb: "@keyv/mongo",
                    mongo: "@keyv/mongo",
                    sqlite: "@keyv/sqlite",
                    postgresql: "@keyv/postgres",
                    postgres: "@keyv/postgres",
                    mysql: "@keyv/mysql",
                };
                if (opts.adapter || opts.uri) {
                    const adapter = opts.adapter || /^[^:]*/.exec(opts.uri)[0];
                    return new (require(adapters[adapter]))(opts);
                }

                return new Map();
            };

            class Keyv extends EventEmitter {
                constructor(uri, opts) {
                    super();
                    this.opts = Object.assign(
                        {
                            namespace: "keyv",
                            serialize: JSONB.stringify,
                            deserialize: JSONB.parse,
                        },
                        typeof uri === "string" ? { uri } : uri,
                        opts
                    );

                    if (!this.opts.store) {
                        const adapterOpts = Object.assign({}, this.opts);
                        this.opts.store = loadStore(adapterOpts);
                    }

                    if (typeof this.opts.store.on === "function") {
                        this.opts.store.on("error", (err) =>
                            this.emit("error", err)
                        );
                    }

                    this.opts.store.namespace = this.opts.namespace;
                }

                _getKeyPrefix(key) {
                    return `${this.opts.namespace}:${key}`;
                }

                get(key, opts) {
                    const keyPrefixed = this._getKeyPrefix(key);
                    const { store } = this.opts;
                    return Promise.resolve()
                        .then(() => store.get(keyPrefixed))
                        .then((data) => {
                            return typeof data === "string"
                                ? this.opts.deserialize(data)
                                : data;
                        })
                        .then((data) => {
                            if (data === undefined) {
                                return undefined;
                            }

                            if (
                                typeof data.expires === "number" &&
                                Date.now() > data.expires
                            ) {
                                this.delete(key);
                                return undefined;
                            }

                            return opts && opts.raw ? data : data.value;
                        });
                }

                set(key, value, ttl) {
                    const keyPrefixed = this._getKeyPrefix(key);
                    if (typeof ttl === "undefined") {
                        ttl = this.opts.ttl;
                    }

                    if (ttl === 0) {
                        ttl = undefined;
                    }

                    const { store } = this.opts;

                    return Promise.resolve()
                        .then(() => {
                            const expires =
                                typeof ttl === "number"
                                    ? Date.now() + ttl
                                    : null;
                            value = { value, expires };
                            return this.opts.serialize(value);
                        })
                        .then((value) => store.set(keyPrefixed, value, ttl))
                        .then(() => true);
                }

                delete(key) {
                    const keyPrefixed = this._getKeyPrefix(key);
                    const { store } = this.opts;
                    return Promise.resolve().then(() =>
                        store.delete(keyPrefixed)
                    );
                }

                clear() {
                    const { store } = this.opts;
                    return Promise.resolve().then(() => store.clear());
                }
            }

            module.exports = Keyv;

            /***/
        },

        /***/ 8063: /***/ function (module) {
            /*
             * loglevel - https://github.com/pimterry/loglevel
             *
             * Copyright (c) 2013 Tim Perry
             * Licensed under the MIT license.
             */
            (function (root, definition) {
                "use strict";
                if (typeof define === "function" && define.amd) {
                    define(definition);
                } else if (true && module.exports) {
                    module.exports = definition();
                } else {
                    root.log = definition();
                }
            })(this, function () {
                "use strict";

                // Slightly dubious tricks to cut down minimized file size
                var noop = function () {};
                var undefinedType = "undefined";
                var isIE =
                    typeof window !== undefinedType &&
                    typeof window.navigator !== undefinedType &&
                    /Trident\/|MSIE /.test(window.navigator.userAgent);

                var logMethods = ["trace", "debug", "info", "warn", "error"];

                // Cross-browser bind equivalent that works at least back to IE6
                function bindMethod(obj, methodName) {
                    var method = obj[methodName];
                    if (typeof method.bind === "function") {
                        return method.bind(obj);
                    } else {
                        try {
                            return Function.prototype.bind.call(method, obj);
                        } catch (e) {
                            // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                            return function () {
                                return Function.prototype.apply.apply(method, [
                                    obj,
                                    arguments,
                                ]);
                            };
                        }
                    }
                }

                // Trace() doesn't print the message in IE, so for that case we need to wrap it
                function traceForIE() {
                    if (console.log) {
                        if (console.log.apply) {
                            console.log.apply(console, arguments);
                        } else {
                            // In old IE, native console methods themselves don't have apply().
                            Function.prototype.apply.apply(console.log, [
                                console,
                                arguments,
                            ]);
                        }
                    }
                    if (console.trace) console.trace();
                }

                // Build the best logging method possible for this env
                // Wherever possible we want to bind, not wrap, to preserve stack traces
                function realMethod(methodName) {
                    if (methodName === "debug") {
                        methodName = "log";
                    }

                    if (typeof console === undefinedType) {
                        return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
                    } else if (methodName === "trace" && isIE) {
                        return traceForIE;
                    } else if (console[methodName] !== undefined) {
                        return bindMethod(console, methodName);
                    } else if (console.log !== undefined) {
                        return bindMethod(console, "log");
                    } else {
                        return noop;
                    }
                }

                // These private functions always need `this` to be set properly

                function replaceLoggingMethods(level, loggerName) {
                    /*jshint validthis:true */
                    for (var i = 0; i < logMethods.length; i++) {
                        var methodName = logMethods[i];
                        this[methodName] =
                            i < level
                                ? noop
                                : this.methodFactory(
                                      methodName,
                                      level,
                                      loggerName
                                  );
                    }

                    // Define log.log as an alias for log.debug
                    this.log = this.debug;
                }

                // In old IE versions, the console isn't present until you first open it.
                // We build realMethod() replacements here that regenerate logging methods
                function enableLoggingWhenConsoleArrives(
                    methodName,
                    level,
                    loggerName
                ) {
                    return function () {
                        if (typeof console !== undefinedType) {
                            replaceLoggingMethods.call(this, level, loggerName);
                            this[methodName].apply(this, arguments);
                        }
                    };
                }

                // By default, we use closely bound real methods wherever possible, and
                // otherwise we wait for a console to appear, and then try again.
                function defaultMethodFactory(methodName, level, loggerName) {
                    /*jshint validthis:true */
                    return (
                        realMethod(methodName) ||
                        enableLoggingWhenConsoleArrives.apply(this, arguments)
                    );
                }

                function Logger(name, defaultLevel, factory) {
                    var self = this;
                    var currentLevel;

                    var storageKey = "loglevel";
                    if (typeof name === "string") {
                        storageKey += ":" + name;
                    } else if (typeof name === "symbol") {
                        storageKey = undefined;
                    }

                    function persistLevelIfPossible(levelNum) {
                        var levelName = (
                            logMethods[levelNum] || "silent"
                        ).toUpperCase();

                        if (typeof window === undefinedType || !storageKey)
                            return;

                        // Use localStorage if available
                        try {
                            window.localStorage[storageKey] = levelName;
                            return;
                        } catch (ignore) {}

                        // Use session cookie as fallback
                        try {
                            window.document.cookie =
                                encodeURIComponent(storageKey) +
                                "=" +
                                levelName +
                                ";";
                        } catch (ignore) {}
                    }

                    function getPersistedLevel() {
                        var storedLevel;

                        if (typeof window === undefinedType || !storageKey)
                            return;

                        try {
                            storedLevel = window.localStorage[storageKey];
                        } catch (ignore) {}

                        // Fallback to cookies if local storage gives us nothing
                        if (typeof storedLevel === undefinedType) {
                            try {
                                var cookie = window.document.cookie;
                                var location = cookie.indexOf(
                                    encodeURIComponent(storageKey) + "="
                                );
                                if (location !== -1) {
                                    storedLevel = /^([^;]+)/.exec(
                                        cookie.slice(location)
                                    )[1];
                                }
                            } catch (ignore) {}
                        }

                        // If the stored level is not valid, treat it as if nothing was stored.
                        if (self.levels[storedLevel] === undefined) {
                            storedLevel = undefined;
                        }

                        return storedLevel;
                    }

                    /*
                     *
                     * Public logger API - see https://github.com/pimterry/loglevel for details
                     *
                     */

                    self.name = name;

                    self.levels = {
                        TRACE: 0,
                        DEBUG: 1,
                        INFO: 2,
                        WARN: 3,
                        ERROR: 4,
                        SILENT: 5,
                    };

                    self.methodFactory = factory || defaultMethodFactory;

                    self.getLevel = function () {
                        return currentLevel;
                    };

                    self.setLevel = function (level, persist) {
                        if (
                            typeof level === "string" &&
                            self.levels[level.toUpperCase()] !== undefined
                        ) {
                            level = self.levels[level.toUpperCase()];
                        }
                        if (
                            typeof level === "number" &&
                            level >= 0 &&
                            level <= self.levels.SILENT
                        ) {
                            currentLevel = level;
                            if (persist !== false) {
                                // defaults to true
                                persistLevelIfPossible(level);
                            }
                            replaceLoggingMethods.call(self, level, name);
                            if (
                                typeof console === undefinedType &&
                                level < self.levels.SILENT
                            ) {
                                return "No console available for logging";
                            }
                        } else {
                            throw (
                                "log.setLevel() called with invalid level: " +
                                level
                            );
                        }
                    };

                    self.setDefaultLevel = function (level) {
                        if (!getPersistedLevel()) {
                            self.setLevel(level, false);
                        }
                    };

                    self.enableAll = function (persist) {
                        self.setLevel(self.levels.TRACE, persist);
                    };

                    self.disableAll = function (persist) {
                        self.setLevel(self.levels.SILENT, persist);
                    };

                    // Initialize with the right level
                    var initialLevel = getPersistedLevel();
                    if (initialLevel == null) {
                        initialLevel =
                            defaultLevel == null ? "WARN" : defaultLevel;
                    }
                    self.setLevel(initialLevel, false);
                }

                /*
                 *
                 * Top-level API
                 *
                 */

                var defaultLogger = new Logger();

                var _loggersByName = {};
                defaultLogger.getLogger = function getLogger(name) {
                    if (
                        (typeof name !== "symbol" &&
                            typeof name !== "string") ||
                        name === ""
                    ) {
                        throw new TypeError(
                            "You must supply a name when creating a logger."
                        );
                    }

                    var logger = _loggersByName[name];
                    if (!logger) {
                        logger = _loggersByName[name] = new Logger(
                            name,
                            defaultLogger.getLevel(),
                            defaultLogger.methodFactory
                        );
                    }
                    return logger;
                };

                // Grab the current global log variable in case of overwrite
                var _log =
                    typeof window !== undefinedType ? window.log : undefined;
                defaultLogger.noConflict = function () {
                    if (
                        typeof window !== undefinedType &&
                        window.log === defaultLogger
                    ) {
                        window.log = _log;
                    }

                    return defaultLogger;
                };

                defaultLogger.getLoggers = function getLoggers() {
                    return _loggersByName;
                };

                // ES6 default export, for compatibility
                defaultLogger["default"] = defaultLogger;

                return defaultLogger;
            });

            /***/
        },

        /***/ 9662: /***/ (module) => {
            "use strict";

            module.exports = (object) => {
                const result = {};

                for (const [key, value] of Object.entries(object)) {
                    result[key.toLowerCase()] = value;
                }

                return result;
            };

            /***/
        },

        /***/ 2610: /***/ (module) => {
            "use strict";

            // We define these manually to ensure they're always copied
            // even if they would move up the prototype chain
            // https://nodejs.org/api/http.html#http_class_http_incomingmessage
            const knownProps = [
                "destroy",
                "setTimeout",
                "socket",
                "headers",
                "trailers",
                "rawHeaders",
                "statusCode",
                "httpVersion",
                "httpVersionMinor",
                "httpVersionMajor",
                "rawTrailers",
                "statusMessage",
            ];

            module.exports = (fromStream, toStream) => {
                const fromProps = new Set(
                    Object.keys(fromStream).concat(knownProps)
                );

                for (const prop of fromProps) {
                    // Don't overwrite existing properties
                    if (prop in toStream) {
                        continue;
                    }

                    toStream[prop] =
                        typeof fromStream[prop] === "function"
                            ? fromStream[prop].bind(fromStream)
                            : fromStream[prop];
                }
            };

            /***/
        },

        /***/ 9623: /***/ function (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) {
            /* module decorator */ module = __nccwpck_require__.nmd(module);
            //! moment.js
            //! version : 2.29.1
            //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
            //! license : MIT
            //! momentjs.com

            (function (global, factory) {
                true ? (module.exports = factory()) : 0;
            })(this, function () {
                "use strict";

                var hookCallback;

                function hooks() {
                    return hookCallback.apply(null, arguments);
                }

                // This is done to register the method called with moment()
                // without creating circular dependencies.
                function setHookCallback(callback) {
                    hookCallback = callback;
                }

                function isArray(input) {
                    return (
                        input instanceof Array ||
                        Object.prototype.toString.call(input) ===
                            "[object Array]"
                    );
                }

                function isObject(input) {
                    // IE8 will treat undefined and null as object if it wasn't for
                    // input != null
                    return (
                        input != null &&
                        Object.prototype.toString.call(input) ===
                            "[object Object]"
                    );
                }

                function hasOwnProp(a, b) {
                    return Object.prototype.hasOwnProperty.call(a, b);
                }

                function isObjectEmpty(obj) {
                    if (Object.getOwnPropertyNames) {
                        return Object.getOwnPropertyNames(obj).length === 0;
                    } else {
                        var k;
                        for (k in obj) {
                            if (hasOwnProp(obj, k)) {
                                return false;
                            }
                        }
                        return true;
                    }
                }

                function isUndefined(input) {
                    return input === void 0;
                }

                function isNumber(input) {
                    return (
                        typeof input === "number" ||
                        Object.prototype.toString.call(input) ===
                            "[object Number]"
                    );
                }

                function isDate(input) {
                    return (
                        input instanceof Date ||
                        Object.prototype.toString.call(input) ===
                            "[object Date]"
                    );
                }

                function map(arr, fn) {
                    var res = [],
                        i;
                    for (i = 0; i < arr.length; ++i) {
                        res.push(fn(arr[i], i));
                    }
                    return res;
                }

                function extend(a, b) {
                    for (var i in b) {
                        if (hasOwnProp(b, i)) {
                            a[i] = b[i];
                        }
                    }

                    if (hasOwnProp(b, "toString")) {
                        a.toString = b.toString;
                    }

                    if (hasOwnProp(b, "valueOf")) {
                        a.valueOf = b.valueOf;
                    }

                    return a;
                }

                function createUTC(input, format, locale, strict) {
                    return createLocalOrUTC(
                        input,
                        format,
                        locale,
                        strict,
                        true
                    ).utc();
                }

                function defaultParsingFlags() {
                    // We need to deep clone this object.
                    return {
                        empty: false,
                        unusedTokens: [],
                        unusedInput: [],
                        overflow: -2,
                        charsLeftOver: 0,
                        nullInput: false,
                        invalidEra: null,
                        invalidMonth: null,
                        invalidFormat: false,
                        userInvalidated: false,
                        iso: false,
                        parsedDateParts: [],
                        era: null,
                        meridiem: null,
                        rfc2822: false,
                        weekdayMismatch: false,
                    };
                }

                function getParsingFlags(m) {
                    if (m._pf == null) {
                        m._pf = defaultParsingFlags();
                    }
                    return m._pf;
                }

                var some;
                if (Array.prototype.some) {
                    some = Array.prototype.some;
                } else {
                    some = function (fun) {
                        var t = Object(this),
                            len = t.length >>> 0,
                            i;

                        for (i = 0; i < len; i++) {
                            if (i in t && fun.call(this, t[i], i, t)) {
                                return true;
                            }
                        }

                        return false;
                    };
                }

                function isValid(m) {
                    if (m._isValid == null) {
                        var flags = getParsingFlags(m),
                            parsedParts = some.call(
                                flags.parsedDateParts,
                                function (i) {
                                    return i != null;
                                }
                            ),
                            isNowValid =
                                !isNaN(m._d.getTime()) &&
                                flags.overflow < 0 &&
                                !flags.empty &&
                                !flags.invalidEra &&
                                !flags.invalidMonth &&
                                !flags.invalidWeekday &&
                                !flags.weekdayMismatch &&
                                !flags.nullInput &&
                                !flags.invalidFormat &&
                                !flags.userInvalidated &&
                                (!flags.meridiem ||
                                    (flags.meridiem && parsedParts));

                        if (m._strict) {
                            isNowValid =
                                isNowValid &&
                                flags.charsLeftOver === 0 &&
                                flags.unusedTokens.length === 0 &&
                                flags.bigHour === undefined;
                        }

                        if (Object.isFrozen == null || !Object.isFrozen(m)) {
                            m._isValid = isNowValid;
                        } else {
                            return isNowValid;
                        }
                    }
                    return m._isValid;
                }

                function createInvalid(flags) {
                    var m = createUTC(NaN);
                    if (flags != null) {
                        extend(getParsingFlags(m), flags);
                    } else {
                        getParsingFlags(m).userInvalidated = true;
                    }

                    return m;
                }

                // Plugins that add properties should also add the key here (null value),
                // so we can properly clone ourselves.
                var momentProperties = (hooks.momentProperties = []),
                    updateInProgress = false;

                function copyConfig(to, from) {
                    var i, prop, val;

                    if (!isUndefined(from._isAMomentObject)) {
                        to._isAMomentObject = from._isAMomentObject;
                    }
                    if (!isUndefined(from._i)) {
                        to._i = from._i;
                    }
                    if (!isUndefined(from._f)) {
                        to._f = from._f;
                    }
                    if (!isUndefined(from._l)) {
                        to._l = from._l;
                    }
                    if (!isUndefined(from._strict)) {
                        to._strict = from._strict;
                    }
                    if (!isUndefined(from._tzm)) {
                        to._tzm = from._tzm;
                    }
                    if (!isUndefined(from._isUTC)) {
                        to._isUTC = from._isUTC;
                    }
                    if (!isUndefined(from._offset)) {
                        to._offset = from._offset;
                    }
                    if (!isUndefined(from._pf)) {
                        to._pf = getParsingFlags(from);
                    }
                    if (!isUndefined(from._locale)) {
                        to._locale = from._locale;
                    }

                    if (momentProperties.length > 0) {
                        for (i = 0; i < momentProperties.length; i++) {
                            prop = momentProperties[i];
                            val = from[prop];
                            if (!isUndefined(val)) {
                                to[prop] = val;
                            }
                        }
                    }

                    return to;
                }

                // Moment prototype object
                function Moment(config) {
                    copyConfig(this, config);
                    this._d = new Date(
                        config._d != null ? config._d.getTime() : NaN
                    );
                    if (!this.isValid()) {
                        this._d = new Date(NaN);
                    }
                    // Prevent infinite loop in case updateOffset creates new moment
                    // objects.
                    if (updateInProgress === false) {
                        updateInProgress = true;
                        hooks.updateOffset(this);
                        updateInProgress = false;
                    }
                }

                function isMoment(obj) {
                    return (
                        obj instanceof Moment ||
                        (obj != null && obj._isAMomentObject != null)
                    );
                }

                function warn(msg) {
                    if (
                        hooks.suppressDeprecationWarnings === false &&
                        typeof console !== "undefined" &&
                        console.warn
                    ) {
                        console.warn("Deprecation warning: " + msg);
                    }
                }

                function deprecate(msg, fn) {
                    var firstTime = true;

                    return extend(function () {
                        if (hooks.deprecationHandler != null) {
                            hooks.deprecationHandler(null, msg);
                        }
                        if (firstTime) {
                            var args = [],
                                arg,
                                i,
                                key;
                            for (i = 0; i < arguments.length; i++) {
                                arg = "";
                                if (typeof arguments[i] === "object") {
                                    arg += "\n[" + i + "] ";
                                    for (key in arguments[0]) {
                                        if (hasOwnProp(arguments[0], key)) {
                                            arg +=
                                                key +
                                                ": " +
                                                arguments[0][key] +
                                                ", ";
                                        }
                                    }
                                    arg = arg.slice(0, -2); // Remove trailing comma and space
                                } else {
                                    arg = arguments[i];
                                }
                                args.push(arg);
                            }
                            warn(
                                msg +
                                    "\nArguments: " +
                                    Array.prototype.slice.call(args).join("") +
                                    "\n" +
                                    new Error().stack
                            );
                            firstTime = false;
                        }
                        return fn.apply(this, arguments);
                    }, fn);
                }

                var deprecations = {};

                function deprecateSimple(name, msg) {
                    if (hooks.deprecationHandler != null) {
                        hooks.deprecationHandler(name, msg);
                    }
                    if (!deprecations[name]) {
                        warn(msg);
                        deprecations[name] = true;
                    }
                }

                hooks.suppressDeprecationWarnings = false;
                hooks.deprecationHandler = null;

                function isFunction(input) {
                    return (
                        (typeof Function !== "undefined" &&
                            input instanceof Function) ||
                        Object.prototype.toString.call(input) ===
                            "[object Function]"
                    );
                }

                function set(config) {
                    var prop, i;
                    for (i in config) {
                        if (hasOwnProp(config, i)) {
                            prop = config[i];
                            if (isFunction(prop)) {
                                this[i] = prop;
                            } else {
                                this["_" + i] = prop;
                            }
                        }
                    }
                    this._config = config;
                    // Lenient ordinal parsing accepts just a number in addition to
                    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
                    // TODO: Remove "ordinalParse" fallback in next major release.
                    this._dayOfMonthOrdinalParseLenient = new RegExp(
                        (this._dayOfMonthOrdinalParse.source ||
                            this._ordinalParse.source) +
                            "|" +
                            /\d{1,2}/.source
                    );
                }

                function mergeConfigs(parentConfig, childConfig) {
                    var res = extend({}, parentConfig),
                        prop;
                    for (prop in childConfig) {
                        if (hasOwnProp(childConfig, prop)) {
                            if (
                                isObject(parentConfig[prop]) &&
                                isObject(childConfig[prop])
                            ) {
                                res[prop] = {};
                                extend(res[prop], parentConfig[prop]);
                                extend(res[prop], childConfig[prop]);
                            } else if (childConfig[prop] != null) {
                                res[prop] = childConfig[prop];
                            } else {
                                delete res[prop];
                            }
                        }
                    }
                    for (prop in parentConfig) {
                        if (
                            hasOwnProp(parentConfig, prop) &&
                            !hasOwnProp(childConfig, prop) &&
                            isObject(parentConfig[prop])
                        ) {
                            // make sure changes to properties don't modify parent config
                            res[prop] = extend({}, res[prop]);
                        }
                    }
                    return res;
                }

                function Locale(config) {
                    if (config != null) {
                        this.set(config);
                    }
                }

                var keys;

                if (Object.keys) {
                    keys = Object.keys;
                } else {
                    keys = function (obj) {
                        var i,
                            res = [];
                        for (i in obj) {
                            if (hasOwnProp(obj, i)) {
                                res.push(i);
                            }
                        }
                        return res;
                    };
                }

                var defaultCalendar = {
                    sameDay: "[Today at] LT",
                    nextDay: "[Tomorrow at] LT",
                    nextWeek: "dddd [at] LT",
                    lastDay: "[Yesterday at] LT",
                    lastWeek: "[Last] dddd [at] LT",
                    sameElse: "L",
                };

                function calendar(key, mom, now) {
                    var output =
                        this._calendar[key] || this._calendar["sameElse"];
                    return isFunction(output) ? output.call(mom, now) : output;
                }

                function zeroFill(number, targetLength, forceSign) {
                    var absNumber = "" + Math.abs(number),
                        zerosToFill = targetLength - absNumber.length,
                        sign = number >= 0;
                    return (
                        (sign ? (forceSign ? "+" : "") : "-") +
                        Math.pow(10, Math.max(0, zerosToFill))
                            .toString()
                            .substr(1) +
                        absNumber
                    );
                }

                var formattingTokens =
                        /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
                    localFormattingTokens =
                        /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
                    formatFunctions = {},
                    formatTokenFunctions = {};

                // token:    'M'
                // padded:   ['MM', 2]
                // ordinal:  'Mo'
                // callback: function () { this.month() + 1 }
                function addFormatToken(token, padded, ordinal, callback) {
                    var func = callback;
                    if (typeof callback === "string") {
                        func = function () {
                            return this[callback]();
                        };
                    }
                    if (token) {
                        formatTokenFunctions[token] = func;
                    }
                    if (padded) {
                        formatTokenFunctions[padded[0]] = function () {
                            return zeroFill(
                                func.apply(this, arguments),
                                padded[1],
                                padded[2]
                            );
                        };
                    }
                    if (ordinal) {
                        formatTokenFunctions[ordinal] = function () {
                            return this.localeData().ordinal(
                                func.apply(this, arguments),
                                token
                            );
                        };
                    }
                }

                function removeFormattingTokens(input) {
                    if (input.match(/\[[\s\S]/)) {
                        return input.replace(/^\[|\]$/g, "");
                    }
                    return input.replace(/\\/g, "");
                }

                function makeFormatFunction(format) {
                    var array = format.match(formattingTokens),
                        i,
                        length;

                    for (i = 0, length = array.length; i < length; i++) {
                        if (formatTokenFunctions[array[i]]) {
                            array[i] = formatTokenFunctions[array[i]];
                        } else {
                            array[i] = removeFormattingTokens(array[i]);
                        }
                    }

                    return function (mom) {
                        var output = "",
                            i;
                        for (i = 0; i < length; i++) {
                            output += isFunction(array[i])
                                ? array[i].call(mom, format)
                                : array[i];
                        }
                        return output;
                    };
                }

                // format date using native date object
                function formatMoment(m, format) {
                    if (!m.isValid()) {
                        return m.localeData().invalidDate();
                    }

                    format = expandFormat(format, m.localeData());
                    formatFunctions[format] =
                        formatFunctions[format] || makeFormatFunction(format);

                    return formatFunctions[format](m);
                }

                function expandFormat(format, locale) {
                    var i = 5;

                    function replaceLongDateFormatTokens(input) {
                        return locale.longDateFormat(input) || input;
                    }

                    localFormattingTokens.lastIndex = 0;
                    while (i >= 0 && localFormattingTokens.test(format)) {
                        format = format.replace(
                            localFormattingTokens,
                            replaceLongDateFormatTokens
                        );
                        localFormattingTokens.lastIndex = 0;
                        i -= 1;
                    }

                    return format;
                }

                var defaultLongDateFormat = {
                    LTS: "h:mm:ss A",
                    LT: "h:mm A",
                    L: "MM/DD/YYYY",
                    LL: "MMMM D, YYYY",
                    LLL: "MMMM D, YYYY h:mm A",
                    LLLL: "dddd, MMMM D, YYYY h:mm A",
                };

                function longDateFormat(key) {
                    var format = this._longDateFormat[key],
                        formatUpper = this._longDateFormat[key.toUpperCase()];

                    if (format || !formatUpper) {
                        return format;
                    }

                    this._longDateFormat[key] = formatUpper
                        .match(formattingTokens)
                        .map(function (tok) {
                            if (
                                tok === "MMMM" ||
                                tok === "MM" ||
                                tok === "DD" ||
                                tok === "dddd"
                            ) {
                                return tok.slice(1);
                            }
                            return tok;
                        })
                        .join("");

                    return this._longDateFormat[key];
                }

                var defaultInvalidDate = "Invalid date";

                function invalidDate() {
                    return this._invalidDate;
                }

                var defaultOrdinal = "%d",
                    defaultDayOfMonthOrdinalParse = /\d{1,2}/;

                function ordinal(number) {
                    return this._ordinal.replace("%d", number);
                }

                var defaultRelativeTime = {
                    future: "in %s",
                    past: "%s ago",
                    s: "a few seconds",
                    ss: "%d seconds",
                    m: "a minute",
                    mm: "%d minutes",
                    h: "an hour",
                    hh: "%d hours",
                    d: "a day",
                    dd: "%d days",
                    w: "a week",
                    ww: "%d weeks",
                    M: "a month",
                    MM: "%d months",
                    y: "a year",
                    yy: "%d years",
                };

                function relativeTime(number, withoutSuffix, string, isFuture) {
                    var output = this._relativeTime[string];
                    return isFunction(output)
                        ? output(number, withoutSuffix, string, isFuture)
                        : output.replace(/%d/i, number);
                }

                function pastFuture(diff, output) {
                    var format =
                        this._relativeTime[diff > 0 ? "future" : "past"];
                    return isFunction(format)
                        ? format(output)
                        : format.replace(/%s/i, output);
                }

                var aliases = {};

                function addUnitAlias(unit, shorthand) {
                    var lowerCase = unit.toLowerCase();
                    aliases[lowerCase] =
                        aliases[lowerCase + "s"] =
                        aliases[shorthand] =
                            unit;
                }

                function normalizeUnits(units) {
                    return typeof units === "string"
                        ? aliases[units] || aliases[units.toLowerCase()]
                        : undefined;
                }

                function normalizeObjectUnits(inputObject) {
                    var normalizedInput = {},
                        normalizedProp,
                        prop;

                    for (prop in inputObject) {
                        if (hasOwnProp(inputObject, prop)) {
                            normalizedProp = normalizeUnits(prop);
                            if (normalizedProp) {
                                normalizedInput[normalizedProp] =
                                    inputObject[prop];
                            }
                        }
                    }

                    return normalizedInput;
                }

                var priorities = {};

                function addUnitPriority(unit, priority) {
                    priorities[unit] = priority;
                }

                function getPrioritizedUnits(unitsObj) {
                    var units = [],
                        u;
                    for (u in unitsObj) {
                        if (hasOwnProp(unitsObj, u)) {
                            units.push({ unit: u, priority: priorities[u] });
                        }
                    }
                    units.sort(function (a, b) {
                        return a.priority - b.priority;
                    });
                    return units;
                }

                function isLeapYear(year) {
                    return (
                        (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0
                    );
                }

                function absFloor(number) {
                    if (number < 0) {
                        // -0 -> 0
                        return Math.ceil(number) || 0;
                    } else {
                        return Math.floor(number);
                    }
                }

                function toInt(argumentForCoercion) {
                    var coercedNumber = +argumentForCoercion,
                        value = 0;

                    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                        value = absFloor(coercedNumber);
                    }

                    return value;
                }

                function makeGetSet(unit, keepTime) {
                    return function (value) {
                        if (value != null) {
                            set$1(this, unit, value);
                            hooks.updateOffset(this, keepTime);
                            return this;
                        } else {
                            return get(this, unit);
                        }
                    };
                }

                function get(mom, unit) {
                    return mom.isValid()
                        ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]()
                        : NaN;
                }

                function set$1(mom, unit, value) {
                    if (mom.isValid() && !isNaN(value)) {
                        if (
                            unit === "FullYear" &&
                            isLeapYear(mom.year()) &&
                            mom.month() === 1 &&
                            mom.date() === 29
                        ) {
                            value = toInt(value);
                            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
                                value,
                                mom.month(),
                                daysInMonth(value, mom.month())
                            );
                        } else {
                            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
                                value
                            );
                        }
                    }
                }

                // MOMENTS

                function stringGet(units) {
                    units = normalizeUnits(units);
                    if (isFunction(this[units])) {
                        return this[units]();
                    }
                    return this;
                }

                function stringSet(units, value) {
                    if (typeof units === "object") {
                        units = normalizeObjectUnits(units);
                        var prioritized = getPrioritizedUnits(units),
                            i;
                        for (i = 0; i < prioritized.length; i++) {
                            this[prioritized[i].unit](
                                units[prioritized[i].unit]
                            );
                        }
                    } else {
                        units = normalizeUnits(units);
                        if (isFunction(this[units])) {
                            return this[units](value);
                        }
                    }
                    return this;
                }

                var match1 = /\d/, //       0 - 9
                    match2 = /\d\d/, //      00 - 99
                    match3 = /\d{3}/, //     000 - 999
                    match4 = /\d{4}/, //    0000 - 9999
                    match6 = /[+-]?\d{6}/, // -999999 - 999999
                    match1to2 = /\d\d?/, //       0 - 99
                    match3to4 = /\d\d\d\d?/, //     999 - 9999
                    match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
                    match1to3 = /\d{1,3}/, //       0 - 999
                    match1to4 = /\d{1,4}/, //       0 - 9999
                    match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
                    matchUnsigned = /\d+/, //       0 - inf
                    matchSigned = /[+-]?\d+/, //    -inf - inf
                    matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
                    matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
                    matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
                    // any word (or two) characters or numbers including two/three word month in arabic.
                    // includes scottish gaelic two word and hyphenated months
                    matchWord =
                        /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
                    regexes;

                regexes = {};

                function addRegexToken(token, regex, strictRegex) {
                    regexes[token] = isFunction(regex)
                        ? regex
                        : function (isStrict, localeData) {
                              return isStrict && strictRegex
                                  ? strictRegex
                                  : regex;
                          };
                }

                function getParseRegexForToken(token, config) {
                    if (!hasOwnProp(regexes, token)) {
                        return new RegExp(unescapeFormat(token));
                    }

                    return regexes[token](config._strict, config._locale);
                }

                // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
                function unescapeFormat(s) {
                    return regexEscape(
                        s
                            .replace("\\", "")
                            .replace(
                                /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
                                function (matched, p1, p2, p3, p4) {
                                    return p1 || p2 || p3 || p4;
                                }
                            )
                    );
                }

                function regexEscape(s) {
                    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
                }

                var tokens = {};

                function addParseToken(token, callback) {
                    var i,
                        func = callback;
                    if (typeof token === "string") {
                        token = [token];
                    }
                    if (isNumber(callback)) {
                        func = function (input, array) {
                            array[callback] = toInt(input);
                        };
                    }
                    for (i = 0; i < token.length; i++) {
                        tokens[token[i]] = func;
                    }
                }

                function addWeekParseToken(token, callback) {
                    addParseToken(
                        token,
                        function (input, array, config, token) {
                            config._w = config._w || {};
                            callback(input, config._w, config, token);
                        }
                    );
                }

                function addTimeToArrayFromToken(token, input, config) {
                    if (input != null && hasOwnProp(tokens, token)) {
                        tokens[token](input, config._a, config, token);
                    }
                }

                var YEAR = 0,
                    MONTH = 1,
                    DATE = 2,
                    HOUR = 3,
                    MINUTE = 4,
                    SECOND = 5,
                    MILLISECOND = 6,
                    WEEK = 7,
                    WEEKDAY = 8;

                function mod(n, x) {
                    return ((n % x) + x) % x;
                }

                var indexOf;

                if (Array.prototype.indexOf) {
                    indexOf = Array.prototype.indexOf;
                } else {
                    indexOf = function (o) {
                        // I know
                        var i;
                        for (i = 0; i < this.length; ++i) {
                            if (this[i] === o) {
                                return i;
                            }
                        }
                        return -1;
                    };
                }

                function daysInMonth(year, month) {
                    if (isNaN(year) || isNaN(month)) {
                        return NaN;
                    }
                    var modMonth = mod(month, 12);
                    year += (month - modMonth) / 12;
                    return modMonth === 1
                        ? isLeapYear(year)
                            ? 29
                            : 28
                        : 31 - ((modMonth % 7) % 2);
                }

                // FORMATTING

                addFormatToken("M", ["MM", 2], "Mo", function () {
                    return this.month() + 1;
                });

                addFormatToken("MMM", 0, 0, function (format) {
                    return this.localeData().monthsShort(this, format);
                });

                addFormatToken("MMMM", 0, 0, function (format) {
                    return this.localeData().months(this, format);
                });

                // ALIASES

                addUnitAlias("month", "M");

                // PRIORITY

                addUnitPriority("month", 8);

                // PARSING

                addRegexToken("M", match1to2);
                addRegexToken("MM", match1to2, match2);
                addRegexToken("MMM", function (isStrict, locale) {
                    return locale.monthsShortRegex(isStrict);
                });
                addRegexToken("MMMM", function (isStrict, locale) {
                    return locale.monthsRegex(isStrict);
                });

                addParseToken(["M", "MM"], function (input, array) {
                    array[MONTH] = toInt(input) - 1;
                });

                addParseToken(
                    ["MMM", "MMMM"],
                    function (input, array, config, token) {
                        var month = config._locale.monthsParse(
                            input,
                            token,
                            config._strict
                        );
                        // if we didn't find a month name, mark the date as invalid.
                        if (month != null) {
                            array[MONTH] = month;
                        } else {
                            getParsingFlags(config).invalidMonth = input;
                        }
                    }
                );

                // LOCALES

                var defaultLocaleMonths =
                        "January_February_March_April_May_June_July_August_September_October_November_December".split(
                            "_"
                        ),
                    defaultLocaleMonthsShort =
                        "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split(
                            "_"
                        ),
                    MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
                    defaultMonthsShortRegex = matchWord,
                    defaultMonthsRegex = matchWord;

                function localeMonths(m, format) {
                    if (!m) {
                        return isArray(this._months)
                            ? this._months
                            : this._months["standalone"];
                    }
                    return isArray(this._months)
                        ? this._months[m.month()]
                        : this._months[
                              (this._months.isFormat || MONTHS_IN_FORMAT).test(
                                  format
                              )
                                  ? "format"
                                  : "standalone"
                          ][m.month()];
                }

                function localeMonthsShort(m, format) {
                    if (!m) {
                        return isArray(this._monthsShort)
                            ? this._monthsShort
                            : this._monthsShort["standalone"];
                    }
                    return isArray(this._monthsShort)
                        ? this._monthsShort[m.month()]
                        : this._monthsShort[
                              MONTHS_IN_FORMAT.test(format)
                                  ? "format"
                                  : "standalone"
                          ][m.month()];
                }

                function handleStrictParse(monthName, format, strict) {
                    var i,
                        ii,
                        mom,
                        llc = monthName.toLocaleLowerCase();
                    if (!this._monthsParse) {
                        // this is not used
                        this._monthsParse = [];
                        this._longMonthsParse = [];
                        this._shortMonthsParse = [];
                        for (i = 0; i < 12; ++i) {
                            mom = createUTC([2000, i]);
                            this._shortMonthsParse[i] = this.monthsShort(
                                mom,
                                ""
                            ).toLocaleLowerCase();
                            this._longMonthsParse[i] = this.months(
                                mom,
                                ""
                            ).toLocaleLowerCase();
                        }
                    }

                    if (strict) {
                        if (format === "MMM") {
                            ii = indexOf.call(this._shortMonthsParse, llc);
                            return ii !== -1 ? ii : null;
                        } else {
                            ii = indexOf.call(this._longMonthsParse, llc);
                            return ii !== -1 ? ii : null;
                        }
                    } else {
                        if (format === "MMM") {
                            ii = indexOf.call(this._shortMonthsParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf.call(this._longMonthsParse, llc);
                            return ii !== -1 ? ii : null;
                        } else {
                            ii = indexOf.call(this._longMonthsParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf.call(this._shortMonthsParse, llc);
                            return ii !== -1 ? ii : null;
                        }
                    }
                }

                function localeMonthsParse(monthName, format, strict) {
                    var i, mom, regex;

                    if (this._monthsParseExact) {
                        return handleStrictParse.call(
                            this,
                            monthName,
                            format,
                            strict
                        );
                    }

                    if (!this._monthsParse) {
                        this._monthsParse = [];
                        this._longMonthsParse = [];
                        this._shortMonthsParse = [];
                    }

                    // TODO: add sorting
                    // Sorting makes sure if one month (or abbr) is a prefix of another
                    // see sorting in computeMonthsParse
                    for (i = 0; i < 12; i++) {
                        // make the regex if we don't have it already
                        mom = createUTC([2000, i]);
                        if (strict && !this._longMonthsParse[i]) {
                            this._longMonthsParse[i] = new RegExp(
                                "^" +
                                    this.months(mom, "").replace(".", "") +
                                    "$",
                                "i"
                            );
                            this._shortMonthsParse[i] = new RegExp(
                                "^" +
                                    this.monthsShort(mom, "").replace(".", "") +
                                    "$",
                                "i"
                            );
                        }
                        if (!strict && !this._monthsParse[i]) {
                            regex =
                                "^" +
                                this.months(mom, "") +
                                "|^" +
                                this.monthsShort(mom, "");
                            this._monthsParse[i] = new RegExp(
                                regex.replace(".", ""),
                                "i"
                            );
                        }
                        // test the regex
                        if (
                            strict &&
                            format === "MMMM" &&
                            this._longMonthsParse[i].test(monthName)
                        ) {
                            return i;
                        } else if (
                            strict &&
                            format === "MMM" &&
                            this._shortMonthsParse[i].test(monthName)
                        ) {
                            return i;
                        } else if (
                            !strict &&
                            this._monthsParse[i].test(monthName)
                        ) {
                            return i;
                        }
                    }
                }

                // MOMENTS

                function setMonth(mom, value) {
                    var dayOfMonth;

                    if (!mom.isValid()) {
                        // No op
                        return mom;
                    }

                    if (typeof value === "string") {
                        if (/^\d+$/.test(value)) {
                            value = toInt(value);
                        } else {
                            value = mom.localeData().monthsParse(value);
                            // TODO: Another silent failure?
                            if (!isNumber(value)) {
                                return mom;
                            }
                        }
                    }

                    dayOfMonth = Math.min(
                        mom.date(),
                        daysInMonth(mom.year(), value)
                    );
                    mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](
                        value,
                        dayOfMonth
                    );
                    return mom;
                }

                function getSetMonth(value) {
                    if (value != null) {
                        setMonth(this, value);
                        hooks.updateOffset(this, true);
                        return this;
                    } else {
                        return get(this, "Month");
                    }
                }

                function getDaysInMonth() {
                    return daysInMonth(this.year(), this.month());
                }

                function monthsShortRegex(isStrict) {
                    if (this._monthsParseExact) {
                        if (!hasOwnProp(this, "_monthsRegex")) {
                            computeMonthsParse.call(this);
                        }
                        if (isStrict) {
                            return this._monthsShortStrictRegex;
                        } else {
                            return this._monthsShortRegex;
                        }
                    } else {
                        if (!hasOwnProp(this, "_monthsShortRegex")) {
                            this._monthsShortRegex = defaultMonthsShortRegex;
                        }
                        return this._monthsShortStrictRegex && isStrict
                            ? this._monthsShortStrictRegex
                            : this._monthsShortRegex;
                    }
                }

                function monthsRegex(isStrict) {
                    if (this._monthsParseExact) {
                        if (!hasOwnProp(this, "_monthsRegex")) {
                            computeMonthsParse.call(this);
                        }
                        if (isStrict) {
                            return this._monthsStrictRegex;
                        } else {
                            return this._monthsRegex;
                        }
                    } else {
                        if (!hasOwnProp(this, "_monthsRegex")) {
                            this._monthsRegex = defaultMonthsRegex;
                        }
                        return this._monthsStrictRegex && isStrict
                            ? this._monthsStrictRegex
                            : this._monthsRegex;
                    }
                }

                function computeMonthsParse() {
                    function cmpLenRev(a, b) {
                        return b.length - a.length;
                    }

                    var shortPieces = [],
                        longPieces = [],
                        mixedPieces = [],
                        i,
                        mom;
                    for (i = 0; i < 12; i++) {
                        // make the regex if we don't have it already
                        mom = createUTC([2000, i]);
                        shortPieces.push(this.monthsShort(mom, ""));
                        longPieces.push(this.months(mom, ""));
                        mixedPieces.push(this.months(mom, ""));
                        mixedPieces.push(this.monthsShort(mom, ""));
                    }
                    // Sorting makes sure if one month (or abbr) is a prefix of another it
                    // will match the longer piece.
                    shortPieces.sort(cmpLenRev);
                    longPieces.sort(cmpLenRev);
                    mixedPieces.sort(cmpLenRev);
                    for (i = 0; i < 12; i++) {
                        shortPieces[i] = regexEscape(shortPieces[i]);
                        longPieces[i] = regexEscape(longPieces[i]);
                    }
                    for (i = 0; i < 24; i++) {
                        mixedPieces[i] = regexEscape(mixedPieces[i]);
                    }

                    this._monthsRegex = new RegExp(
                        "^(" + mixedPieces.join("|") + ")",
                        "i"
                    );
                    this._monthsShortRegex = this._monthsRegex;
                    this._monthsStrictRegex = new RegExp(
                        "^(" + longPieces.join("|") + ")",
                        "i"
                    );
                    this._monthsShortStrictRegex = new RegExp(
                        "^(" + shortPieces.join("|") + ")",
                        "i"
                    );
                }

                // FORMATTING

                addFormatToken("Y", 0, 0, function () {
                    var y = this.year();
                    return y <= 9999 ? zeroFill(y, 4) : "+" + y;
                });

                addFormatToken(0, ["YY", 2], 0, function () {
                    return this.year() % 100;
                });

                addFormatToken(0, ["YYYY", 4], 0, "year");
                addFormatToken(0, ["YYYYY", 5], 0, "year");
                addFormatToken(0, ["YYYYYY", 6, true], 0, "year");

                // ALIASES

                addUnitAlias("year", "y");

                // PRIORITIES

                addUnitPriority("year", 1);

                // PARSING

                addRegexToken("Y", matchSigned);
                addRegexToken("YY", match1to2, match2);
                addRegexToken("YYYY", match1to4, match4);
                addRegexToken("YYYYY", match1to6, match6);
                addRegexToken("YYYYYY", match1to6, match6);

                addParseToken(["YYYYY", "YYYYYY"], YEAR);
                addParseToken("YYYY", function (input, array) {
                    array[YEAR] =
                        input.length === 2
                            ? hooks.parseTwoDigitYear(input)
                            : toInt(input);
                });
                addParseToken("YY", function (input, array) {
                    array[YEAR] = hooks.parseTwoDigitYear(input);
                });
                addParseToken("Y", function (input, array) {
                    array[YEAR] = parseInt(input, 10);
                });

                // HELPERS

                function daysInYear(year) {
                    return isLeapYear(year) ? 366 : 365;
                }

                // HOOKS

                hooks.parseTwoDigitYear = function (input) {
                    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
                };

                // MOMENTS

                var getSetYear = makeGetSet("FullYear", true);

                function getIsLeapYear() {
                    return isLeapYear(this.year());
                }

                function createDate(y, m, d, h, M, s, ms) {
                    // can't just apply() to create a date:
                    // https://stackoverflow.com/q/181348
                    var date;
                    // the date constructor remaps years 0-99 to 1900-1999
                    if (y < 100 && y >= 0) {
                        // preserve leap years using a full 400 year cycle, then reset
                        date = new Date(y + 400, m, d, h, M, s, ms);
                        if (isFinite(date.getFullYear())) {
                            date.setFullYear(y);
                        }
                    } else {
                        date = new Date(y, m, d, h, M, s, ms);
                    }

                    return date;
                }

                function createUTCDate(y) {
                    var date, args;
                    // the Date.UTC function remaps years 0-99 to 1900-1999
                    if (y < 100 && y >= 0) {
                        args = Array.prototype.slice.call(arguments);
                        // preserve leap years using a full 400 year cycle, then reset
                        args[0] = y + 400;
                        date = new Date(Date.UTC.apply(null, args));
                        if (isFinite(date.getUTCFullYear())) {
                            date.setUTCFullYear(y);
                        }
                    } else {
                        date = new Date(Date.UTC.apply(null, arguments));
                    }

                    return date;
                }

                // start-of-first-week - start-of-year
                function firstWeekOffset(year, dow, doy) {
                    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
                        fwd = 7 + dow - doy,
                        // first-week day local weekday -- which local weekday is fwd
                        fwdlw =
                            (7 +
                                createUTCDate(year, 0, fwd).getUTCDay() -
                                dow) %
                            7;

                    return -fwdlw + fwd - 1;
                }

                // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
                function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
                    var localWeekday = (7 + weekday - dow) % 7,
                        weekOffset = firstWeekOffset(year, dow, doy),
                        dayOfYear =
                            1 + 7 * (week - 1) + localWeekday + weekOffset,
                        resYear,
                        resDayOfYear;

                    if (dayOfYear <= 0) {
                        resYear = year - 1;
                        resDayOfYear = daysInYear(resYear) + dayOfYear;
                    } else if (dayOfYear > daysInYear(year)) {
                        resYear = year + 1;
                        resDayOfYear = dayOfYear - daysInYear(year);
                    } else {
                        resYear = year;
                        resDayOfYear = dayOfYear;
                    }

                    return {
                        year: resYear,
                        dayOfYear: resDayOfYear,
                    };
                }

                function weekOfYear(mom, dow, doy) {
                    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
                        week =
                            Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) +
                            1,
                        resWeek,
                        resYear;

                    if (week < 1) {
                        resYear = mom.year() - 1;
                        resWeek = week + weeksInYear(resYear, dow, doy);
                    } else if (week > weeksInYear(mom.year(), dow, doy)) {
                        resWeek = week - weeksInYear(mom.year(), dow, doy);
                        resYear = mom.year() + 1;
                    } else {
                        resYear = mom.year();
                        resWeek = week;
                    }

                    return {
                        week: resWeek,
                        year: resYear,
                    };
                }

                function weeksInYear(year, dow, doy) {
                    var weekOffset = firstWeekOffset(year, dow, doy),
                        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
                    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
                }

                // FORMATTING

                addFormatToken("w", ["ww", 2], "wo", "week");
                addFormatToken("W", ["WW", 2], "Wo", "isoWeek");

                // ALIASES

                addUnitAlias("week", "w");
                addUnitAlias("isoWeek", "W");

                // PRIORITIES

                addUnitPriority("week", 5);
                addUnitPriority("isoWeek", 5);

                // PARSING

                addRegexToken("w", match1to2);
                addRegexToken("ww", match1to2, match2);
                addRegexToken("W", match1to2);
                addRegexToken("WW", match1to2, match2);

                addWeekParseToken(
                    ["w", "ww", "W", "WW"],
                    function (input, week, config, token) {
                        week[token.substr(0, 1)] = toInt(input);
                    }
                );

                // HELPERS

                // LOCALES

                function localeWeek(mom) {
                    return weekOfYear(mom, this._week.dow, this._week.doy).week;
                }

                var defaultLocaleWeek = {
                    dow: 0, // Sunday is the first day of the week.
                    doy: 6, // The week that contains Jan 6th is the first week of the year.
                };

                function localeFirstDayOfWeek() {
                    return this._week.dow;
                }

                function localeFirstDayOfYear() {
                    return this._week.doy;
                }

                // MOMENTS

                function getSetWeek(input) {
                    var week = this.localeData().week(this);
                    return input == null
                        ? week
                        : this.add((input - week) * 7, "d");
                }

                function getSetISOWeek(input) {
                    var week = weekOfYear(this, 1, 4).week;
                    return input == null
                        ? week
                        : this.add((input - week) * 7, "d");
                }

                // FORMATTING

                addFormatToken("d", 0, "do", "day");

                addFormatToken("dd", 0, 0, function (format) {
                    return this.localeData().weekdaysMin(this, format);
                });

                addFormatToken("ddd", 0, 0, function (format) {
                    return this.localeData().weekdaysShort(this, format);
                });

                addFormatToken("dddd", 0, 0, function (format) {
                    return this.localeData().weekdays(this, format);
                });

                addFormatToken("e", 0, 0, "weekday");
                addFormatToken("E", 0, 0, "isoWeekday");

                // ALIASES

                addUnitAlias("day", "d");
                addUnitAlias("weekday", "e");
                addUnitAlias("isoWeekday", "E");

                // PRIORITY
                addUnitPriority("day", 11);
                addUnitPriority("weekday", 11);
                addUnitPriority("isoWeekday", 11);

                // PARSING

                addRegexToken("d", match1to2);
                addRegexToken("e", match1to2);
                addRegexToken("E", match1to2);
                addRegexToken("dd", function (isStrict, locale) {
                    return locale.weekdaysMinRegex(isStrict);
                });
                addRegexToken("ddd", function (isStrict, locale) {
                    return locale.weekdaysShortRegex(isStrict);
                });
                addRegexToken("dddd", function (isStrict, locale) {
                    return locale.weekdaysRegex(isStrict);
                });

                addWeekParseToken(
                    ["dd", "ddd", "dddd"],
                    function (input, week, config, token) {
                        var weekday = config._locale.weekdaysParse(
                            input,
                            token,
                            config._strict
                        );
                        // if we didn't get a weekday name, mark the date as invalid
                        if (weekday != null) {
                            week.d = weekday;
                        } else {
                            getParsingFlags(config).invalidWeekday = input;
                        }
                    }
                );

                addWeekParseToken(
                    ["d", "e", "E"],
                    function (input, week, config, token) {
                        week[token] = toInt(input);
                    }
                );

                // HELPERS

                function parseWeekday(input, locale) {
                    if (typeof input !== "string") {
                        return input;
                    }

                    if (!isNaN(input)) {
                        return parseInt(input, 10);
                    }

                    input = locale.weekdaysParse(input);
                    if (typeof input === "number") {
                        return input;
                    }

                    return null;
                }

                function parseIsoWeekday(input, locale) {
                    if (typeof input === "string") {
                        return locale.weekdaysParse(input) % 7 || 7;
                    }
                    return isNaN(input) ? null : input;
                }

                // LOCALES
                function shiftWeekdays(ws, n) {
                    return ws.slice(n, 7).concat(ws.slice(0, n));
                }

                var defaultLocaleWeekdays =
                        "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
                            "_"
                        ),
                    defaultLocaleWeekdaysShort =
                        "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                    defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split(
                        "_"
                    ),
                    defaultWeekdaysRegex = matchWord,
                    defaultWeekdaysShortRegex = matchWord,
                    defaultWeekdaysMinRegex = matchWord;

                function localeWeekdays(m, format) {
                    var weekdays = isArray(this._weekdays)
                        ? this._weekdays
                        : this._weekdays[
                              m &&
                              m !== true &&
                              this._weekdays.isFormat.test(format)
                                  ? "format"
                                  : "standalone"
                          ];
                    return m === true
                        ? shiftWeekdays(weekdays, this._week.dow)
                        : m
                        ? weekdays[m.day()]
                        : weekdays;
                }

                function localeWeekdaysShort(m) {
                    return m === true
                        ? shiftWeekdays(this._weekdaysShort, this._week.dow)
                        : m
                        ? this._weekdaysShort[m.day()]
                        : this._weekdaysShort;
                }

                function localeWeekdaysMin(m) {
                    return m === true
                        ? shiftWeekdays(this._weekdaysMin, this._week.dow)
                        : m
                        ? this._weekdaysMin[m.day()]
                        : this._weekdaysMin;
                }

                function handleStrictParse$1(weekdayName, format, strict) {
                    var i,
                        ii,
                        mom,
                        llc = weekdayName.toLocaleLowerCase();
                    if (!this._weekdaysParse) {
                        this._weekdaysParse = [];
                        this._shortWeekdaysParse = [];
                        this._minWeekdaysParse = [];

                        for (i = 0; i < 7; ++i) {
                            mom = createUTC([2000, 1]).day(i);
                            this._minWeekdaysParse[i] = this.weekdaysMin(
                                mom,
                                ""
                            ).toLocaleLowerCase();
                            this._shortWeekdaysParse[i] = this.weekdaysShort(
                                mom,
                                ""
                            ).toLocaleLowerCase();
                            this._weekdaysParse[i] = this.weekdays(
                                mom,
                                ""
                            ).toLocaleLowerCase();
                        }
                    }

                    if (strict) {
                        if (format === "dddd") {
                            ii = indexOf.call(this._weekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        } else if (format === "ddd") {
                            ii = indexOf.call(this._shortWeekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        } else {
                            ii = indexOf.call(this._minWeekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        }
                    } else {
                        if (format === "dddd") {
                            ii = indexOf.call(this._weekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf.call(this._shortWeekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf.call(this._minWeekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        } else if (format === "ddd") {
                            ii = indexOf.call(this._shortWeekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf.call(this._weekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf.call(this._minWeekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        } else {
                            ii = indexOf.call(this._minWeekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf.call(this._weekdaysParse, llc);
                            if (ii !== -1) {
                                return ii;
                            }
                            ii = indexOf.call(this._shortWeekdaysParse, llc);
                            return ii !== -1 ? ii : null;
                        }
                    }
                }

                function localeWeekdaysParse(weekdayName, format, strict) {
                    var i, mom, regex;

                    if (this._weekdaysParseExact) {
                        return handleStrictParse$1.call(
                            this,
                            weekdayName,
                            format,
                            strict
                        );
                    }

                    if (!this._weekdaysParse) {
                        this._weekdaysParse = [];
                        this._minWeekdaysParse = [];
                        this._shortWeekdaysParse = [];
                        this._fullWeekdaysParse = [];
                    }

                    for (i = 0; i < 7; i++) {
                        // make the regex if we don't have it already

                        mom = createUTC([2000, 1]).day(i);
                        if (strict && !this._fullWeekdaysParse[i]) {
                            this._fullWeekdaysParse[i] = new RegExp(
                                "^" +
                                    this.weekdays(mom, "").replace(
                                        ".",
                                        "\\.?"
                                    ) +
                                    "$",
                                "i"
                            );
                            this._shortWeekdaysParse[i] = new RegExp(
                                "^" +
                                    this.weekdaysShort(mom, "").replace(
                                        ".",
                                        "\\.?"
                                    ) +
                                    "$",
                                "i"
                            );
                            this._minWeekdaysParse[i] = new RegExp(
                                "^" +
                                    this.weekdaysMin(mom, "").replace(
                                        ".",
                                        "\\.?"
                                    ) +
                                    "$",
                                "i"
                            );
                        }
                        if (!this._weekdaysParse[i]) {
                            regex =
                                "^" +
                                this.weekdays(mom, "") +
                                "|^" +
                                this.weekdaysShort(mom, "") +
                                "|^" +
                                this.weekdaysMin(mom, "");
                            this._weekdaysParse[i] = new RegExp(
                                regex.replace(".", ""),
                                "i"
                            );
                        }
                        // test the regex
                        if (
                            strict &&
                            format === "dddd" &&
                            this._fullWeekdaysParse[i].test(weekdayName)
                        ) {
                            return i;
                        } else if (
                            strict &&
                            format === "ddd" &&
                            this._shortWeekdaysParse[i].test(weekdayName)
                        ) {
                            return i;
                        } else if (
                            strict &&
                            format === "dd" &&
                            this._minWeekdaysParse[i].test(weekdayName)
                        ) {
                            return i;
                        } else if (
                            !strict &&
                            this._weekdaysParse[i].test(weekdayName)
                        ) {
                            return i;
                        }
                    }
                }

                // MOMENTS

                function getSetDayOfWeek(input) {
                    if (!this.isValid()) {
                        return input != null ? this : NaN;
                    }
                    var day = this._isUTC
                        ? this._d.getUTCDay()
                        : this._d.getDay();
                    if (input != null) {
                        input = parseWeekday(input, this.localeData());
                        return this.add(input - day, "d");
                    } else {
                        return day;
                    }
                }

                function getSetLocaleDayOfWeek(input) {
                    if (!this.isValid()) {
                        return input != null ? this : NaN;
                    }
                    var weekday =
                        (this.day() + 7 - this.localeData()._week.dow) % 7;
                    return input == null
                        ? weekday
                        : this.add(input - weekday, "d");
                }

                function getSetISODayOfWeek(input) {
                    if (!this.isValid()) {
                        return input != null ? this : NaN;
                    }

                    // behaves the same as moment#day except
                    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
                    // as a setter, sunday should belong to the previous week.

                    if (input != null) {
                        var weekday = parseIsoWeekday(input, this.localeData());
                        return this.day(this.day() % 7 ? weekday : weekday - 7);
                    } else {
                        return this.day() || 7;
                    }
                }

                function weekdaysRegex(isStrict) {
                    if (this._weekdaysParseExact) {
                        if (!hasOwnProp(this, "_weekdaysRegex")) {
                            computeWeekdaysParse.call(this);
                        }
                        if (isStrict) {
                            return this._weekdaysStrictRegex;
                        } else {
                            return this._weekdaysRegex;
                        }
                    } else {
                        if (!hasOwnProp(this, "_weekdaysRegex")) {
                            this._weekdaysRegex = defaultWeekdaysRegex;
                        }
                        return this._weekdaysStrictRegex && isStrict
                            ? this._weekdaysStrictRegex
                            : this._weekdaysRegex;
                    }
                }

                function weekdaysShortRegex(isStrict) {
                    if (this._weekdaysParseExact) {
                        if (!hasOwnProp(this, "_weekdaysRegex")) {
                            computeWeekdaysParse.call(this);
                        }
                        if (isStrict) {
                            return this._weekdaysShortStrictRegex;
                        } else {
                            return this._weekdaysShortRegex;
                        }
                    } else {
                        if (!hasOwnProp(this, "_weekdaysShortRegex")) {
                            this._weekdaysShortRegex =
                                defaultWeekdaysShortRegex;
                        }
                        return this._weekdaysShortStrictRegex && isStrict
                            ? this._weekdaysShortStrictRegex
                            : this._weekdaysShortRegex;
                    }
                }

                function weekdaysMinRegex(isStrict) {
                    if (this._weekdaysParseExact) {
                        if (!hasOwnProp(this, "_weekdaysRegex")) {
                            computeWeekdaysParse.call(this);
                        }
                        if (isStrict) {
                            return this._weekdaysMinStrictRegex;
                        } else {
                            return this._weekdaysMinRegex;
                        }
                    } else {
                        if (!hasOwnProp(this, "_weekdaysMinRegex")) {
                            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                        }
                        return this._weekdaysMinStrictRegex && isStrict
                            ? this._weekdaysMinStrictRegex
                            : this._weekdaysMinRegex;
                    }
                }

                function computeWeekdaysParse() {
                    function cmpLenRev(a, b) {
                        return b.length - a.length;
                    }

                    var minPieces = [],
                        shortPieces = [],
                        longPieces = [],
                        mixedPieces = [],
                        i,
                        mom,
                        minp,
                        shortp,
                        longp;
                    for (i = 0; i < 7; i++) {
                        // make the regex if we don't have it already
                        mom = createUTC([2000, 1]).day(i);
                        minp = regexEscape(this.weekdaysMin(mom, ""));
                        shortp = regexEscape(this.weekdaysShort(mom, ""));
                        longp = regexEscape(this.weekdays(mom, ""));
                        minPieces.push(minp);
                        shortPieces.push(shortp);
                        longPieces.push(longp);
                        mixedPieces.push(minp);
                        mixedPieces.push(shortp);
                        mixedPieces.push(longp);
                    }
                    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
                    // will match the longer piece.
                    minPieces.sort(cmpLenRev);
                    shortPieces.sort(cmpLenRev);
                    longPieces.sort(cmpLenRev);
                    mixedPieces.sort(cmpLenRev);

                    this._weekdaysRegex = new RegExp(
                        "^(" + mixedPieces.join("|") + ")",
                        "i"
                    );
                    this._weekdaysShortRegex = this._weekdaysRegex;
                    this._weekdaysMinRegex = this._weekdaysRegex;

                    this._weekdaysStrictRegex = new RegExp(
                        "^(" + longPieces.join("|") + ")",
                        "i"
                    );
                    this._weekdaysShortStrictRegex = new RegExp(
                        "^(" + shortPieces.join("|") + ")",
                        "i"
                    );
                    this._weekdaysMinStrictRegex = new RegExp(
                        "^(" + minPieces.join("|") + ")",
                        "i"
                    );
                }

                // FORMATTING

                function hFormat() {
                    return this.hours() % 12 || 12;
                }

                function kFormat() {
                    return this.hours() || 24;
                }

                addFormatToken("H", ["HH", 2], 0, "hour");
                addFormatToken("h", ["hh", 2], 0, hFormat);
                addFormatToken("k", ["kk", 2], 0, kFormat);

                addFormatToken("hmm", 0, 0, function () {
                    return (
                        "" + hFormat.apply(this) + zeroFill(this.minutes(), 2)
                    );
                });

                addFormatToken("hmmss", 0, 0, function () {
                    return (
                        "" +
                        hFormat.apply(this) +
                        zeroFill(this.minutes(), 2) +
                        zeroFill(this.seconds(), 2)
                    );
                });

                addFormatToken("Hmm", 0, 0, function () {
                    return "" + this.hours() + zeroFill(this.minutes(), 2);
                });

                addFormatToken("Hmmss", 0, 0, function () {
                    return (
                        "" +
                        this.hours() +
                        zeroFill(this.minutes(), 2) +
                        zeroFill(this.seconds(), 2)
                    );
                });

                function meridiem(token, lowercase) {
                    addFormatToken(token, 0, 0, function () {
                        return this.localeData().meridiem(
                            this.hours(),
                            this.minutes(),
                            lowercase
                        );
                    });
                }

                meridiem("a", true);
                meridiem("A", false);

                // ALIASES

                addUnitAlias("hour", "h");

                // PRIORITY
                addUnitPriority("hour", 13);

                // PARSING

                function matchMeridiem(isStrict, locale) {
                    return locale._meridiemParse;
                }

                addRegexToken("a", matchMeridiem);
                addRegexToken("A", matchMeridiem);
                addRegexToken("H", match1to2);
                addRegexToken("h", match1to2);
                addRegexToken("k", match1to2);
                addRegexToken("HH", match1to2, match2);
                addRegexToken("hh", match1to2, match2);
                addRegexToken("kk", match1to2, match2);

                addRegexToken("hmm", match3to4);
                addRegexToken("hmmss", match5to6);
                addRegexToken("Hmm", match3to4);
                addRegexToken("Hmmss", match5to6);

                addParseToken(["H", "HH"], HOUR);
                addParseToken(["k", "kk"], function (input, array, config) {
                    var kInput = toInt(input);
                    array[HOUR] = kInput === 24 ? 0 : kInput;
                });
                addParseToken(["a", "A"], function (input, array, config) {
                    config._isPm = config._locale.isPM(input);
                    config._meridiem = input;
                });
                addParseToken(["h", "hh"], function (input, array, config) {
                    array[HOUR] = toInt(input);
                    getParsingFlags(config).bigHour = true;
                });
                addParseToken("hmm", function (input, array, config) {
                    var pos = input.length - 2;
                    array[HOUR] = toInt(input.substr(0, pos));
                    array[MINUTE] = toInt(input.substr(pos));
                    getParsingFlags(config).bigHour = true;
                });
                addParseToken("hmmss", function (input, array, config) {
                    var pos1 = input.length - 4,
                        pos2 = input.length - 2;
                    array[HOUR] = toInt(input.substr(0, pos1));
                    array[MINUTE] = toInt(input.substr(pos1, 2));
                    array[SECOND] = toInt(input.substr(pos2));
                    getParsingFlags(config).bigHour = true;
                });
                addParseToken("Hmm", function (input, array, config) {
                    var pos = input.length - 2;
                    array[HOUR] = toInt(input.substr(0, pos));
                    array[MINUTE] = toInt(input.substr(pos));
                });
                addParseToken("Hmmss", function (input, array, config) {
                    var pos1 = input.length - 4,
                        pos2 = input.length - 2;
                    array[HOUR] = toInt(input.substr(0, pos1));
                    array[MINUTE] = toInt(input.substr(pos1, 2));
                    array[SECOND] = toInt(input.substr(pos2));
                });

                // LOCALES

                function localeIsPM(input) {
                    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
                    // Using charAt should be more compatible.
                    return (input + "").toLowerCase().charAt(0) === "p";
                }

                var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
                    // Setting the hour should keep the time, because the user explicitly
                    // specified which hour they want. So trying to maintain the same hour (in
                    // a new timezone) makes sense. Adding/subtracting hours does not follow
                    // this rule.
                    getSetHour = makeGetSet("Hours", true);

                function localeMeridiem(hours, minutes, isLower) {
                    if (hours > 11) {
                        return isLower ? "pm" : "PM";
                    } else {
                        return isLower ? "am" : "AM";
                    }
                }

                var baseConfig = {
                    calendar: defaultCalendar,
                    longDateFormat: defaultLongDateFormat,
                    invalidDate: defaultInvalidDate,
                    ordinal: defaultOrdinal,
                    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
                    relativeTime: defaultRelativeTime,

                    months: defaultLocaleMonths,
                    monthsShort: defaultLocaleMonthsShort,

                    week: defaultLocaleWeek,

                    weekdays: defaultLocaleWeekdays,
                    weekdaysMin: defaultLocaleWeekdaysMin,
                    weekdaysShort: defaultLocaleWeekdaysShort,

                    meridiemParse: defaultLocaleMeridiemParse,
                };

                // internal storage for locale config files
                var locales = {},
                    localeFamilies = {},
                    globalLocale;

                function commonPrefix(arr1, arr2) {
                    var i,
                        minl = Math.min(arr1.length, arr2.length);
                    for (i = 0; i < minl; i += 1) {
                        if (arr1[i] !== arr2[i]) {
                            return i;
                        }
                    }
                    return minl;
                }

                function normalizeLocale(key) {
                    return key ? key.toLowerCase().replace("_", "-") : key;
                }

                // pick the locale from the array
                // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
                // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
                function chooseLocale(names) {
                    var i = 0,
                        j,
                        next,
                        locale,
                        split;

                    while (i < names.length) {
                        split = normalizeLocale(names[i]).split("-");
                        j = split.length;
                        next = normalizeLocale(names[i + 1]);
                        next = next ? next.split("-") : null;
                        while (j > 0) {
                            locale = loadLocale(split.slice(0, j).join("-"));
                            if (locale) {
                                return locale;
                            }
                            if (
                                next &&
                                next.length >= j &&
                                commonPrefix(split, next) >= j - 1
                            ) {
                                //the next array item is better than a shallower substring of this one
                                break;
                            }
                            j--;
                        }
                        i++;
                    }
                    return globalLocale;
                }

                function loadLocale(name) {
                    var oldLocale = null,
                        aliasedRequire;
                    // TODO: Find a better way to register and load all the locales in Node
                    if (
                        locales[name] === undefined &&
                        "object" !== "undefined" &&
                        module &&
                        module.exports
                    ) {
                        try {
                            oldLocale = globalLocale._abbr;
                            aliasedRequire = require;
                            aliasedRequire("./locale/" + name);
                            getSetGlobalLocale(oldLocale);
                        } catch (e) {
                            // mark as not found to avoid repeating expensive file require call causing high CPU
                            // when trying to find en-US, en_US, en-us for every format call
                            locales[name] = null; // null means not found
                        }
                    }
                    return locales[name];
                }

                // This function will load locale and then set the global locale.  If
                // no arguments are passed in, it will simply return the current global
                // locale key.
                function getSetGlobalLocale(key, values) {
                    var data;
                    if (key) {
                        if (isUndefined(values)) {
                            data = getLocale(key);
                        } else {
                            data = defineLocale(key, values);
                        }

                        if (data) {
                            // moment.duration._locale = moment._locale = data;
                            globalLocale = data;
                        } else {
                            if (
                                typeof console !== "undefined" &&
                                console.warn
                            ) {
                                //warn user if arguments are passed but the locale could not be set
                                console.warn(
                                    "Locale " +
                                        key +
                                        " not found. Did you forget to load it?"
                                );
                            }
                        }
                    }

                    return globalLocale._abbr;
                }

                function defineLocale(name, config) {
                    if (config !== null) {
                        var locale,
                            parentConfig = baseConfig;
                        config.abbr = name;
                        if (locales[name] != null) {
                            deprecateSimple(
                                "defineLocaleOverride",
                                "use moment.updateLocale(localeName, config) to change " +
                                    "an existing locale. moment.defineLocale(localeName, " +
                                    "config) should only be used for creating a new locale " +
                                    "See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
                            );
                            parentConfig = locales[name]._config;
                        } else if (config.parentLocale != null) {
                            if (locales[config.parentLocale] != null) {
                                parentConfig =
                                    locales[config.parentLocale]._config;
                            } else {
                                locale = loadLocale(config.parentLocale);
                                if (locale != null) {
                                    parentConfig = locale._config;
                                } else {
                                    if (!localeFamilies[config.parentLocale]) {
                                        localeFamilies[config.parentLocale] =
                                            [];
                                    }
                                    localeFamilies[config.parentLocale].push({
                                        name: name,
                                        config: config,
                                    });
                                    return null;
                                }
                            }
                        }
                        locales[name] = new Locale(
                            mergeConfigs(parentConfig, config)
                        );

                        if (localeFamilies[name]) {
                            localeFamilies[name].forEach(function (x) {
                                defineLocale(x.name, x.config);
                            });
                        }

                        // backwards compat for now: also set the locale
                        // make sure we set the locale AFTER all child locales have been
                        // created, so we won't end up with the child locale set.
                        getSetGlobalLocale(name);

                        return locales[name];
                    } else {
                        // useful for testing
                        delete locales[name];
                        return null;
                    }
                }

                function updateLocale(name, config) {
                    if (config != null) {
                        var locale,
                            tmpLocale,
                            parentConfig = baseConfig;

                        if (
                            locales[name] != null &&
                            locales[name].parentLocale != null
                        ) {
                            // Update existing child locale in-place to avoid memory-leaks
                            locales[name].set(
                                mergeConfigs(locales[name]._config, config)
                            );
                        } else {
                            // MERGE
                            tmpLocale = loadLocale(name);
                            if (tmpLocale != null) {
                                parentConfig = tmpLocale._config;
                            }
                            config = mergeConfigs(parentConfig, config);
                            if (tmpLocale == null) {
                                // updateLocale is called for creating a new locale
                                // Set abbr so it will have a name (getters return
                                // undefined otherwise).
                                config.abbr = name;
                            }
                            locale = new Locale(config);
                            locale.parentLocale = locales[name];
                            locales[name] = locale;
                        }

                        // backwards compat for now: also set the locale
                        getSetGlobalLocale(name);
                    } else {
                        // pass null for config to unupdate, useful for tests
                        if (locales[name] != null) {
                            if (locales[name].parentLocale != null) {
                                locales[name] = locales[name].parentLocale;
                                if (name === getSetGlobalLocale()) {
                                    getSetGlobalLocale(name);
                                }
                            } else if (locales[name] != null) {
                                delete locales[name];
                            }
                        }
                    }
                    return locales[name];
                }

                // returns locale data
                function getLocale(key) {
                    var locale;

                    if (key && key._locale && key._locale._abbr) {
                        key = key._locale._abbr;
                    }

                    if (!key) {
                        return globalLocale;
                    }

                    if (!isArray(key)) {
                        //short-circuit everything else
                        locale = loadLocale(key);
                        if (locale) {
                            return locale;
                        }
                        key = [key];
                    }

                    return chooseLocale(key);
                }

                function listLocales() {
                    return keys(locales);
                }

                function checkOverflow(m) {
                    var overflow,
                        a = m._a;

                    if (a && getParsingFlags(m).overflow === -2) {
                        overflow =
                            a[MONTH] < 0 || a[MONTH] > 11
                                ? MONTH
                                : a[DATE] < 1 ||
                                  a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                                ? DATE
                                : a[HOUR] < 0 ||
                                  a[HOUR] > 24 ||
                                  (a[HOUR] === 24 &&
                                      (a[MINUTE] !== 0 ||
                                          a[SECOND] !== 0 ||
                                          a[MILLISECOND] !== 0))
                                ? HOUR
                                : a[MINUTE] < 0 || a[MINUTE] > 59
                                ? MINUTE
                                : a[SECOND] < 0 || a[SECOND] > 59
                                ? SECOND
                                : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                                ? MILLISECOND
                                : -1;

                        if (
                            getParsingFlags(m)._overflowDayOfYear &&
                            (overflow < YEAR || overflow > DATE)
                        ) {
                            overflow = DATE;
                        }
                        if (
                            getParsingFlags(m)._overflowWeeks &&
                            overflow === -1
                        ) {
                            overflow = WEEK;
                        }
                        if (
                            getParsingFlags(m)._overflowWeekday &&
                            overflow === -1
                        ) {
                            overflow = WEEKDAY;
                        }

                        getParsingFlags(m).overflow = overflow;
                    }

                    return m;
                }

                // iso 8601 regex
                // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
                var extendedIsoRegex =
                        /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
                    basicIsoRegex =
                        /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
                    tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
                    isoDates = [
                        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
                        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
                        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
                        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
                        ["YYYY-DDD", /\d{4}-\d{3}/],
                        ["YYYY-MM", /\d{4}-\d\d/, false],
                        ["YYYYYYMMDD", /[+-]\d{10}/],
                        ["YYYYMMDD", /\d{8}/],
                        ["GGGG[W]WWE", /\d{4}W\d{3}/],
                        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
                        ["YYYYDDD", /\d{7}/],
                        ["YYYYMM", /\d{6}/, false],
                        ["YYYY", /\d{4}/, false],
                    ],
                    // iso time formats and regexes
                    isoTimes = [
                        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
                        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
                        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
                        ["HH:mm", /\d\d:\d\d/],
                        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
                        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
                        ["HHmmss", /\d\d\d\d\d\d/],
                        ["HHmm", /\d\d\d\d/],
                        ["HH", /\d\d/],
                    ],
                    aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
                    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
                    rfc2822 =
                        /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
                    obsOffsets = {
                        UT: 0,
                        GMT: 0,
                        EDT: -4 * 60,
                        EST: -5 * 60,
                        CDT: -5 * 60,
                        CST: -6 * 60,
                        MDT: -6 * 60,
                        MST: -7 * 60,
                        PDT: -7 * 60,
                        PST: -8 * 60,
                    };

                // date from iso format
                function configFromISO(config) {
                    var i,
                        l,
                        string = config._i,
                        match =
                            extendedIsoRegex.exec(string) ||
                            basicIsoRegex.exec(string),
                        allowTime,
                        dateFormat,
                        timeFormat,
                        tzFormat;

                    if (match) {
                        getParsingFlags(config).iso = true;

                        for (i = 0, l = isoDates.length; i < l; i++) {
                            if (isoDates[i][1].exec(match[1])) {
                                dateFormat = isoDates[i][0];
                                allowTime = isoDates[i][2] !== false;
                                break;
                            }
                        }
                        if (dateFormat == null) {
                            config._isValid = false;
                            return;
                        }
                        if (match[3]) {
                            for (i = 0, l = isoTimes.length; i < l; i++) {
                                if (isoTimes[i][1].exec(match[3])) {
                                    // match[2] should be 'T' or space
                                    timeFormat =
                                        (match[2] || " ") + isoTimes[i][0];
                                    break;
                                }
                            }
                            if (timeFormat == null) {
                                config._isValid = false;
                                return;
                            }
                        }
                        if (!allowTime && timeFormat != null) {
                            config._isValid = false;
                            return;
                        }
                        if (match[4]) {
                            if (tzRegex.exec(match[4])) {
                                tzFormat = "Z";
                            } else {
                                config._isValid = false;
                                return;
                            }
                        }
                        config._f =
                            dateFormat + (timeFormat || "") + (tzFormat || "");
                        configFromStringAndFormat(config);
                    } else {
                        config._isValid = false;
                    }
                }

                function extractFromRFC2822Strings(
                    yearStr,
                    monthStr,
                    dayStr,
                    hourStr,
                    minuteStr,
                    secondStr
                ) {
                    var result = [
                        untruncateYear(yearStr),
                        defaultLocaleMonthsShort.indexOf(monthStr),
                        parseInt(dayStr, 10),
                        parseInt(hourStr, 10),
                        parseInt(minuteStr, 10),
                    ];

                    if (secondStr) {
                        result.push(parseInt(secondStr, 10));
                    }

                    return result;
                }

                function untruncateYear(yearStr) {
                    var year = parseInt(yearStr, 10);
                    if (year <= 49) {
                        return 2000 + year;
                    } else if (year <= 999) {
                        return 1900 + year;
                    }
                    return year;
                }

                function preprocessRFC2822(s) {
                    // Remove comments and folding whitespace and replace multiple-spaces with a single space
                    return s
                        .replace(/\([^)]*\)|[\n\t]/g, " ")
                        .replace(/(\s\s+)/g, " ")
                        .replace(/^\s\s*/, "")
                        .replace(/\s\s*$/, "");
                }

                function checkWeekday(weekdayStr, parsedInput, config) {
                    if (weekdayStr) {
                        // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
                        var weekdayProvided =
                                defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                            weekdayActual = new Date(
                                parsedInput[0],
                                parsedInput[1],
                                parsedInput[2]
                            ).getDay();
                        if (weekdayProvided !== weekdayActual) {
                            getParsingFlags(config).weekdayMismatch = true;
                            config._isValid = false;
                            return false;
                        }
                    }
                    return true;
                }

                function calculateOffset(obsOffset, militaryOffset, numOffset) {
                    if (obsOffset) {
                        return obsOffsets[obsOffset];
                    } else if (militaryOffset) {
                        // the only allowed military tz is Z
                        return 0;
                    } else {
                        var hm = parseInt(numOffset, 10),
                            m = hm % 100,
                            h = (hm - m) / 100;
                        return h * 60 + m;
                    }
                }

                // date and time from ref 2822 format
                function configFromRFC2822(config) {
                    var match = rfc2822.exec(preprocessRFC2822(config._i)),
                        parsedArray;
                    if (match) {
                        parsedArray = extractFromRFC2822Strings(
                            match[4],
                            match[3],
                            match[2],
                            match[5],
                            match[6],
                            match[7]
                        );
                        if (!checkWeekday(match[1], parsedArray, config)) {
                            return;
                        }

                        config._a = parsedArray;
                        config._tzm = calculateOffset(
                            match[8],
                            match[9],
                            match[10]
                        );

                        config._d = createUTCDate.apply(null, config._a);
                        config._d.setUTCMinutes(
                            config._d.getUTCMinutes() - config._tzm
                        );

                        getParsingFlags(config).rfc2822 = true;
                    } else {
                        config._isValid = false;
                    }
                }

                // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
                function configFromString(config) {
                    var matched = aspNetJsonRegex.exec(config._i);
                    if (matched !== null) {
                        config._d = new Date(+matched[1]);
                        return;
                    }

                    configFromISO(config);
                    if (config._isValid === false) {
                        delete config._isValid;
                    } else {
                        return;
                    }

                    configFromRFC2822(config);
                    if (config._isValid === false) {
                        delete config._isValid;
                    } else {
                        return;
                    }

                    if (config._strict) {
                        config._isValid = false;
                    } else {
                        // Final attempt, use Input Fallback
                        hooks.createFromInputFallback(config);
                    }
                }

                hooks.createFromInputFallback = deprecate(
                    "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), " +
                        "which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are " +
                        "discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
                    function (config) {
                        config._d = new Date(
                            config._i + (config._useUTC ? " UTC" : "")
                        );
                    }
                );

                // Pick the first defined of two or three arguments.
                function defaults(a, b, c) {
                    if (a != null) {
                        return a;
                    }
                    if (b != null) {
                        return b;
                    }
                    return c;
                }

                function currentDateArray(config) {
                    // hooks is actually the exported moment object
                    var nowValue = new Date(hooks.now());
                    if (config._useUTC) {
                        return [
                            nowValue.getUTCFullYear(),
                            nowValue.getUTCMonth(),
                            nowValue.getUTCDate(),
                        ];
                    }
                    return [
                        nowValue.getFullYear(),
                        nowValue.getMonth(),
                        nowValue.getDate(),
                    ];
                }

                // convert an array to a date.
                // the array should mirror the parameters below
                // note: all values past the year are optional and will default to the lowest possible value.
                // [year, month, day , hour, minute, second, millisecond]
                function configFromArray(config) {
                    var i,
                        date,
                        input = [],
                        currentDate,
                        expectedWeekday,
                        yearToUse;

                    if (config._d) {
                        return;
                    }

                    currentDate = currentDateArray(config);

                    //compute day of the year from weeks and weekdays
                    if (
                        config._w &&
                        config._a[DATE] == null &&
                        config._a[MONTH] == null
                    ) {
                        dayOfYearFromWeekInfo(config);
                    }

                    //if the day of the year is set, figure out what it is
                    if (config._dayOfYear != null) {
                        yearToUse = defaults(
                            config._a[YEAR],
                            currentDate[YEAR]
                        );

                        if (
                            config._dayOfYear > daysInYear(yearToUse) ||
                            config._dayOfYear === 0
                        ) {
                            getParsingFlags(config)._overflowDayOfYear = true;
                        }

                        date = createUTCDate(yearToUse, 0, config._dayOfYear);
                        config._a[MONTH] = date.getUTCMonth();
                        config._a[DATE] = date.getUTCDate();
                    }

                    // Default to current date.
                    // * if no year, month, day of month are given, default to today
                    // * if day of month is given, default month and year
                    // * if month is given, default only year
                    // * if year is given, don't default anything
                    for (i = 0; i < 3 && config._a[i] == null; ++i) {
                        config._a[i] = input[i] = currentDate[i];
                    }

                    // Zero out whatever was not defaulted, including time
                    for (; i < 7; i++) {
                        config._a[i] = input[i] =
                            config._a[i] == null
                                ? i === 2
                                    ? 1
                                    : 0
                                : config._a[i];
                    }

                    // Check for 24:00:00.000
                    if (
                        config._a[HOUR] === 24 &&
                        config._a[MINUTE] === 0 &&
                        config._a[SECOND] === 0 &&
                        config._a[MILLISECOND] === 0
                    ) {
                        config._nextDay = true;
                        config._a[HOUR] = 0;
                    }

                    config._d = (
                        config._useUTC ? createUTCDate : createDate
                    ).apply(null, input);
                    expectedWeekday = config._useUTC
                        ? config._d.getUTCDay()
                        : config._d.getDay();

                    // Apply timezone offset from input. The actual utcOffset can be changed
                    // with parseZone.
                    if (config._tzm != null) {
                        config._d.setUTCMinutes(
                            config._d.getUTCMinutes() - config._tzm
                        );
                    }

                    if (config._nextDay) {
                        config._a[HOUR] = 24;
                    }

                    // check for mismatching day of week
                    if (
                        config._w &&
                        typeof config._w.d !== "undefined" &&
                        config._w.d !== expectedWeekday
                    ) {
                        getParsingFlags(config).weekdayMismatch = true;
                    }
                }

                function dayOfYearFromWeekInfo(config) {
                    var w,
                        weekYear,
                        week,
                        weekday,
                        dow,
                        doy,
                        temp,
                        weekdayOverflow,
                        curWeek;

                    w = config._w;
                    if (w.GG != null || w.W != null || w.E != null) {
                        dow = 1;
                        doy = 4;

                        // TODO: We need to take the current isoWeekYear, but that depends on
                        // how we interpret now (local, utc, fixed offset). So create
                        // a now version of current config (take local/utc/offset flags, and
                        // create now).
                        weekYear = defaults(
                            w.GG,
                            config._a[YEAR],
                            weekOfYear(createLocal(), 1, 4).year
                        );
                        week = defaults(w.W, 1);
                        weekday = defaults(w.E, 1);
                        if (weekday < 1 || weekday > 7) {
                            weekdayOverflow = true;
                        }
                    } else {
                        dow = config._locale._week.dow;
                        doy = config._locale._week.doy;

                        curWeek = weekOfYear(createLocal(), dow, doy);

                        weekYear = defaults(
                            w.gg,
                            config._a[YEAR],
                            curWeek.year
                        );

                        // Default to current week.
                        week = defaults(w.w, curWeek.week);

                        if (w.d != null) {
                            // weekday -- low day numbers are considered next week
                            weekday = w.d;
                            if (weekday < 0 || weekday > 6) {
                                weekdayOverflow = true;
                            }
                        } else if (w.e != null) {
                            // local weekday -- counting starts from beginning of week
                            weekday = w.e + dow;
                            if (w.e < 0 || w.e > 6) {
                                weekdayOverflow = true;
                            }
                        } else {
                            // default to beginning of week
                            weekday = dow;
                        }
                    }
                    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                        getParsingFlags(config)._overflowWeeks = true;
                    } else if (weekdayOverflow != null) {
                        getParsingFlags(config)._overflowWeekday = true;
                    } else {
                        temp = dayOfYearFromWeeks(
                            weekYear,
                            week,
                            weekday,
                            dow,
                            doy
                        );
                        config._a[YEAR] = temp.year;
                        config._dayOfYear = temp.dayOfYear;
                    }
                }

                // constant that refers to the ISO standard
                hooks.ISO_8601 = function () {};

                // constant that refers to the RFC 2822 form
                hooks.RFC_2822 = function () {};

                // date from string and format string
                function configFromStringAndFormat(config) {
                    // TODO: Move this to another part of the creation flow to prevent circular deps
                    if (config._f === hooks.ISO_8601) {
                        configFromISO(config);
                        return;
                    }
                    if (config._f === hooks.RFC_2822) {
                        configFromRFC2822(config);
                        return;
                    }
                    config._a = [];
                    getParsingFlags(config).empty = true;

                    // This array is used to make a Date, either with `new Date` or `Date.UTC`
                    var string = "" + config._i,
                        i,
                        parsedInput,
                        tokens,
                        token,
                        skipped,
                        stringLength = string.length,
                        totalParsedInputLength = 0,
                        era;

                    tokens =
                        expandFormat(config._f, config._locale).match(
                            formattingTokens
                        ) || [];

                    for (i = 0; i < tokens.length; i++) {
                        token = tokens[i];
                        parsedInput = (string.match(
                            getParseRegexForToken(token, config)
                        ) || [])[0];
                        if (parsedInput) {
                            skipped = string.substr(
                                0,
                                string.indexOf(parsedInput)
                            );
                            if (skipped.length > 0) {
                                getParsingFlags(config).unusedInput.push(
                                    skipped
                                );
                            }
                            string = string.slice(
                                string.indexOf(parsedInput) + parsedInput.length
                            );
                            totalParsedInputLength += parsedInput.length;
                        }
                        // don't parse if it's not a known token
                        if (formatTokenFunctions[token]) {
                            if (parsedInput) {
                                getParsingFlags(config).empty = false;
                            } else {
                                getParsingFlags(config).unusedTokens.push(
                                    token
                                );
                            }
                            addTimeToArrayFromToken(token, parsedInput, config);
                        } else if (config._strict && !parsedInput) {
                            getParsingFlags(config).unusedTokens.push(token);
                        }
                    }

                    // add remaining unparsed input length to the string
                    getParsingFlags(config).charsLeftOver =
                        stringLength - totalParsedInputLength;
                    if (string.length > 0) {
                        getParsingFlags(config).unusedInput.push(string);
                    }

                    // clear _12h flag if hour is <= 12
                    if (
                        config._a[HOUR] <= 12 &&
                        getParsingFlags(config).bigHour === true &&
                        config._a[HOUR] > 0
                    ) {
                        getParsingFlags(config).bigHour = undefined;
                    }

                    getParsingFlags(config).parsedDateParts =
                        config._a.slice(0);
                    getParsingFlags(config).meridiem = config._meridiem;
                    // handle meridiem
                    config._a[HOUR] = meridiemFixWrap(
                        config._locale,
                        config._a[HOUR],
                        config._meridiem
                    );

                    // handle era
                    era = getParsingFlags(config).era;
                    if (era !== null) {
                        config._a[YEAR] = config._locale.erasConvertYear(
                            era,
                            config._a[YEAR]
                        );
                    }

                    configFromArray(config);
                    checkOverflow(config);
                }

                function meridiemFixWrap(locale, hour, meridiem) {
                    var isPm;

                    if (meridiem == null) {
                        // nothing to do
                        return hour;
                    }
                    if (locale.meridiemHour != null) {
                        return locale.meridiemHour(hour, meridiem);
                    } else if (locale.isPM != null) {
                        // Fallback
                        isPm = locale.isPM(meridiem);
                        if (isPm && hour < 12) {
                            hour += 12;
                        }
                        if (!isPm && hour === 12) {
                            hour = 0;
                        }
                        return hour;
                    } else {
                        // this is not supposed to happen
                        return hour;
                    }
                }

                // date from string and array of format strings
                function configFromStringAndArray(config) {
                    var tempConfig,
                        bestMoment,
                        scoreToBeat,
                        i,
                        currentScore,
                        validFormatFound,
                        bestFormatIsValid = false;

                    if (config._f.length === 0) {
                        getParsingFlags(config).invalidFormat = true;
                        config._d = new Date(NaN);
                        return;
                    }

                    for (i = 0; i < config._f.length; i++) {
                        currentScore = 0;
                        validFormatFound = false;
                        tempConfig = copyConfig({}, config);
                        if (config._useUTC != null) {
                            tempConfig._useUTC = config._useUTC;
                        }
                        tempConfig._f = config._f[i];
                        configFromStringAndFormat(tempConfig);

                        if (isValid(tempConfig)) {
                            validFormatFound = true;
                        }

                        // if there is any input that was not parsed add a penalty for that format
                        currentScore +=
                            getParsingFlags(tempConfig).charsLeftOver;

                        //or tokens
                        currentScore +=
                            getParsingFlags(tempConfig).unusedTokens.length *
                            10;

                        getParsingFlags(tempConfig).score = currentScore;

                        if (!bestFormatIsValid) {
                            if (
                                scoreToBeat == null ||
                                currentScore < scoreToBeat ||
                                validFormatFound
                            ) {
                                scoreToBeat = currentScore;
                                bestMoment = tempConfig;
                                if (validFormatFound) {
                                    bestFormatIsValid = true;
                                }
                            }
                        } else {
                            if (currentScore < scoreToBeat) {
                                scoreToBeat = currentScore;
                                bestMoment = tempConfig;
                            }
                        }
                    }

                    extend(config, bestMoment || tempConfig);
                }

                function configFromObject(config) {
                    if (config._d) {
                        return;
                    }

                    var i = normalizeObjectUnits(config._i),
                        dayOrDate = i.day === undefined ? i.date : i.day;
                    config._a = map(
                        [
                            i.year,
                            i.month,
                            dayOrDate,
                            i.hour,
                            i.minute,
                            i.second,
                            i.millisecond,
                        ],
                        function (obj) {
                            return obj && parseInt(obj, 10);
                        }
                    );

                    configFromArray(config);
                }

                function createFromConfig(config) {
                    var res = new Moment(checkOverflow(prepareConfig(config)));
                    if (res._nextDay) {
                        // Adding is smart enough around DST
                        res.add(1, "d");
                        res._nextDay = undefined;
                    }

                    return res;
                }

                function prepareConfig(config) {
                    var input = config._i,
                        format = config._f;

                    config._locale = config._locale || getLocale(config._l);

                    if (
                        input === null ||
                        (format === undefined && input === "")
                    ) {
                        return createInvalid({ nullInput: true });
                    }

                    if (typeof input === "string") {
                        config._i = input = config._locale.preparse(input);
                    }

                    if (isMoment(input)) {
                        return new Moment(checkOverflow(input));
                    } else if (isDate(input)) {
                        config._d = input;
                    } else if (isArray(format)) {
                        configFromStringAndArray(config);
                    } else if (format) {
                        configFromStringAndFormat(config);
                    } else {
                        configFromInput(config);
                    }

                    if (!isValid(config)) {
                        config._d = null;
                    }

                    return config;
                }

                function configFromInput(config) {
                    var input = config._i;
                    if (isUndefined(input)) {
                        config._d = new Date(hooks.now());
                    } else if (isDate(input)) {
                        config._d = new Date(input.valueOf());
                    } else if (typeof input === "string") {
                        configFromString(config);
                    } else if (isArray(input)) {
                        config._a = map(input.slice(0), function (obj) {
                            return parseInt(obj, 10);
                        });
                        configFromArray(config);
                    } else if (isObject(input)) {
                        configFromObject(config);
                    } else if (isNumber(input)) {
                        // from milliseconds
                        config._d = new Date(input);
                    } else {
                        hooks.createFromInputFallback(config);
                    }
                }

                function createLocalOrUTC(
                    input,
                    format,
                    locale,
                    strict,
                    isUTC
                ) {
                    var c = {};

                    if (format === true || format === false) {
                        strict = format;
                        format = undefined;
                    }

                    if (locale === true || locale === false) {
                        strict = locale;
                        locale = undefined;
                    }

                    if (
                        (isObject(input) && isObjectEmpty(input)) ||
                        (isArray(input) && input.length === 0)
                    ) {
                        input = undefined;
                    }
                    // object construction must be done this way.
                    // https://github.com/moment/moment/issues/1423
                    c._isAMomentObject = true;
                    c._useUTC = c._isUTC = isUTC;
                    c._l = locale;
                    c._i = input;
                    c._f = format;
                    c._strict = strict;

                    return createFromConfig(c);
                }

                function createLocal(input, format, locale, strict) {
                    return createLocalOrUTC(
                        input,
                        format,
                        locale,
                        strict,
                        false
                    );
                }

                var prototypeMin = deprecate(
                        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
                        function () {
                            var other = createLocal.apply(null, arguments);
                            if (this.isValid() && other.isValid()) {
                                return other < this ? this : other;
                            } else {
                                return createInvalid();
                            }
                        }
                    ),
                    prototypeMax = deprecate(
                        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
                        function () {
                            var other = createLocal.apply(null, arguments);
                            if (this.isValid() && other.isValid()) {
                                return other > this ? this : other;
                            } else {
                                return createInvalid();
                            }
                        }
                    );

                // Pick a moment m from moments so that m[fn](other) is true for all
                // other. This relies on the function fn to be transitive.
                //
                // moments should either be an array of moment objects or an array, whose
                // first element is an array of moment objects.
                function pickBy(fn, moments) {
                    var res, i;
                    if (moments.length === 1 && isArray(moments[0])) {
                        moments = moments[0];
                    }
                    if (!moments.length) {
                        return createLocal();
                    }
                    res = moments[0];
                    for (i = 1; i < moments.length; ++i) {
                        if (!moments[i].isValid() || moments[i][fn](res)) {
                            res = moments[i];
                        }
                    }
                    return res;
                }

                // TODO: Use [].sort instead?
                function min() {
                    var args = [].slice.call(arguments, 0);

                    return pickBy("isBefore", args);
                }

                function max() {
                    var args = [].slice.call(arguments, 0);

                    return pickBy("isAfter", args);
                }

                var now = function () {
                    return Date.now ? Date.now() : +new Date();
                };

                var ordering = [
                    "year",
                    "quarter",
                    "month",
                    "week",
                    "day",
                    "hour",
                    "minute",
                    "second",
                    "millisecond",
                ];

                function isDurationValid(m) {
                    var key,
                        unitHasDecimal = false,
                        i;
                    for (key in m) {
                        if (
                            hasOwnProp(m, key) &&
                            !(
                                indexOf.call(ordering, key) !== -1 &&
                                (m[key] == null || !isNaN(m[key]))
                            )
                        ) {
                            return false;
                        }
                    }

                    for (i = 0; i < ordering.length; ++i) {
                        if (m[ordering[i]]) {
                            if (unitHasDecimal) {
                                return false; // only allow non-integers for smallest unit
                            }
                            if (
                                parseFloat(m[ordering[i]]) !==
                                toInt(m[ordering[i]])
                            ) {
                                unitHasDecimal = true;
                            }
                        }
                    }

                    return true;
                }

                function isValid$1() {
                    return this._isValid;
                }

                function createInvalid$1() {
                    return createDuration(NaN);
                }

                function Duration(duration) {
                    var normalizedInput = normalizeObjectUnits(duration),
                        years = normalizedInput.year || 0,
                        quarters = normalizedInput.quarter || 0,
                        months = normalizedInput.month || 0,
                        weeks =
                            normalizedInput.week ||
                            normalizedInput.isoWeek ||
                            0,
                        days = normalizedInput.day || 0,
                        hours = normalizedInput.hour || 0,
                        minutes = normalizedInput.minute || 0,
                        seconds = normalizedInput.second || 0,
                        milliseconds = normalizedInput.millisecond || 0;

                    this._isValid = isDurationValid(normalizedInput);

                    // representation for dateAddRemove
                    this._milliseconds =
                        +milliseconds +
                        seconds * 1e3 + // 1000
                        minutes * 6e4 + // 1000 * 60
                        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
                    // Because of dateAddRemove treats 24 hours as different from a
                    // day when working around DST, we need to store them separately
                    this._days = +days + weeks * 7;
                    // It is impossible to translate months into days without knowing
                    // which months you are are talking about, so we have to store
                    // it separately.
                    this._months = +months + quarters * 3 + years * 12;

                    this._data = {};

                    this._locale = getLocale();

                    this._bubble();
                }

                function isDuration(obj) {
                    return obj instanceof Duration;
                }

                function absRound(number) {
                    if (number < 0) {
                        return Math.round(-1 * number) * -1;
                    } else {
                        return Math.round(number);
                    }
                }

                // compare two arrays, return the number of differences
                function compareArrays(array1, array2, dontConvert) {
                    var len = Math.min(array1.length, array2.length),
                        lengthDiff = Math.abs(array1.length - array2.length),
                        diffs = 0,
                        i;
                    for (i = 0; i < len; i++) {
                        if (
                            (dontConvert && array1[i] !== array2[i]) ||
                            (!dontConvert &&
                                toInt(array1[i]) !== toInt(array2[i]))
                        ) {
                            diffs++;
                        }
                    }
                    return diffs + lengthDiff;
                }

                // FORMATTING

                function offset(token, separator) {
                    addFormatToken(token, 0, 0, function () {
                        var offset = this.utcOffset(),
                            sign = "+";
                        if (offset < 0) {
                            offset = -offset;
                            sign = "-";
                        }
                        return (
                            sign +
                            zeroFill(~~(offset / 60), 2) +
                            separator +
                            zeroFill(~~offset % 60, 2)
                        );
                    });
                }

                offset("Z", ":");
                offset("ZZ", "");

                // PARSING

                addRegexToken("Z", matchShortOffset);
                addRegexToken("ZZ", matchShortOffset);
                addParseToken(["Z", "ZZ"], function (input, array, config) {
                    config._useUTC = true;
                    config._tzm = offsetFromString(matchShortOffset, input);
                });

                // HELPERS

                // timezone chunker
                // '+10:00' > ['10',  '00']
                // '-1530'  > ['-15', '30']
                var chunkOffset = /([\+\-]|\d\d)/gi;

                function offsetFromString(matcher, string) {
                    var matches = (string || "").match(matcher),
                        chunk,
                        parts,
                        minutes;

                    if (matches === null) {
                        return null;
                    }

                    chunk = matches[matches.length - 1] || [];
                    parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
                    minutes = +(parts[1] * 60) + toInt(parts[2]);

                    return minutes === 0
                        ? 0
                        : parts[0] === "+"
                        ? minutes
                        : -minutes;
                }

                // Return a moment from input, that is local/utc/zone equivalent to model.
                function cloneWithOffset(input, model) {
                    var res, diff;
                    if (model._isUTC) {
                        res = model.clone();
                        diff =
                            (isMoment(input) || isDate(input)
                                ? input.valueOf()
                                : createLocal(input).valueOf()) - res.valueOf();
                        // Use low-level api, because this fn is low-level api.
                        res._d.setTime(res._d.valueOf() + diff);
                        hooks.updateOffset(res, false);
                        return res;
                    } else {
                        return createLocal(input).local();
                    }
                }

                function getDateOffset(m) {
                    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
                    // https://github.com/moment/moment/pull/1871
                    return -Math.round(m._d.getTimezoneOffset());
                }

                // HOOKS

                // This function will be called whenever a moment is mutated.
                // It is intended to keep the offset in sync with the timezone.
                hooks.updateOffset = function () {};

                // MOMENTS

                // keepLocalTime = true means only change the timezone, without
                // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
                // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
                // +0200, so we adjust the time as needed, to be valid.
                //
                // Keeping the time actually adds/subtracts (one hour)
                // from the actual represented time. That is why we call updateOffset
                // a second time. In case it wants us to change the offset again
                // _changeInProgress == true case, then we have to adjust, because
                // there is no such time in the given timezone.
                function getSetOffset(input, keepLocalTime, keepMinutes) {
                    var offset = this._offset || 0,
                        localAdjust;
                    if (!this.isValid()) {
                        return input != null ? this : NaN;
                    }
                    if (input != null) {
                        if (typeof input === "string") {
                            input = offsetFromString(matchShortOffset, input);
                            if (input === null) {
                                return this;
                            }
                        } else if (Math.abs(input) < 16 && !keepMinutes) {
                            input = input * 60;
                        }
                        if (!this._isUTC && keepLocalTime) {
                            localAdjust = getDateOffset(this);
                        }
                        this._offset = input;
                        this._isUTC = true;
                        if (localAdjust != null) {
                            this.add(localAdjust, "m");
                        }
                        if (offset !== input) {
                            if (!keepLocalTime || this._changeInProgress) {
                                addSubtract(
                                    this,
                                    createDuration(input - offset, "m"),
                                    1,
                                    false
                                );
                            } else if (!this._changeInProgress) {
                                this._changeInProgress = true;
                                hooks.updateOffset(this, true);
                                this._changeInProgress = null;
                            }
                        }
                        return this;
                    } else {
                        return this._isUTC ? offset : getDateOffset(this);
                    }
                }

                function getSetZone(input, keepLocalTime) {
                    if (input != null) {
                        if (typeof input !== "string") {
                            input = -input;
                        }

                        this.utcOffset(input, keepLocalTime);

                        return this;
                    } else {
                        return -this.utcOffset();
                    }
                }

                function setOffsetToUTC(keepLocalTime) {
                    return this.utcOffset(0, keepLocalTime);
                }

                function setOffsetToLocal(keepLocalTime) {
                    if (this._isUTC) {
                        this.utcOffset(0, keepLocalTime);
                        this._isUTC = false;

                        if (keepLocalTime) {
                            this.subtract(getDateOffset(this), "m");
                        }
                    }
                    return this;
                }

                function setOffsetToParsedOffset() {
                    if (this._tzm != null) {
                        this.utcOffset(this._tzm, false, true);
                    } else if (typeof this._i === "string") {
                        var tZone = offsetFromString(matchOffset, this._i);
                        if (tZone != null) {
                            this.utcOffset(tZone);
                        } else {
                            this.utcOffset(0, true);
                        }
                    }
                    return this;
                }

                function hasAlignedHourOffset(input) {
                    if (!this.isValid()) {
                        return false;
                    }
                    input = input ? createLocal(input).utcOffset() : 0;

                    return (this.utcOffset() - input) % 60 === 0;
                }

                function isDaylightSavingTime() {
                    return (
                        this.utcOffset() > this.clone().month(0).utcOffset() ||
                        this.utcOffset() > this.clone().month(5).utcOffset()
                    );
                }

                function isDaylightSavingTimeShifted() {
                    if (!isUndefined(this._isDSTShifted)) {
                        return this._isDSTShifted;
                    }

                    var c = {},
                        other;

                    copyConfig(c, this);
                    c = prepareConfig(c);

                    if (c._a) {
                        other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
                        this._isDSTShifted =
                            this.isValid() &&
                            compareArrays(c._a, other.toArray()) > 0;
                    } else {
                        this._isDSTShifted = false;
                    }

                    return this._isDSTShifted;
                }

                function isLocal() {
                    return this.isValid() ? !this._isUTC : false;
                }

                function isUtcOffset() {
                    return this.isValid() ? this._isUTC : false;
                }

                function isUtc() {
                    return this.isValid()
                        ? this._isUTC && this._offset === 0
                        : false;
                }

                // ASP.NET json date format regex
                var aspNetRegex =
                        /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
                    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
                    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
                    // and further modified to allow for strings containing both week and day
                    isoRegex =
                        /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

                function createDuration(input, key) {
                    var duration = input,
                        // matching against regexp is expensive, do it on demand
                        match = null,
                        sign,
                        ret,
                        diffRes;

                    if (isDuration(input)) {
                        duration = {
                            ms: input._milliseconds,
                            d: input._days,
                            M: input._months,
                        };
                    } else if (isNumber(input) || !isNaN(+input)) {
                        duration = {};
                        if (key) {
                            duration[key] = +input;
                        } else {
                            duration.milliseconds = +input;
                        }
                    } else if ((match = aspNetRegex.exec(input))) {
                        sign = match[1] === "-" ? -1 : 1;
                        duration = {
                            y: 0,
                            d: toInt(match[DATE]) * sign,
                            h: toInt(match[HOUR]) * sign,
                            m: toInt(match[MINUTE]) * sign,
                            s: toInt(match[SECOND]) * sign,
                            ms:
                                toInt(absRound(match[MILLISECOND] * 1000)) *
                                sign, // the millisecond decimal point is included in the match
                        };
                    } else if ((match = isoRegex.exec(input))) {
                        sign = match[1] === "-" ? -1 : 1;
                        duration = {
                            y: parseIso(match[2], sign),
                            M: parseIso(match[3], sign),
                            w: parseIso(match[4], sign),
                            d: parseIso(match[5], sign),
                            h: parseIso(match[6], sign),
                            m: parseIso(match[7], sign),
                            s: parseIso(match[8], sign),
                        };
                    } else if (duration == null) {
                        // checks for null or undefined
                        duration = {};
                    } else if (
                        typeof duration === "object" &&
                        ("from" in duration || "to" in duration)
                    ) {
                        diffRes = momentsDifference(
                            createLocal(duration.from),
                            createLocal(duration.to)
                        );

                        duration = {};
                        duration.ms = diffRes.milliseconds;
                        duration.M = diffRes.months;
                    }

                    ret = new Duration(duration);

                    if (isDuration(input) && hasOwnProp(input, "_locale")) {
                        ret._locale = input._locale;
                    }

                    if (isDuration(input) && hasOwnProp(input, "_isValid")) {
                        ret._isValid = input._isValid;
                    }

                    return ret;
                }

                createDuration.fn = Duration.prototype;
                createDuration.invalid = createInvalid$1;

                function parseIso(inp, sign) {
                    // We'd normally use ~~inp for this, but unfortunately it also
                    // converts floats to ints.
                    // inp may be undefined, so careful calling replace on it.
                    var res = inp && parseFloat(inp.replace(",", "."));
                    // apply sign while we're at it
                    return (isNaN(res) ? 0 : res) * sign;
                }

                function positiveMomentsDifference(base, other) {
                    var res = {};

                    res.months =
                        other.month() -
                        base.month() +
                        (other.year() - base.year()) * 12;
                    if (base.clone().add(res.months, "M").isAfter(other)) {
                        --res.months;
                    }

                    res.milliseconds =
                        +other - +base.clone().add(res.months, "M");

                    return res;
                }

                function momentsDifference(base, other) {
                    var res;
                    if (!(base.isValid() && other.isValid())) {
                        return { milliseconds: 0, months: 0 };
                    }

                    other = cloneWithOffset(other, base);
                    if (base.isBefore(other)) {
                        res = positiveMomentsDifference(base, other);
                    } else {
                        res = positiveMomentsDifference(other, base);
                        res.milliseconds = -res.milliseconds;
                        res.months = -res.months;
                    }

                    return res;
                }

                // TODO: remove 'name' arg after deprecation is removed
                function createAdder(direction, name) {
                    return function (val, period) {
                        var dur, tmp;
                        //invert the arguments, but complain about it
                        if (period !== null && !isNaN(+period)) {
                            deprecateSimple(
                                name,
                                "moment()." +
                                    name +
                                    "(period, number) is deprecated. Please use moment()." +
                                    name +
                                    "(number, period). " +
                                    "See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
                            );
                            tmp = val;
                            val = period;
                            period = tmp;
                        }

                        dur = createDuration(val, period);
                        addSubtract(this, dur, direction);
                        return this;
                    };
                }

                function addSubtract(mom, duration, isAdding, updateOffset) {
                    var milliseconds = duration._milliseconds,
                        days = absRound(duration._days),
                        months = absRound(duration._months);

                    if (!mom.isValid()) {
                        // No op
                        return;
                    }

                    updateOffset = updateOffset == null ? true : updateOffset;

                    if (months) {
                        setMonth(mom, get(mom, "Month") + months * isAdding);
                    }
                    if (days) {
                        set$1(mom, "Date", get(mom, "Date") + days * isAdding);
                    }
                    if (milliseconds) {
                        mom._d.setTime(
                            mom._d.valueOf() + milliseconds * isAdding
                        );
                    }
                    if (updateOffset) {
                        hooks.updateOffset(mom, days || months);
                    }
                }

                var add = createAdder(1, "add"),
                    subtract = createAdder(-1, "subtract");

                function isString(input) {
                    return typeof input === "string" || input instanceof String;
                }

                // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
                function isMomentInput(input) {
                    return (
                        isMoment(input) ||
                        isDate(input) ||
                        isString(input) ||
                        isNumber(input) ||
                        isNumberOrStringArray(input) ||
                        isMomentInputObject(input) ||
                        input === null ||
                        input === undefined
                    );
                }

                function isMomentInputObject(input) {
                    var objectTest = isObject(input) && !isObjectEmpty(input),
                        propertyTest = false,
                        properties = [
                            "years",
                            "year",
                            "y",
                            "months",
                            "month",
                            "M",
                            "days",
                            "day",
                            "d",
                            "dates",
                            "date",
                            "D",
                            "hours",
                            "hour",
                            "h",
                            "minutes",
                            "minute",
                            "m",
                            "seconds",
                            "second",
                            "s",
                            "milliseconds",
                            "millisecond",
                            "ms",
                        ],
                        i,
                        property;

                    for (i = 0; i < properties.length; i += 1) {
                        property = properties[i];
                        propertyTest =
                            propertyTest || hasOwnProp(input, property);
                    }

                    return objectTest && propertyTest;
                }

                function isNumberOrStringArray(input) {
                    var arrayTest = isArray(input),
                        dataTypeTest = false;
                    if (arrayTest) {
                        dataTypeTest =
                            input.filter(function (item) {
                                return !isNumber(item) && isString(input);
                            }).length === 0;
                    }
                    return arrayTest && dataTypeTest;
                }

                function isCalendarSpec(input) {
                    var objectTest = isObject(input) && !isObjectEmpty(input),
                        propertyTest = false,
                        properties = [
                            "sameDay",
                            "nextDay",
                            "lastDay",
                            "nextWeek",
                            "lastWeek",
                            "sameElse",
                        ],
                        i,
                        property;

                    for (i = 0; i < properties.length; i += 1) {
                        property = properties[i];
                        propertyTest =
                            propertyTest || hasOwnProp(input, property);
                    }

                    return objectTest && propertyTest;
                }

                function getCalendarFormat(myMoment, now) {
                    var diff = myMoment.diff(now, "days", true);
                    return diff < -6
                        ? "sameElse"
                        : diff < -1
                        ? "lastWeek"
                        : diff < 0
                        ? "lastDay"
                        : diff < 1
                        ? "sameDay"
                        : diff < 2
                        ? "nextDay"
                        : diff < 7
                        ? "nextWeek"
                        : "sameElse";
                }

                function calendar$1(time, formats) {
                    // Support for single parameter, formats only overload to the calendar function
                    if (arguments.length === 1) {
                        if (!arguments[0]) {
                            time = undefined;
                            formats = undefined;
                        } else if (isMomentInput(arguments[0])) {
                            time = arguments[0];
                            formats = undefined;
                        } else if (isCalendarSpec(arguments[0])) {
                            formats = arguments[0];
                            time = undefined;
                        }
                    }
                    // We want to compare the start of today, vs this.
                    // Getting start-of-today depends on whether we're local/utc/offset or not.
                    var now = time || createLocal(),
                        sod = cloneWithOffset(now, this).startOf("day"),
                        format = hooks.calendarFormat(this, sod) || "sameElse",
                        output =
                            formats &&
                            (isFunction(formats[format])
                                ? formats[format].call(this, now)
                                : formats[format]);

                    return this.format(
                        output ||
                            this.localeData().calendar(
                                format,
                                this,
                                createLocal(now)
                            )
                    );
                }

                function clone() {
                    return new Moment(this);
                }

                function isAfter(input, units) {
                    var localInput = isMoment(input)
                        ? input
                        : createLocal(input);
                    if (!(this.isValid() && localInput.isValid())) {
                        return false;
                    }
                    units = normalizeUnits(units) || "millisecond";
                    if (units === "millisecond") {
                        return this.valueOf() > localInput.valueOf();
                    } else {
                        return (
                            localInput.valueOf() <
                            this.clone().startOf(units).valueOf()
                        );
                    }
                }

                function isBefore(input, units) {
                    var localInput = isMoment(input)
                        ? input
                        : createLocal(input);
                    if (!(this.isValid() && localInput.isValid())) {
                        return false;
                    }
                    units = normalizeUnits(units) || "millisecond";
                    if (units === "millisecond") {
                        return this.valueOf() < localInput.valueOf();
                    } else {
                        return (
                            this.clone().endOf(units).valueOf() <
                            localInput.valueOf()
                        );
                    }
                }

                function isBetween(from, to, units, inclusivity) {
                    var localFrom = isMoment(from) ? from : createLocal(from),
                        localTo = isMoment(to) ? to : createLocal(to);
                    if (
                        !(
                            this.isValid() &&
                            localFrom.isValid() &&
                            localTo.isValid()
                        )
                    ) {
                        return false;
                    }
                    inclusivity = inclusivity || "()";
                    return (
                        (inclusivity[0] === "("
                            ? this.isAfter(localFrom, units)
                            : !this.isBefore(localFrom, units)) &&
                        (inclusivity[1] === ")"
                            ? this.isBefore(localTo, units)
                            : !this.isAfter(localTo, units))
                    );
                }

                function isSame(input, units) {
                    var localInput = isMoment(input)
                            ? input
                            : createLocal(input),
                        inputMs;
                    if (!(this.isValid() && localInput.isValid())) {
                        return false;
                    }
                    units = normalizeUnits(units) || "millisecond";
                    if (units === "millisecond") {
                        return this.valueOf() === localInput.valueOf();
                    } else {
                        inputMs = localInput.valueOf();
                        return (
                            this.clone().startOf(units).valueOf() <= inputMs &&
                            inputMs <= this.clone().endOf(units).valueOf()
                        );
                    }
                }

                function isSameOrAfter(input, units) {
                    return (
                        this.isSame(input, units) || this.isAfter(input, units)
                    );
                }

                function isSameOrBefore(input, units) {
                    return (
                        this.isSame(input, units) || this.isBefore(input, units)
                    );
                }

                function diff(input, units, asFloat) {
                    var that, zoneDelta, output;

                    if (!this.isValid()) {
                        return NaN;
                    }

                    that = cloneWithOffset(input, this);

                    if (!that.isValid()) {
                        return NaN;
                    }

                    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

                    units = normalizeUnits(units);

                    switch (units) {
                        case "year":
                            output = monthDiff(this, that) / 12;
                            break;
                        case "month":
                            output = monthDiff(this, that);
                            break;
                        case "quarter":
                            output = monthDiff(this, that) / 3;
                            break;
                        case "second":
                            output = (this - that) / 1e3;
                            break; // 1000
                        case "minute":
                            output = (this - that) / 6e4;
                            break; // 1000 * 60
                        case "hour":
                            output = (this - that) / 36e5;
                            break; // 1000 * 60 * 60
                        case "day":
                            output = (this - that - zoneDelta) / 864e5;
                            break; // 1000 * 60 * 60 * 24, negate dst
                        case "week":
                            output = (this - that - zoneDelta) / 6048e5;
                            break; // 1000 * 60 * 60 * 24 * 7, negate dst
                        default:
                            output = this - that;
                    }

                    return asFloat ? output : absFloor(output);
                }

                function monthDiff(a, b) {
                    if (a.date() < b.date()) {
                        // end-of-month calculations work correct when the start month has more
                        // days than the end month.
                        return -monthDiff(b, a);
                    }
                    // difference in months
                    var wholeMonthDiff =
                            (b.year() - a.year()) * 12 +
                            (b.month() - a.month()),
                        // b is in (anchor - 1 month, anchor + 1 month)
                        anchor = a.clone().add(wholeMonthDiff, "months"),
                        anchor2,
                        adjust;

                    if (b - anchor < 0) {
                        anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
                        // linear across the month
                        adjust = (b - anchor) / (anchor - anchor2);
                    } else {
                        anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
                        // linear across the month
                        adjust = (b - anchor) / (anchor2 - anchor);
                    }

                    //check for negative zero, return zero if negative zero
                    return -(wholeMonthDiff + adjust) || 0;
                }

                hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
                hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";

                function toString() {
                    return this.clone()
                        .locale("en")
                        .format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
                }

                function toISOString(keepOffset) {
                    if (!this.isValid()) {
                        return null;
                    }
                    var utc = keepOffset !== true,
                        m = utc ? this.clone().utc() : this;
                    if (m.year() < 0 || m.year() > 9999) {
                        return formatMoment(
                            m,
                            utc
                                ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]"
                                : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
                        );
                    }
                    if (isFunction(Date.prototype.toISOString)) {
                        // native implementation is ~50x faster, use it when we can
                        if (utc) {
                            return this.toDate().toISOString();
                        } else {
                            return new Date(
                                this.valueOf() + this.utcOffset() * 60 * 1000
                            )
                                .toISOString()
                                .replace("Z", formatMoment(m, "Z"));
                        }
                    }
                    return formatMoment(
                        m,
                        utc
                            ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]"
                            : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
                    );
                }

                /**
                 * Return a human readable representation of a moment that can
                 * also be evaluated to get a new moment which is the same
                 *
                 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
                 */
                function inspect() {
                    if (!this.isValid()) {
                        return "moment.invalid(/* " + this._i + " */)";
                    }
                    var func = "moment",
                        zone = "",
                        prefix,
                        year,
                        datetime,
                        suffix;
                    if (!this.isLocal()) {
                        func =
                            this.utcOffset() === 0
                                ? "moment.utc"
                                : "moment.parseZone";
                        zone = "Z";
                    }
                    prefix = "[" + func + '("]';
                    year =
                        0 <= this.year() && this.year() <= 9999
                            ? "YYYY"
                            : "YYYYYY";
                    datetime = "-MM-DD[T]HH:mm:ss.SSS";
                    suffix = zone + '[")]';

                    return this.format(prefix + year + datetime + suffix);
                }

                function format(inputString) {
                    if (!inputString) {
                        inputString = this.isUtc()
                            ? hooks.defaultFormatUtc
                            : hooks.defaultFormat;
                    }
                    var output = formatMoment(this, inputString);
                    return this.localeData().postformat(output);
                }

                function from(time, withoutSuffix) {
                    if (
                        this.isValid() &&
                        ((isMoment(time) && time.isValid()) ||
                            createLocal(time).isValid())
                    ) {
                        return createDuration({ to: this, from: time })
                            .locale(this.locale())
                            .humanize(!withoutSuffix);
                    } else {
                        return this.localeData().invalidDate();
                    }
                }

                function fromNow(withoutSuffix) {
                    return this.from(createLocal(), withoutSuffix);
                }

                function to(time, withoutSuffix) {
                    if (
                        this.isValid() &&
                        ((isMoment(time) && time.isValid()) ||
                            createLocal(time).isValid())
                    ) {
                        return createDuration({ from: this, to: time })
                            .locale(this.locale())
                            .humanize(!withoutSuffix);
                    } else {
                        return this.localeData().invalidDate();
                    }
                }

                function toNow(withoutSuffix) {
                    return this.to(createLocal(), withoutSuffix);
                }

                // If passed a locale key, it will set the locale for this
                // instance.  Otherwise, it will return the locale configuration
                // variables for this instance.
                function locale(key) {
                    var newLocaleData;

                    if (key === undefined) {
                        return this._locale._abbr;
                    } else {
                        newLocaleData = getLocale(key);
                        if (newLocaleData != null) {
                            this._locale = newLocaleData;
                        }
                        return this;
                    }
                }

                var lang = deprecate(
                    "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
                    function (key) {
                        if (key === undefined) {
                            return this.localeData();
                        } else {
                            return this.locale(key);
                        }
                    }
                );

                function localeData() {
                    return this._locale;
                }

                var MS_PER_SECOND = 1000,
                    MS_PER_MINUTE = 60 * MS_PER_SECOND,
                    MS_PER_HOUR = 60 * MS_PER_MINUTE,
                    MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

                // actual modulo - handles negative numbers (for dates before 1970):
                function mod$1(dividend, divisor) {
                    return ((dividend % divisor) + divisor) % divisor;
                }

                function localStartOfDate(y, m, d) {
                    // the date constructor remaps years 0-99 to 1900-1999
                    if (y < 100 && y >= 0) {
                        // preserve leap years using a full 400 year cycle, then reset
                        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
                    } else {
                        return new Date(y, m, d).valueOf();
                    }
                }

                function utcStartOfDate(y, m, d) {
                    // Date.UTC remaps years 0-99 to 1900-1999
                    if (y < 100 && y >= 0) {
                        // preserve leap years using a full 400 year cycle, then reset
                        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
                    } else {
                        return Date.UTC(y, m, d);
                    }
                }

                function startOf(units) {
                    var time, startOfDate;
                    units = normalizeUnits(units);
                    if (
                        units === undefined ||
                        units === "millisecond" ||
                        !this.isValid()
                    ) {
                        return this;
                    }

                    startOfDate = this._isUTC
                        ? utcStartOfDate
                        : localStartOfDate;

                    switch (units) {
                        case "year":
                            time = startOfDate(this.year(), 0, 1);
                            break;
                        case "quarter":
                            time = startOfDate(
                                this.year(),
                                this.month() - (this.month() % 3),
                                1
                            );
                            break;
                        case "month":
                            time = startOfDate(this.year(), this.month(), 1);
                            break;
                        case "week":
                            time = startOfDate(
                                this.year(),
                                this.month(),
                                this.date() - this.weekday()
                            );
                            break;
                        case "isoWeek":
                            time = startOfDate(
                                this.year(),
                                this.month(),
                                this.date() - (this.isoWeekday() - 1)
                            );
                            break;
                        case "day":
                        case "date":
                            time = startOfDate(
                                this.year(),
                                this.month(),
                                this.date()
                            );
                            break;
                        case "hour":
                            time = this._d.valueOf();
                            time -= mod$1(
                                time +
                                    (this._isUTC
                                        ? 0
                                        : this.utcOffset() * MS_PER_MINUTE),
                                MS_PER_HOUR
                            );
                            break;
                        case "minute":
                            time = this._d.valueOf();
                            time -= mod$1(time, MS_PER_MINUTE);
                            break;
                        case "second":
                            time = this._d.valueOf();
                            time -= mod$1(time, MS_PER_SECOND);
                            break;
                    }

                    this._d.setTime(time);
                    hooks.updateOffset(this, true);
                    return this;
                }

                function endOf(units) {
                    var time, startOfDate;
                    units = normalizeUnits(units);
                    if (
                        units === undefined ||
                        units === "millisecond" ||
                        !this.isValid()
                    ) {
                        return this;
                    }

                    startOfDate = this._isUTC
                        ? utcStartOfDate
                        : localStartOfDate;

                    switch (units) {
                        case "year":
                            time = startOfDate(this.year() + 1, 0, 1) - 1;
                            break;
                        case "quarter":
                            time =
                                startOfDate(
                                    this.year(),
                                    this.month() - (this.month() % 3) + 3,
                                    1
                                ) - 1;
                            break;
                        case "month":
                            time =
                                startOfDate(this.year(), this.month() + 1, 1) -
                                1;
                            break;
                        case "week":
                            time =
                                startOfDate(
                                    this.year(),
                                    this.month(),
                                    this.date() - this.weekday() + 7
                                ) - 1;
                            break;
                        case "isoWeek":
                            time =
                                startOfDate(
                                    this.year(),
                                    this.month(),
                                    this.date() - (this.isoWeekday() - 1) + 7
                                ) - 1;
                            break;
                        case "day":
                        case "date":
                            time =
                                startOfDate(
                                    this.year(),
                                    this.month(),
                                    this.date() + 1
                                ) - 1;
                            break;
                        case "hour":
                            time = this._d.valueOf();
                            time +=
                                MS_PER_HOUR -
                                mod$1(
                                    time +
                                        (this._isUTC
                                            ? 0
                                            : this.utcOffset() * MS_PER_MINUTE),
                                    MS_PER_HOUR
                                ) -
                                1;
                            break;
                        case "minute":
                            time = this._d.valueOf();
                            time +=
                                MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                            break;
                        case "second":
                            time = this._d.valueOf();
                            time +=
                                MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                            break;
                    }

                    this._d.setTime(time);
                    hooks.updateOffset(this, true);
                    return this;
                }

                function valueOf() {
                    return this._d.valueOf() - (this._offset || 0) * 60000;
                }

                function unix() {
                    return Math.floor(this.valueOf() / 1000);
                }

                function toDate() {
                    return new Date(this.valueOf());
                }

                function toArray() {
                    var m = this;
                    return [
                        m.year(),
                        m.month(),
                        m.date(),
                        m.hour(),
                        m.minute(),
                        m.second(),
                        m.millisecond(),
                    ];
                }

                function toObject() {
                    var m = this;
                    return {
                        years: m.year(),
                        months: m.month(),
                        date: m.date(),
                        hours: m.hours(),
                        minutes: m.minutes(),
                        seconds: m.seconds(),
                        milliseconds: m.milliseconds(),
                    };
                }

                function toJSON() {
                    // new Date(NaN).toJSON() === null
                    return this.isValid() ? this.toISOString() : null;
                }

                function isValid$2() {
                    return isValid(this);
                }

                function parsingFlags() {
                    return extend({}, getParsingFlags(this));
                }

                function invalidAt() {
                    return getParsingFlags(this).overflow;
                }

                function creationData() {
                    return {
                        input: this._i,
                        format: this._f,
                        locale: this._locale,
                        isUTC: this._isUTC,
                        strict: this._strict,
                    };
                }

                addFormatToken("N", 0, 0, "eraAbbr");
                addFormatToken("NN", 0, 0, "eraAbbr");
                addFormatToken("NNN", 0, 0, "eraAbbr");
                addFormatToken("NNNN", 0, 0, "eraName");
                addFormatToken("NNNNN", 0, 0, "eraNarrow");

                addFormatToken("y", ["y", 1], "yo", "eraYear");
                addFormatToken("y", ["yy", 2], 0, "eraYear");
                addFormatToken("y", ["yyy", 3], 0, "eraYear");
                addFormatToken("y", ["yyyy", 4], 0, "eraYear");

                addRegexToken("N", matchEraAbbr);
                addRegexToken("NN", matchEraAbbr);
                addRegexToken("NNN", matchEraAbbr);
                addRegexToken("NNNN", matchEraName);
                addRegexToken("NNNNN", matchEraNarrow);

                addParseToken(
                    ["N", "NN", "NNN", "NNNN", "NNNNN"],
                    function (input, array, config, token) {
                        var era = config._locale.erasParse(
                            input,
                            token,
                            config._strict
                        );
                        if (era) {
                            getParsingFlags(config).era = era;
                        } else {
                            getParsingFlags(config).invalidEra = input;
                        }
                    }
                );

                addRegexToken("y", matchUnsigned);
                addRegexToken("yy", matchUnsigned);
                addRegexToken("yyy", matchUnsigned);
                addRegexToken("yyyy", matchUnsigned);
                addRegexToken("yo", matchEraYearOrdinal);

                addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
                addParseToken(["yo"], function (input, array, config, token) {
                    var match;
                    if (config._locale._eraYearOrdinalRegex) {
                        match = input.match(
                            config._locale._eraYearOrdinalRegex
                        );
                    }

                    if (config._locale.eraYearOrdinalParse) {
                        array[YEAR] = config._locale.eraYearOrdinalParse(
                            input,
                            match
                        );
                    } else {
                        array[YEAR] = parseInt(input, 10);
                    }
                });

                function localeEras(m, format) {
                    var i,
                        l,
                        date,
                        eras = this._eras || getLocale("en")._eras;
                    for (i = 0, l = eras.length; i < l; ++i) {
                        switch (typeof eras[i].since) {
                            case "string":
                                // truncate time
                                date = hooks(eras[i].since).startOf("day");
                                eras[i].since = date.valueOf();
                                break;
                        }

                        switch (typeof eras[i].until) {
                            case "undefined":
                                eras[i].until = +Infinity;
                                break;
                            case "string":
                                // truncate time
                                date = hooks(eras[i].until)
                                    .startOf("day")
                                    .valueOf();
                                eras[i].until = date.valueOf();
                                break;
                        }
                    }
                    return eras;
                }

                function localeErasParse(eraName, format, strict) {
                    var i,
                        l,
                        eras = this.eras(),
                        name,
                        abbr,
                        narrow;
                    eraName = eraName.toUpperCase();

                    for (i = 0, l = eras.length; i < l; ++i) {
                        name = eras[i].name.toUpperCase();
                        abbr = eras[i].abbr.toUpperCase();
                        narrow = eras[i].narrow.toUpperCase();

                        if (strict) {
                            switch (format) {
                                case "N":
                                case "NN":
                                case "NNN":
                                    if (abbr === eraName) {
                                        return eras[i];
                                    }
                                    break;

                                case "NNNN":
                                    if (name === eraName) {
                                        return eras[i];
                                    }
                                    break;

                                case "NNNNN":
                                    if (narrow === eraName) {
                                        return eras[i];
                                    }
                                    break;
                            }
                        } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                            return eras[i];
                        }
                    }
                }

                function localeErasConvertYear(era, year) {
                    var dir = era.since <= era.until ? +1 : -1;
                    if (year === undefined) {
                        return hooks(era.since).year();
                    } else {
                        return (
                            hooks(era.since).year() + (year - era.offset) * dir
                        );
                    }
                }

                function getEraName() {
                    var i,
                        l,
                        val,
                        eras = this.localeData().eras();
                    for (i = 0, l = eras.length; i < l; ++i) {
                        // truncate time
                        val = this.clone().startOf("day").valueOf();

                        if (eras[i].since <= val && val <= eras[i].until) {
                            return eras[i].name;
                        }
                        if (eras[i].until <= val && val <= eras[i].since) {
                            return eras[i].name;
                        }
                    }

                    return "";
                }

                function getEraNarrow() {
                    var i,
                        l,
                        val,
                        eras = this.localeData().eras();
                    for (i = 0, l = eras.length; i < l; ++i) {
                        // truncate time
                        val = this.clone().startOf("day").valueOf();

                        if (eras[i].since <= val && val <= eras[i].until) {
                            return eras[i].narrow;
                        }
                        if (eras[i].until <= val && val <= eras[i].since) {
                            return eras[i].narrow;
                        }
                    }

                    return "";
                }

                function getEraAbbr() {
                    var i,
                        l,
                        val,
                        eras = this.localeData().eras();
                    for (i = 0, l = eras.length; i < l; ++i) {
                        // truncate time
                        val = this.clone().startOf("day").valueOf();

                        if (eras[i].since <= val && val <= eras[i].until) {
                            return eras[i].abbr;
                        }
                        if (eras[i].until <= val && val <= eras[i].since) {
                            return eras[i].abbr;
                        }
                    }

                    return "";
                }

                function getEraYear() {
                    var i,
                        l,
                        dir,
                        val,
                        eras = this.localeData().eras();
                    for (i = 0, l = eras.length; i < l; ++i) {
                        dir = eras[i].since <= eras[i].until ? +1 : -1;

                        // truncate time
                        val = this.clone().startOf("day").valueOf();

                        if (
                            (eras[i].since <= val && val <= eras[i].until) ||
                            (eras[i].until <= val && val <= eras[i].since)
                        ) {
                            return (
                                (this.year() - hooks(eras[i].since).year()) *
                                    dir +
                                eras[i].offset
                            );
                        }
                    }

                    return this.year();
                }

                function erasNameRegex(isStrict) {
                    if (!hasOwnProp(this, "_erasNameRegex")) {
                        computeErasParse.call(this);
                    }
                    return isStrict ? this._erasNameRegex : this._erasRegex;
                }

                function erasAbbrRegex(isStrict) {
                    if (!hasOwnProp(this, "_erasAbbrRegex")) {
                        computeErasParse.call(this);
                    }
                    return isStrict ? this._erasAbbrRegex : this._erasRegex;
                }

                function erasNarrowRegex(isStrict) {
                    if (!hasOwnProp(this, "_erasNarrowRegex")) {
                        computeErasParse.call(this);
                    }
                    return isStrict ? this._erasNarrowRegex : this._erasRegex;
                }

                function matchEraAbbr(isStrict, locale) {
                    return locale.erasAbbrRegex(isStrict);
                }

                function matchEraName(isStrict, locale) {
                    return locale.erasNameRegex(isStrict);
                }

                function matchEraNarrow(isStrict, locale) {
                    return locale.erasNarrowRegex(isStrict);
                }

                function matchEraYearOrdinal(isStrict, locale) {
                    return locale._eraYearOrdinalRegex || matchUnsigned;
                }

                function computeErasParse() {
                    var abbrPieces = [],
                        namePieces = [],
                        narrowPieces = [],
                        mixedPieces = [],
                        i,
                        l,
                        eras = this.eras();

                    for (i = 0, l = eras.length; i < l; ++i) {
                        namePieces.push(regexEscape(eras[i].name));
                        abbrPieces.push(regexEscape(eras[i].abbr));
                        narrowPieces.push(regexEscape(eras[i].narrow));

                        mixedPieces.push(regexEscape(eras[i].name));
                        mixedPieces.push(regexEscape(eras[i].abbr));
                        mixedPieces.push(regexEscape(eras[i].narrow));
                    }

                    this._erasRegex = new RegExp(
                        "^(" + mixedPieces.join("|") + ")",
                        "i"
                    );
                    this._erasNameRegex = new RegExp(
                        "^(" + namePieces.join("|") + ")",
                        "i"
                    );
                    this._erasAbbrRegex = new RegExp(
                        "^(" + abbrPieces.join("|") + ")",
                        "i"
                    );
                    this._erasNarrowRegex = new RegExp(
                        "^(" + narrowPieces.join("|") + ")",
                        "i"
                    );
                }

                // FORMATTING

                addFormatToken(0, ["gg", 2], 0, function () {
                    return this.weekYear() % 100;
                });

                addFormatToken(0, ["GG", 2], 0, function () {
                    return this.isoWeekYear() % 100;
                });

                function addWeekYearFormatToken(token, getter) {
                    addFormatToken(0, [token, token.length], 0, getter);
                }

                addWeekYearFormatToken("gggg", "weekYear");
                addWeekYearFormatToken("ggggg", "weekYear");
                addWeekYearFormatToken("GGGG", "isoWeekYear");
                addWeekYearFormatToken("GGGGG", "isoWeekYear");

                // ALIASES

                addUnitAlias("weekYear", "gg");
                addUnitAlias("isoWeekYear", "GG");

                // PRIORITY

                addUnitPriority("weekYear", 1);
                addUnitPriority("isoWeekYear", 1);

                // PARSING

                addRegexToken("G", matchSigned);
                addRegexToken("g", matchSigned);
                addRegexToken("GG", match1to2, match2);
                addRegexToken("gg", match1to2, match2);
                addRegexToken("GGGG", match1to4, match4);
                addRegexToken("gggg", match1to4, match4);
                addRegexToken("GGGGG", match1to6, match6);
                addRegexToken("ggggg", match1to6, match6);

                addWeekParseToken(
                    ["gggg", "ggggg", "GGGG", "GGGGG"],
                    function (input, week, config, token) {
                        week[token.substr(0, 2)] = toInt(input);
                    }
                );

                addWeekParseToken(
                    ["gg", "GG"],
                    function (input, week, config, token) {
                        week[token] = hooks.parseTwoDigitYear(input);
                    }
                );

                // MOMENTS

                function getSetWeekYear(input) {
                    return getSetWeekYearHelper.call(
                        this,
                        input,
                        this.week(),
                        this.weekday(),
                        this.localeData()._week.dow,
                        this.localeData()._week.doy
                    );
                }

                function getSetISOWeekYear(input) {
                    return getSetWeekYearHelper.call(
                        this,
                        input,
                        this.isoWeek(),
                        this.isoWeekday(),
                        1,
                        4
                    );
                }

                function getISOWeeksInYear() {
                    return weeksInYear(this.year(), 1, 4);
                }

                function getISOWeeksInISOWeekYear() {
                    return weeksInYear(this.isoWeekYear(), 1, 4);
                }

                function getWeeksInYear() {
                    var weekInfo = this.localeData()._week;
                    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
                }

                function getWeeksInWeekYear() {
                    var weekInfo = this.localeData()._week;
                    return weeksInYear(
                        this.weekYear(),
                        weekInfo.dow,
                        weekInfo.doy
                    );
                }

                function getSetWeekYearHelper(input, week, weekday, dow, doy) {
                    var weeksTarget;
                    if (input == null) {
                        return weekOfYear(this, dow, doy).year;
                    } else {
                        weeksTarget = weeksInYear(input, dow, doy);
                        if (week > weeksTarget) {
                            week = weeksTarget;
                        }
                        return setWeekAll.call(
                            this,
                            input,
                            week,
                            weekday,
                            dow,
                            doy
                        );
                    }
                }

                function setWeekAll(weekYear, week, weekday, dow, doy) {
                    var dayOfYearData = dayOfYearFromWeeks(
                            weekYear,
                            week,
                            weekday,
                            dow,
                            doy
                        ),
                        date = createUTCDate(
                            dayOfYearData.year,
                            0,
                            dayOfYearData.dayOfYear
                        );

                    this.year(date.getUTCFullYear());
                    this.month(date.getUTCMonth());
                    this.date(date.getUTCDate());
                    return this;
                }

                // FORMATTING

                addFormatToken("Q", 0, "Qo", "quarter");

                // ALIASES

                addUnitAlias("quarter", "Q");

                // PRIORITY

                addUnitPriority("quarter", 7);

                // PARSING

                addRegexToken("Q", match1);
                addParseToken("Q", function (input, array) {
                    array[MONTH] = (toInt(input) - 1) * 3;
                });

                // MOMENTS

                function getSetQuarter(input) {
                    return input == null
                        ? Math.ceil((this.month() + 1) / 3)
                        : this.month((input - 1) * 3 + (this.month() % 3));
                }

                // FORMATTING

                addFormatToken("D", ["DD", 2], "Do", "date");

                // ALIASES

                addUnitAlias("date", "D");

                // PRIORITY
                addUnitPriority("date", 9);

                // PARSING

                addRegexToken("D", match1to2);
                addRegexToken("DD", match1to2, match2);
                addRegexToken("Do", function (isStrict, locale) {
                    // TODO: Remove "ordinalParse" fallback in next major release.
                    return isStrict
                        ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
                        : locale._dayOfMonthOrdinalParseLenient;
                });

                addParseToken(["D", "DD"], DATE);
                addParseToken("Do", function (input, array) {
                    array[DATE] = toInt(input.match(match1to2)[0]);
                });

                // MOMENTS

                var getSetDayOfMonth = makeGetSet("Date", true);

                // FORMATTING

                addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");

                // ALIASES

                addUnitAlias("dayOfYear", "DDD");

                // PRIORITY
                addUnitPriority("dayOfYear", 4);

                // PARSING

                addRegexToken("DDD", match1to3);
                addRegexToken("DDDD", match3);
                addParseToken(["DDD", "DDDD"], function (input, array, config) {
                    config._dayOfYear = toInt(input);
                });

                // HELPERS

                // MOMENTS

                function getSetDayOfYear(input) {
                    var dayOfYear =
                        Math.round(
                            (this.clone().startOf("day") -
                                this.clone().startOf("year")) /
                                864e5
                        ) + 1;
                    return input == null
                        ? dayOfYear
                        : this.add(input - dayOfYear, "d");
                }

                // FORMATTING

                addFormatToken("m", ["mm", 2], 0, "minute");

                // ALIASES

                addUnitAlias("minute", "m");

                // PRIORITY

                addUnitPriority("minute", 14);

                // PARSING

                addRegexToken("m", match1to2);
                addRegexToken("mm", match1to2, match2);
                addParseToken(["m", "mm"], MINUTE);

                // MOMENTS

                var getSetMinute = makeGetSet("Minutes", false);

                // FORMATTING

                addFormatToken("s", ["ss", 2], 0, "second");

                // ALIASES

                addUnitAlias("second", "s");

                // PRIORITY

                addUnitPriority("second", 15);

                // PARSING

                addRegexToken("s", match1to2);
                addRegexToken("ss", match1to2, match2);
                addParseToken(["s", "ss"], SECOND);

                // MOMENTS

                var getSetSecond = makeGetSet("Seconds", false);

                // FORMATTING

                addFormatToken("S", 0, 0, function () {
                    return ~~(this.millisecond() / 100);
                });

                addFormatToken(0, ["SS", 2], 0, function () {
                    return ~~(this.millisecond() / 10);
                });

                addFormatToken(0, ["SSS", 3], 0, "millisecond");
                addFormatToken(0, ["SSSS", 4], 0, function () {
                    return this.millisecond() * 10;
                });
                addFormatToken(0, ["SSSSS", 5], 0, function () {
                    return this.millisecond() * 100;
                });
                addFormatToken(0, ["SSSSSS", 6], 0, function () {
                    return this.millisecond() * 1000;
                });
                addFormatToken(0, ["SSSSSSS", 7], 0, function () {
                    return this.millisecond() * 10000;
                });
                addFormatToken(0, ["SSSSSSSS", 8], 0, function () {
                    return this.millisecond() * 100000;
                });
                addFormatToken(0, ["SSSSSSSSS", 9], 0, function () {
                    return this.millisecond() * 1000000;
                });

                // ALIASES

                addUnitAlias("millisecond", "ms");

                // PRIORITY

                addUnitPriority("millisecond", 16);

                // PARSING

                addRegexToken("S", match1to3, match1);
                addRegexToken("SS", match1to3, match2);
                addRegexToken("SSS", match1to3, match3);

                var token, getSetMillisecond;
                for (token = "SSSS"; token.length <= 9; token += "S") {
                    addRegexToken(token, matchUnsigned);
                }

                function parseMs(input, array) {
                    array[MILLISECOND] = toInt(("0." + input) * 1000);
                }

                for (token = "S"; token.length <= 9; token += "S") {
                    addParseToken(token, parseMs);
                }

                getSetMillisecond = makeGetSet("Milliseconds", false);

                // FORMATTING

                addFormatToken("z", 0, 0, "zoneAbbr");
                addFormatToken("zz", 0, 0, "zoneName");

                // MOMENTS

                function getZoneAbbr() {
                    return this._isUTC ? "UTC" : "";
                }

                function getZoneName() {
                    return this._isUTC ? "Coordinated Universal Time" : "";
                }

                var proto = Moment.prototype;

                proto.add = add;
                proto.calendar = calendar$1;
                proto.clone = clone;
                proto.diff = diff;
                proto.endOf = endOf;
                proto.format = format;
                proto.from = from;
                proto.fromNow = fromNow;
                proto.to = to;
                proto.toNow = toNow;
                proto.get = stringGet;
                proto.invalidAt = invalidAt;
                proto.isAfter = isAfter;
                proto.isBefore = isBefore;
                proto.isBetween = isBetween;
                proto.isSame = isSame;
                proto.isSameOrAfter = isSameOrAfter;
                proto.isSameOrBefore = isSameOrBefore;
                proto.isValid = isValid$2;
                proto.lang = lang;
                proto.locale = locale;
                proto.localeData = localeData;
                proto.max = prototypeMax;
                proto.min = prototypeMin;
                proto.parsingFlags = parsingFlags;
                proto.set = stringSet;
                proto.startOf = startOf;
                proto.subtract = subtract;
                proto.toArray = toArray;
                proto.toObject = toObject;
                proto.toDate = toDate;
                proto.toISOString = toISOString;
                proto.inspect = inspect;
                if (typeof Symbol !== "undefined" && Symbol.for != null) {
                    proto[Symbol.for("nodejs.util.inspect.custom")] =
                        function () {
                            return "Moment<" + this.format() + ">";
                        };
                }
                proto.toJSON = toJSON;
                proto.toString = toString;
                proto.unix = unix;
                proto.valueOf = valueOf;
                proto.creationData = creationData;
                proto.eraName = getEraName;
                proto.eraNarrow = getEraNarrow;
                proto.eraAbbr = getEraAbbr;
                proto.eraYear = getEraYear;
                proto.year = getSetYear;
                proto.isLeapYear = getIsLeapYear;
                proto.weekYear = getSetWeekYear;
                proto.isoWeekYear = getSetISOWeekYear;
                proto.quarter = proto.quarters = getSetQuarter;
                proto.month = getSetMonth;
                proto.daysInMonth = getDaysInMonth;
                proto.week = proto.weeks = getSetWeek;
                proto.isoWeek = proto.isoWeeks = getSetISOWeek;
                proto.weeksInYear = getWeeksInYear;
                proto.weeksInWeekYear = getWeeksInWeekYear;
                proto.isoWeeksInYear = getISOWeeksInYear;
                proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
                proto.date = getSetDayOfMonth;
                proto.day = proto.days = getSetDayOfWeek;
                proto.weekday = getSetLocaleDayOfWeek;
                proto.isoWeekday = getSetISODayOfWeek;
                proto.dayOfYear = getSetDayOfYear;
                proto.hour = proto.hours = getSetHour;
                proto.minute = proto.minutes = getSetMinute;
                proto.second = proto.seconds = getSetSecond;
                proto.millisecond = proto.milliseconds = getSetMillisecond;
                proto.utcOffset = getSetOffset;
                proto.utc = setOffsetToUTC;
                proto.local = setOffsetToLocal;
                proto.parseZone = setOffsetToParsedOffset;
                proto.hasAlignedHourOffset = hasAlignedHourOffset;
                proto.isDST = isDaylightSavingTime;
                proto.isLocal = isLocal;
                proto.isUtcOffset = isUtcOffset;
                proto.isUtc = isUtc;
                proto.isUTC = isUtc;
                proto.zoneAbbr = getZoneAbbr;
                proto.zoneName = getZoneName;
                proto.dates = deprecate(
                    "dates accessor is deprecated. Use date instead.",
                    getSetDayOfMonth
                );
                proto.months = deprecate(
                    "months accessor is deprecated. Use month instead",
                    getSetMonth
                );
                proto.years = deprecate(
                    "years accessor is deprecated. Use year instead",
                    getSetYear
                );
                proto.zone = deprecate(
                    "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
                    getSetZone
                );
                proto.isDSTShifted = deprecate(
                    "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
                    isDaylightSavingTimeShifted
                );

                function createUnix(input) {
                    return createLocal(input * 1000);
                }

                function createInZone() {
                    return createLocal.apply(null, arguments).parseZone();
                }

                function preParsePostFormat(string) {
                    return string;
                }

                var proto$1 = Locale.prototype;

                proto$1.calendar = calendar;
                proto$1.longDateFormat = longDateFormat;
                proto$1.invalidDate = invalidDate;
                proto$1.ordinal = ordinal;
                proto$1.preparse = preParsePostFormat;
                proto$1.postformat = preParsePostFormat;
                proto$1.relativeTime = relativeTime;
                proto$1.pastFuture = pastFuture;
                proto$1.set = set;
                proto$1.eras = localeEras;
                proto$1.erasParse = localeErasParse;
                proto$1.erasConvertYear = localeErasConvertYear;
                proto$1.erasAbbrRegex = erasAbbrRegex;
                proto$1.erasNameRegex = erasNameRegex;
                proto$1.erasNarrowRegex = erasNarrowRegex;

                proto$1.months = localeMonths;
                proto$1.monthsShort = localeMonthsShort;
                proto$1.monthsParse = localeMonthsParse;
                proto$1.monthsRegex = monthsRegex;
                proto$1.monthsShortRegex = monthsShortRegex;
                proto$1.week = localeWeek;
                proto$1.firstDayOfYear = localeFirstDayOfYear;
                proto$1.firstDayOfWeek = localeFirstDayOfWeek;

                proto$1.weekdays = localeWeekdays;
                proto$1.weekdaysMin = localeWeekdaysMin;
                proto$1.weekdaysShort = localeWeekdaysShort;
                proto$1.weekdaysParse = localeWeekdaysParse;

                proto$1.weekdaysRegex = weekdaysRegex;
                proto$1.weekdaysShortRegex = weekdaysShortRegex;
                proto$1.weekdaysMinRegex = weekdaysMinRegex;

                proto$1.isPM = localeIsPM;
                proto$1.meridiem = localeMeridiem;

                function get$1(format, index, field, setter) {
                    var locale = getLocale(),
                        utc = createUTC().set(setter, index);
                    return locale[field](utc, format);
                }

                function listMonthsImpl(format, index, field) {
                    if (isNumber(format)) {
                        index = format;
                        format = undefined;
                    }

                    format = format || "";

                    if (index != null) {
                        return get$1(format, index, field, "month");
                    }

                    var i,
                        out = [];
                    for (i = 0; i < 12; i++) {
                        out[i] = get$1(format, i, field, "month");
                    }
                    return out;
                }

                // ()
                // (5)
                // (fmt, 5)
                // (fmt)
                // (true)
                // (true, 5)
                // (true, fmt, 5)
                // (true, fmt)
                function listWeekdaysImpl(localeSorted, format, index, field) {
                    if (typeof localeSorted === "boolean") {
                        if (isNumber(format)) {
                            index = format;
                            format = undefined;
                        }

                        format = format || "";
                    } else {
                        format = localeSorted;
                        index = format;
                        localeSorted = false;

                        if (isNumber(format)) {
                            index = format;
                            format = undefined;
                        }

                        format = format || "";
                    }

                    var locale = getLocale(),
                        shift = localeSorted ? locale._week.dow : 0,
                        i,
                        out = [];

                    if (index != null) {
                        return get$1(format, (index + shift) % 7, field, "day");
                    }

                    for (i = 0; i < 7; i++) {
                        out[i] = get$1(format, (i + shift) % 7, field, "day");
                    }
                    return out;
                }

                function listMonths(format, index) {
                    return listMonthsImpl(format, index, "months");
                }

                function listMonthsShort(format, index) {
                    return listMonthsImpl(format, index, "monthsShort");
                }

                function listWeekdays(localeSorted, format, index) {
                    return listWeekdaysImpl(
                        localeSorted,
                        format,
                        index,
                        "weekdays"
                    );
                }

                function listWeekdaysShort(localeSorted, format, index) {
                    return listWeekdaysImpl(
                        localeSorted,
                        format,
                        index,
                        "weekdaysShort"
                    );
                }

                function listWeekdaysMin(localeSorted, format, index) {
                    return listWeekdaysImpl(
                        localeSorted,
                        format,
                        index,
                        "weekdaysMin"
                    );
                }

                getSetGlobalLocale("en", {
                    eras: [
                        {
                            since: "0001-01-01",
                            until: +Infinity,
                            offset: 1,
                            name: "Anno Domini",
                            narrow: "AD",
                            abbr: "AD",
                        },
                        {
                            since: "0000-12-31",
                            until: -Infinity,
                            offset: 1,
                            name: "Before Christ",
                            narrow: "BC",
                            abbr: "BC",
                        },
                    ],
                    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
                    ordinal: function (number) {
                        var b = number % 10,
                            output =
                                toInt((number % 100) / 10) === 1
                                    ? "th"
                                    : b === 1
                                    ? "st"
                                    : b === 2
                                    ? "nd"
                                    : b === 3
                                    ? "rd"
                                    : "th";
                        return number + output;
                    },
                });

                // Side effect imports

                hooks.lang = deprecate(
                    "moment.lang is deprecated. Use moment.locale instead.",
                    getSetGlobalLocale
                );
                hooks.langData = deprecate(
                    "moment.langData is deprecated. Use moment.localeData instead.",
                    getLocale
                );

                var mathAbs = Math.abs;

                function abs() {
                    var data = this._data;

                    this._milliseconds = mathAbs(this._milliseconds);
                    this._days = mathAbs(this._days);
                    this._months = mathAbs(this._months);

                    data.milliseconds = mathAbs(data.milliseconds);
                    data.seconds = mathAbs(data.seconds);
                    data.minutes = mathAbs(data.minutes);
                    data.hours = mathAbs(data.hours);
                    data.months = mathAbs(data.months);
                    data.years = mathAbs(data.years);

                    return this;
                }

                function addSubtract$1(duration, input, value, direction) {
                    var other = createDuration(input, value);

                    duration._milliseconds += direction * other._milliseconds;
                    duration._days += direction * other._days;
                    duration._months += direction * other._months;

                    return duration._bubble();
                }

                // supports only 2.0-style add(1, 's') or add(duration)
                function add$1(input, value) {
                    return addSubtract$1(this, input, value, 1);
                }

                // supports only 2.0-style subtract(1, 's') or subtract(duration)
                function subtract$1(input, value) {
                    return addSubtract$1(this, input, value, -1);
                }

                function absCeil(number) {
                    if (number < 0) {
                        return Math.floor(number);
                    } else {
                        return Math.ceil(number);
                    }
                }

                function bubble() {
                    var milliseconds = this._milliseconds,
                        days = this._days,
                        months = this._months,
                        data = this._data,
                        seconds,
                        minutes,
                        hours,
                        years,
                        monthsFromDays;

                    // if we have a mix of positive and negative values, bubble down first
                    // check: https://github.com/moment/moment/issues/2166
                    if (
                        !(
                            (milliseconds >= 0 && days >= 0 && months >= 0) ||
                            (milliseconds <= 0 && days <= 0 && months <= 0)
                        )
                    ) {
                        milliseconds +=
                            absCeil(monthsToDays(months) + days) * 864e5;
                        days = 0;
                        months = 0;
                    }

                    // The following code bubbles up values, see the tests for
                    // examples of what that means.
                    data.milliseconds = milliseconds % 1000;

                    seconds = absFloor(milliseconds / 1000);
                    data.seconds = seconds % 60;

                    minutes = absFloor(seconds / 60);
                    data.minutes = minutes % 60;

                    hours = absFloor(minutes / 60);
                    data.hours = hours % 24;

                    days += absFloor(hours / 24);

                    // convert days to months
                    monthsFromDays = absFloor(daysToMonths(days));
                    months += monthsFromDays;
                    days -= absCeil(monthsToDays(monthsFromDays));

                    // 12 months -> 1 year
                    years = absFloor(months / 12);
                    months %= 12;

                    data.days = days;
                    data.months = months;
                    data.years = years;

                    return this;
                }

                function daysToMonths(days) {
                    // 400 years have 146097 days (taking into account leap year rules)
                    // 400 years have 12 months === 4800
                    return (days * 4800) / 146097;
                }

                function monthsToDays(months) {
                    // the reverse of daysToMonths
                    return (months * 146097) / 4800;
                }

                function as(units) {
                    if (!this.isValid()) {
                        return NaN;
                    }
                    var days,
                        months,
                        milliseconds = this._milliseconds;

                    units = normalizeUnits(units);

                    if (
                        units === "month" ||
                        units === "quarter" ||
                        units === "year"
                    ) {
                        days = this._days + milliseconds / 864e5;
                        months = this._months + daysToMonths(days);
                        switch (units) {
                            case "month":
                                return months;
                            case "quarter":
                                return months / 3;
                            case "year":
                                return months / 12;
                        }
                    } else {
                        // handle milliseconds separately because of floating point math errors (issue #1867)
                        days =
                            this._days + Math.round(monthsToDays(this._months));
                        switch (units) {
                            case "week":
                                return days / 7 + milliseconds / 6048e5;
                            case "day":
                                return days + milliseconds / 864e5;
                            case "hour":
                                return days * 24 + milliseconds / 36e5;
                            case "minute":
                                return days * 1440 + milliseconds / 6e4;
                            case "second":
                                return days * 86400 + milliseconds / 1000;
                            // Math.floor prevents floating point math errors here
                            case "millisecond":
                                return Math.floor(days * 864e5) + milliseconds;
                            default:
                                throw new Error("Unknown unit " + units);
                        }
                    }
                }

                // TODO: Use this.as('ms')?
                function valueOf$1() {
                    if (!this.isValid()) {
                        return NaN;
                    }
                    return (
                        this._milliseconds +
                        this._days * 864e5 +
                        (this._months % 12) * 2592e6 +
                        toInt(this._months / 12) * 31536e6
                    );
                }

                function makeAs(alias) {
                    return function () {
                        return this.as(alias);
                    };
                }

                var asMilliseconds = makeAs("ms"),
                    asSeconds = makeAs("s"),
                    asMinutes = makeAs("m"),
                    asHours = makeAs("h"),
                    asDays = makeAs("d"),
                    asWeeks = makeAs("w"),
                    asMonths = makeAs("M"),
                    asQuarters = makeAs("Q"),
                    asYears = makeAs("y");

                function clone$1() {
                    return createDuration(this);
                }

                function get$2(units) {
                    units = normalizeUnits(units);
                    return this.isValid() ? this[units + "s"]() : NaN;
                }

                function makeGetter(name) {
                    return function () {
                        return this.isValid() ? this._data[name] : NaN;
                    };
                }

                var milliseconds = makeGetter("milliseconds"),
                    seconds = makeGetter("seconds"),
                    minutes = makeGetter("minutes"),
                    hours = makeGetter("hours"),
                    days = makeGetter("days"),
                    months = makeGetter("months"),
                    years = makeGetter("years");

                function weeks() {
                    return absFloor(this.days() / 7);
                }

                var round = Math.round,
                    thresholds = {
                        ss: 44, // a few seconds to seconds
                        s: 45, // seconds to minute
                        m: 45, // minutes to hour
                        h: 22, // hours to day
                        d: 26, // days to month/week
                        w: null, // weeks to month
                        M: 11, // months to year
                    };

                // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
                function substituteTimeAgo(
                    string,
                    number,
                    withoutSuffix,
                    isFuture,
                    locale
                ) {
                    return locale.relativeTime(
                        number || 1,
                        !!withoutSuffix,
                        string,
                        isFuture
                    );
                }

                function relativeTime$1(
                    posNegDuration,
                    withoutSuffix,
                    thresholds,
                    locale
                ) {
                    var duration = createDuration(posNegDuration).abs(),
                        seconds = round(duration.as("s")),
                        minutes = round(duration.as("m")),
                        hours = round(duration.as("h")),
                        days = round(duration.as("d")),
                        months = round(duration.as("M")),
                        weeks = round(duration.as("w")),
                        years = round(duration.as("y")),
                        a =
                            (seconds <= thresholds.ss && ["s", seconds]) ||
                            (seconds < thresholds.s && ["ss", seconds]) ||
                            (minutes <= 1 && ["m"]) ||
                            (minutes < thresholds.m && ["mm", minutes]) ||
                            (hours <= 1 && ["h"]) ||
                            (hours < thresholds.h && ["hh", hours]) ||
                            (days <= 1 && ["d"]) ||
                            (days < thresholds.d && ["dd", days]);

                    if (thresholds.w != null) {
                        a =
                            a ||
                            (weeks <= 1 && ["w"]) ||
                            (weeks < thresholds.w && ["ww", weeks]);
                    }
                    a = a ||
                        (months <= 1 && ["M"]) ||
                        (months < thresholds.M && ["MM", months]) ||
                        (years <= 1 && ["y"]) || ["yy", years];

                    a[2] = withoutSuffix;
                    a[3] = +posNegDuration > 0;
                    a[4] = locale;
                    return substituteTimeAgo.apply(null, a);
                }

                // This function allows you to set the rounding function for relative time strings
                function getSetRelativeTimeRounding(roundingFunction) {
                    if (roundingFunction === undefined) {
                        return round;
                    }
                    if (typeof roundingFunction === "function") {
                        round = roundingFunction;
                        return true;
                    }
                    return false;
                }

                // This function allows you to set a threshold for relative time strings
                function getSetRelativeTimeThreshold(threshold, limit) {
                    if (thresholds[threshold] === undefined) {
                        return false;
                    }
                    if (limit === undefined) {
                        return thresholds[threshold];
                    }
                    thresholds[threshold] = limit;
                    if (threshold === "s") {
                        thresholds.ss = limit - 1;
                    }
                    return true;
                }

                function humanize(argWithSuffix, argThresholds) {
                    if (!this.isValid()) {
                        return this.localeData().invalidDate();
                    }

                    var withSuffix = false,
                        th = thresholds,
                        locale,
                        output;

                    if (typeof argWithSuffix === "object") {
                        argThresholds = argWithSuffix;
                        argWithSuffix = false;
                    }
                    if (typeof argWithSuffix === "boolean") {
                        withSuffix = argWithSuffix;
                    }
                    if (typeof argThresholds === "object") {
                        th = Object.assign({}, thresholds, argThresholds);
                        if (
                            argThresholds.s != null &&
                            argThresholds.ss == null
                        ) {
                            th.ss = argThresholds.s - 1;
                        }
                    }

                    locale = this.localeData();
                    output = relativeTime$1(this, !withSuffix, th, locale);

                    if (withSuffix) {
                        output = locale.pastFuture(+this, output);
                    }

                    return locale.postformat(output);
                }

                var abs$1 = Math.abs;

                function sign(x) {
                    return (x > 0) - (x < 0) || +x;
                }

                function toISOString$1() {
                    // for ISO strings we do not use the normal bubbling rules:
                    //  * milliseconds bubble up until they become hours
                    //  * days do not bubble at all
                    //  * months bubble up until they become years
                    // This is because there is no context-free conversion between hours and days
                    // (think of clock changes)
                    // and also not between days and months (28-31 days per month)
                    if (!this.isValid()) {
                        return this.localeData().invalidDate();
                    }

                    var seconds = abs$1(this._milliseconds) / 1000,
                        days = abs$1(this._days),
                        months = abs$1(this._months),
                        minutes,
                        hours,
                        years,
                        s,
                        total = this.asSeconds(),
                        totalSign,
                        ymSign,
                        daysSign,
                        hmsSign;

                    if (!total) {
                        // this is the same as C#'s (Noda) and python (isodate)...
                        // but not other JS (goog.date)
                        return "P0D";
                    }

                    // 3600 seconds -> 60 minutes -> 1 hour
                    minutes = absFloor(seconds / 60);
                    hours = absFloor(minutes / 60);
                    seconds %= 60;
                    minutes %= 60;

                    // 12 months -> 1 year
                    years = absFloor(months / 12);
                    months %= 12;

                    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
                    s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, "") : "";

                    totalSign = total < 0 ? "-" : "";
                    ymSign = sign(this._months) !== sign(total) ? "-" : "";
                    daysSign = sign(this._days) !== sign(total) ? "-" : "";
                    hmsSign =
                        sign(this._milliseconds) !== sign(total) ? "-" : "";

                    return (
                        totalSign +
                        "P" +
                        (years ? ymSign + years + "Y" : "") +
                        (months ? ymSign + months + "M" : "") +
                        (days ? daysSign + days + "D" : "") +
                        (hours || minutes || seconds ? "T" : "") +
                        (hours ? hmsSign + hours + "H" : "") +
                        (minutes ? hmsSign + minutes + "M" : "") +
                        (seconds ? hmsSign + s + "S" : "")
                    );
                }

                var proto$2 = Duration.prototype;

                proto$2.isValid = isValid$1;
                proto$2.abs = abs;
                proto$2.add = add$1;
                proto$2.subtract = subtract$1;
                proto$2.as = as;
                proto$2.asMilliseconds = asMilliseconds;
                proto$2.asSeconds = asSeconds;
                proto$2.asMinutes = asMinutes;
                proto$2.asHours = asHours;
                proto$2.asDays = asDays;
                proto$2.asWeeks = asWeeks;
                proto$2.asMonths = asMonths;
                proto$2.asQuarters = asQuarters;
                proto$2.asYears = asYears;
                proto$2.valueOf = valueOf$1;
                proto$2._bubble = bubble;
                proto$2.clone = clone$1;
                proto$2.get = get$2;
                proto$2.milliseconds = milliseconds;
                proto$2.seconds = seconds;
                proto$2.minutes = minutes;
                proto$2.hours = hours;
                proto$2.days = days;
                proto$2.weeks = weeks;
                proto$2.months = months;
                proto$2.years = years;
                proto$2.humanize = humanize;
                proto$2.toISOString = toISOString$1;
                proto$2.toString = toISOString$1;
                proto$2.toJSON = toISOString$1;
                proto$2.locale = locale;
                proto$2.localeData = localeData;

                proto$2.toIsoString = deprecate(
                    "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
                    toISOString$1
                );
                proto$2.lang = lang;

                // FORMATTING

                addFormatToken("X", 0, 0, "unix");
                addFormatToken("x", 0, 0, "valueOf");

                // PARSING

                addRegexToken("x", matchSigned);
                addRegexToken("X", matchTimestamp);
                addParseToken("X", function (input, array, config) {
                    config._d = new Date(parseFloat(input) * 1000);
                });
                addParseToken("x", function (input, array, config) {
                    config._d = new Date(toInt(input));
                });

                //! moment.js

                hooks.version = "2.29.1";

                setHookCallback(createLocal);

                hooks.fn = proto;
                hooks.min = min;
                hooks.max = max;
                hooks.now = now;
                hooks.utc = createUTC;
                hooks.unix = createUnix;
                hooks.months = listMonths;
                hooks.isDate = isDate;
                hooks.locale = getSetGlobalLocale;
                hooks.invalid = createInvalid;
                hooks.duration = createDuration;
                hooks.isMoment = isMoment;
                hooks.weekdays = listWeekdays;
                hooks.parseZone = createInZone;
                hooks.localeData = getLocale;
                hooks.isDuration = isDuration;
                hooks.monthsShort = listMonthsShort;
                hooks.weekdaysMin = listWeekdaysMin;
                hooks.defineLocale = defineLocale;
                hooks.updateLocale = updateLocale;
                hooks.locales = listLocales;
                hooks.weekdaysShort = listWeekdaysShort;
                hooks.normalizeUnits = normalizeUnits;
                hooks.relativeTimeRounding = getSetRelativeTimeRounding;
                hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
                hooks.calendarFormat = getCalendarFormat;
                hooks.prototype = proto;

                // currently HTML5 input type only supports 24-hour formats
                hooks.HTML5_FMT = {
                    DATETIME_LOCAL: "YYYY-MM-DDTHH:mm", // <input type="datetime-local" />
                    DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss", // <input type="datetime-local" step="1" />
                    DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS", // <input type="datetime-local" step="0.001" />
                    DATE: "YYYY-MM-DD", // <input type="date" />
                    TIME: "HH:mm", // <input type="time" />
                    TIME_SECONDS: "HH:mm:ss", // <input type="time" step="1" />
                    TIME_MS: "HH:mm:ss.SSS", // <input type="time" step="0.001" />
                    WEEK: "GGGG-[W]WW", // <input type="week" />
                    MONTH: "YYYY-MM", // <input type="month" />
                };

                return hooks;
            });

            /***/
        },

        /***/ 467: /***/ (module, exports, __nccwpck_require__) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });

            function _interopDefault(ex) {
                return ex && typeof ex === "object" && "default" in ex
                    ? ex["default"]
                    : ex;
            }

            var Stream = _interopDefault(__nccwpck_require__(2413));
            var http = _interopDefault(__nccwpck_require__(8605));
            var Url = _interopDefault(__nccwpck_require__(8835));
            var https = _interopDefault(__nccwpck_require__(7211));
            var zlib = _interopDefault(__nccwpck_require__(8761));

            // Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js

            // fix for "Readable" isn't a named export issue
            const Readable = Stream.Readable;

            const BUFFER = Symbol("buffer");
            const TYPE = Symbol("type");

            class Blob {
                constructor() {
                    this[TYPE] = "";

                    const blobParts = arguments[0];
                    const options = arguments[1];

                    const buffers = [];
                    let size = 0;

                    if (blobParts) {
                        const a = blobParts;
                        const length = Number(a.length);
                        for (let i = 0; i < length; i++) {
                            const element = a[i];
                            let buffer;
                            if (element instanceof Buffer) {
                                buffer = element;
                            } else if (ArrayBuffer.isView(element)) {
                                buffer = Buffer.from(
                                    element.buffer,
                                    element.byteOffset,
                                    element.byteLength
                                );
                            } else if (element instanceof ArrayBuffer) {
                                buffer = Buffer.from(element);
                            } else if (element instanceof Blob) {
                                buffer = element[BUFFER];
                            } else {
                                buffer = Buffer.from(
                                    typeof element === "string"
                                        ? element
                                        : String(element)
                                );
                            }
                            size += buffer.length;
                            buffers.push(buffer);
                        }
                    }

                    this[BUFFER] = Buffer.concat(buffers);

                    let type =
                        options &&
                        options.type !== undefined &&
                        String(options.type).toLowerCase();
                    if (type && !/[^\u0020-\u007E]/.test(type)) {
                        this[TYPE] = type;
                    }
                }
                get size() {
                    return this[BUFFER].length;
                }
                get type() {
                    return this[TYPE];
                }
                text() {
                    return Promise.resolve(this[BUFFER].toString());
                }
                arrayBuffer() {
                    const buf = this[BUFFER];
                    const ab = buf.buffer.slice(
                        buf.byteOffset,
                        buf.byteOffset + buf.byteLength
                    );
                    return Promise.resolve(ab);
                }
                stream() {
                    const readable = new Readable();
                    readable._read = function () {};
                    readable.push(this[BUFFER]);
                    readable.push(null);
                    return readable;
                }
                toString() {
                    return "[object Blob]";
                }
                slice() {
                    const size = this.size;

                    const start = arguments[0];
                    const end = arguments[1];
                    let relativeStart, relativeEnd;
                    if (start === undefined) {
                        relativeStart = 0;
                    } else if (start < 0) {
                        relativeStart = Math.max(size + start, 0);
                    } else {
                        relativeStart = Math.min(start, size);
                    }
                    if (end === undefined) {
                        relativeEnd = size;
                    } else if (end < 0) {
                        relativeEnd = Math.max(size + end, 0);
                    } else {
                        relativeEnd = Math.min(end, size);
                    }
                    const span = Math.max(relativeEnd - relativeStart, 0);

                    const buffer = this[BUFFER];
                    const slicedBuffer = buffer.slice(
                        relativeStart,
                        relativeStart + span
                    );
                    const blob = new Blob([], { type: arguments[2] });
                    blob[BUFFER] = slicedBuffer;
                    return blob;
                }
            }

            Object.defineProperties(Blob.prototype, {
                size: { enumerable: true },
                type: { enumerable: true },
                slice: { enumerable: true },
            });

            Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
                value: "Blob",
                writable: false,
                enumerable: false,
                configurable: true,
            });

            /**
             * fetch-error.js
             *
             * FetchError interface for operational errors
             */

            /**
             * Create FetchError instance
             *
             * @param   String      message      Error message for human
             * @param   String      type         Error type for machine
             * @param   String      systemError  For Node.js system error
             * @return  FetchError
             */
            function FetchError(message, type, systemError) {
                Error.call(this, message);

                this.message = message;
                this.type = type;

                // when err.type is `system`, err.code contains system error code
                if (systemError) {
                    this.code = this.errno = systemError.code;
                }

                // hide custom error implementation details from end-users
                Error.captureStackTrace(this, this.constructor);
            }

            FetchError.prototype = Object.create(Error.prototype);
            FetchError.prototype.constructor = FetchError;
            FetchError.prototype.name = "FetchError";

            let convert;
            try {
                convert = __nccwpck_require__(2877).convert;
            } catch (e) {}

            const INTERNALS = Symbol("Body internals");

            // fix an issue where "PassThrough" isn't a named export for node <10
            const PassThrough = Stream.PassThrough;

            /**
             * Body mixin
             *
             * Ref: https://fetch.spec.whatwg.org/#body
             *
             * @param   Stream  body  Readable stream
             * @param   Object  opts  Response options
             * @return  Void
             */
            function Body(body) {
                var _this = this;

                var _ref =
                        arguments.length > 1 && arguments[1] !== undefined
                            ? arguments[1]
                            : {},
                    _ref$size = _ref.size;

                let size = _ref$size === undefined ? 0 : _ref$size;
                var _ref$timeout = _ref.timeout;
                let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

                if (body == null) {
                    // body is undefined or null
                    body = null;
                } else if (isURLSearchParams(body)) {
                    // body is a URLSearchParams
                    body = Buffer.from(body.toString());
                } else if (isBlob(body));
                else if (Buffer.isBuffer(body));
                else if (
                    Object.prototype.toString.call(body) ===
                    "[object ArrayBuffer]"
                ) {
                    // body is ArrayBuffer
                    body = Buffer.from(body);
                } else if (ArrayBuffer.isView(body)) {
                    // body is ArrayBufferView
                    body = Buffer.from(
                        body.buffer,
                        body.byteOffset,
                        body.byteLength
                    );
                } else if (body instanceof Stream);
                else {
                    // none of the above
                    // coerce to string then buffer
                    body = Buffer.from(String(body));
                }
                this[INTERNALS] = {
                    body,
                    disturbed: false,
                    error: null,
                };
                this.size = size;
                this.timeout = timeout;

                if (body instanceof Stream) {
                    body.on("error", function (err) {
                        const error =
                            err.name === "AbortError"
                                ? err
                                : new FetchError(
                                      `Invalid response body while trying to fetch ${_this.url}: ${err.message}`,
                                      "system",
                                      err
                                  );
                        _this[INTERNALS].error = error;
                    });
                }
            }

            Body.prototype = {
                get body() {
                    return this[INTERNALS].body;
                },

                get bodyUsed() {
                    return this[INTERNALS].disturbed;
                },

                /**
                 * Decode response as ArrayBuffer
                 *
                 * @return  Promise
                 */
                arrayBuffer() {
                    return consumeBody.call(this).then(function (buf) {
                        return buf.buffer.slice(
                            buf.byteOffset,
                            buf.byteOffset + buf.byteLength
                        );
                    });
                },

                /**
                 * Return raw response as Blob
                 *
                 * @return Promise
                 */
                blob() {
                    let ct =
                        (this.headers && this.headers.get("content-type")) ||
                        "";
                    return consumeBody.call(this).then(function (buf) {
                        return Object.assign(
                            // Prevent copying
                            new Blob([], {
                                type: ct.toLowerCase(),
                            }),
                            {
                                [BUFFER]: buf,
                            }
                        );
                    });
                },

                /**
                 * Decode response as json
                 *
                 * @return  Promise
                 */
                json() {
                    var _this2 = this;

                    return consumeBody.call(this).then(function (buffer) {
                        try {
                            return JSON.parse(buffer.toString());
                        } catch (err) {
                            return Body.Promise.reject(
                                new FetchError(
                                    `invalid json response body at ${_this2.url} reason: ${err.message}`,
                                    "invalid-json"
                                )
                            );
                        }
                    });
                },

                /**
                 * Decode response as text
                 *
                 * @return  Promise
                 */
                text() {
                    return consumeBody.call(this).then(function (buffer) {
                        return buffer.toString();
                    });
                },

                /**
                 * Decode response as buffer (non-spec api)
                 *
                 * @return  Promise
                 */
                buffer() {
                    return consumeBody.call(this);
                },

                /**
                 * Decode response as text, while automatically detecting the encoding and
                 * trying to decode to UTF-8 (non-spec api)
                 *
                 * @return  Promise
                 */
                textConverted() {
                    var _this3 = this;

                    return consumeBody.call(this).then(function (buffer) {
                        return convertBody(buffer, _this3.headers);
                    });
                },
            };

            // In browsers, all properties are enumerable.
            Object.defineProperties(Body.prototype, {
                body: { enumerable: true },
                bodyUsed: { enumerable: true },
                arrayBuffer: { enumerable: true },
                blob: { enumerable: true },
                json: { enumerable: true },
                text: { enumerable: true },
            });

            Body.mixIn = function (proto) {
                for (const name of Object.getOwnPropertyNames(Body.prototype)) {
                    // istanbul ignore else: future proof
                    if (!(name in proto)) {
                        const desc = Object.getOwnPropertyDescriptor(
                            Body.prototype,
                            name
                        );
                        Object.defineProperty(proto, name, desc);
                    }
                }
            };

            /**
             * Consume and convert an entire Body to a Buffer.
             *
             * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
             *
             * @return  Promise
             */
            function consumeBody() {
                var _this4 = this;

                if (this[INTERNALS].disturbed) {
                    return Body.Promise.reject(
                        new TypeError(`body used already for: ${this.url}`)
                    );
                }

                this[INTERNALS].disturbed = true;

                if (this[INTERNALS].error) {
                    return Body.Promise.reject(this[INTERNALS].error);
                }

                let body = this.body;

                // body is null
                if (body === null) {
                    return Body.Promise.resolve(Buffer.alloc(0));
                }

                // body is blob
                if (isBlob(body)) {
                    body = body.stream();
                }

                // body is buffer
                if (Buffer.isBuffer(body)) {
                    return Body.Promise.resolve(body);
                }

                // istanbul ignore if: should never happen
                if (!(body instanceof Stream)) {
                    return Body.Promise.resolve(Buffer.alloc(0));
                }

                // body is stream
                // get ready to actually consume the body
                let accum = [];
                let accumBytes = 0;
                let abort = false;

                return new Body.Promise(function (resolve, reject) {
                    let resTimeout;

                    // allow timeout on slow response body
                    if (_this4.timeout) {
                        resTimeout = setTimeout(function () {
                            abort = true;
                            reject(
                                new FetchError(
                                    `Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`,
                                    "body-timeout"
                                )
                            );
                        }, _this4.timeout);
                    }

                    // handle stream errors
                    body.on("error", function (err) {
                        if (err.name === "AbortError") {
                            // if the request was aborted, reject with this Error
                            abort = true;
                            reject(err);
                        } else {
                            // other errors, such as incorrect content-encoding
                            reject(
                                new FetchError(
                                    `Invalid response body while trying to fetch ${_this4.url}: ${err.message}`,
                                    "system",
                                    err
                                )
                            );
                        }
                    });

                    body.on("data", function (chunk) {
                        if (abort || chunk === null) {
                            return;
                        }

                        if (
                            _this4.size &&
                            accumBytes + chunk.length > _this4.size
                        ) {
                            abort = true;
                            reject(
                                new FetchError(
                                    `content size at ${_this4.url} over limit: ${_this4.size}`,
                                    "max-size"
                                )
                            );
                            return;
                        }

                        accumBytes += chunk.length;
                        accum.push(chunk);
                    });

                    body.on("end", function () {
                        if (abort) {
                            return;
                        }

                        clearTimeout(resTimeout);

                        try {
                            resolve(Buffer.concat(accum, accumBytes));
                        } catch (err) {
                            // handle streams that have accumulated too much data (issue #414)
                            reject(
                                new FetchError(
                                    `Could not create Buffer from response body for ${_this4.url}: ${err.message}`,
                                    "system",
                                    err
                                )
                            );
                        }
                    });
                });
            }

            /**
             * Detect buffer encoding and convert to target encoding
             * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
             *
             * @param   Buffer  buffer    Incoming buffer
             * @param   String  encoding  Target encoding
             * @return  String
             */
            function convertBody(buffer, headers) {
                if (typeof convert !== "function") {
                    throw new Error(
                        "The package `encoding` must be installed to use the textConverted() function"
                    );
                }

                const ct = headers.get("content-type");
                let charset = "utf-8";
                let res, str;

                // header
                if (ct) {
                    res = /charset=([^;]*)/i.exec(ct);
                }

                // no charset in content type, peek at response body for at most 1024 bytes
                str = buffer.slice(0, 1024).toString();

                // html5
                if (!res && str) {
                    res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
                }

                // html4
                if (!res && str) {
                    res =
                        /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(
                            str
                        );

                    if (res) {
                        res = /charset=(.*)/i.exec(res.pop());
                    }
                }

                // xml
                if (!res && str) {
                    res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
                }

                // found charset
                if (res) {
                    charset = res.pop();

                    // prevent decode issues when sites use incorrect encoding
                    // ref: https://hsivonen.fi/encoding-menu/
                    if (charset === "gb2312" || charset === "gbk") {
                        charset = "gb18030";
                    }
                }

                // turn raw buffers into a single utf-8 buffer
                return convert(buffer, "UTF-8", charset).toString();
            }

            /**
             * Detect a URLSearchParams object
             * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
             *
             * @param   Object  obj     Object to detect by type or brand
             * @return  String
             */
            function isURLSearchParams(obj) {
                // Duck-typing as a necessary condition.
                if (
                    typeof obj !== "object" ||
                    typeof obj.append !== "function" ||
                    typeof obj.delete !== "function" ||
                    typeof obj.get !== "function" ||
                    typeof obj.getAll !== "function" ||
                    typeof obj.has !== "function" ||
                    typeof obj.set !== "function"
                ) {
                    return false;
                }

                // Brand-checking and more duck-typing as optional condition.
                return (
                    obj.constructor.name === "URLSearchParams" ||
                    Object.prototype.toString.call(obj) ===
                        "[object URLSearchParams]" ||
                    typeof obj.sort === "function"
                );
            }

            /**
             * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
             * @param  {*} obj
             * @return {boolean}
             */
            function isBlob(obj) {
                return (
                    typeof obj === "object" &&
                    typeof obj.arrayBuffer === "function" &&
                    typeof obj.type === "string" &&
                    typeof obj.stream === "function" &&
                    typeof obj.constructor === "function" &&
                    typeof obj.constructor.name === "string" &&
                    /^(Blob|File)$/.test(obj.constructor.name) &&
                    /^(Blob|File)$/.test(obj[Symbol.toStringTag])
                );
            }

            /**
             * Clone body given Res/Req instance
             *
             * @param   Mixed  instance  Response or Request instance
             * @return  Mixed
             */
            function clone(instance) {
                let p1, p2;
                let body = instance.body;

                // don't allow cloning a used body
                if (instance.bodyUsed) {
                    throw new Error("cannot clone body after it is used");
                }

                // check that body is a stream and not form-data object
                // note: we can't clone the form-data object without having it as a dependency
                if (
                    body instanceof Stream &&
                    typeof body.getBoundary !== "function"
                ) {
                    // tee instance body
                    p1 = new PassThrough();
                    p2 = new PassThrough();
                    body.pipe(p1);
                    body.pipe(p2);
                    // set instance body to teed body and return the other teed body
                    instance[INTERNALS].body = p1;
                    body = p2;
                }

                return body;
            }

            /**
             * Performs the operation "extract a `Content-Type` value from |object|" as
             * specified in the specification:
             * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
             *
             * This function assumes that instance.body is present.
             *
             * @param   Mixed  instance  Any options.body input
             */
            function extractContentType(body) {
                if (body === null) {
                    // body is null
                    return null;
                } else if (typeof body === "string") {
                    // body is string
                    return "text/plain;charset=UTF-8";
                } else if (isURLSearchParams(body)) {
                    // body is a URLSearchParams
                    return "application/x-www-form-urlencoded;charset=UTF-8";
                } else if (isBlob(body)) {
                    // body is blob
                    return body.type || null;
                } else if (Buffer.isBuffer(body)) {
                    // body is buffer
                    return null;
                } else if (
                    Object.prototype.toString.call(body) ===
                    "[object ArrayBuffer]"
                ) {
                    // body is ArrayBuffer
                    return null;
                } else if (ArrayBuffer.isView(body)) {
                    // body is ArrayBufferView
                    return null;
                } else if (typeof body.getBoundary === "function") {
                    // detect form data input from form-data module
                    return `multipart/form-data;boundary=${body.getBoundary()}`;
                } else if (body instanceof Stream) {
                    // body is stream
                    // can't really do much about this
                    return null;
                } else {
                    // Body constructor defaults other things to string
                    return "text/plain;charset=UTF-8";
                }
            }

            /**
             * The Fetch Standard treats this as if "total bytes" is a property on the body.
             * For us, we have to explicitly get it with a function.
             *
             * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
             *
             * @param   Body    instance   Instance of Body
             * @return  Number?            Number of bytes, or null if not possible
             */
            function getTotalBytes(instance) {
                const body = instance.body;

                if (body === null) {
                    // body is null
                    return 0;
                } else if (isBlob(body)) {
                    return body.size;
                } else if (Buffer.isBuffer(body)) {
                    // body is buffer
                    return body.length;
                } else if (body && typeof body.getLengthSync === "function") {
                    // detect form data input from form-data module
                    if (
                        (body._lengthRetrievers &&
                            body._lengthRetrievers.length == 0) || // 1.x
                        (body.hasKnownLength && body.hasKnownLength())
                    ) {
                        // 2.x
                        return body.getLengthSync();
                    }
                    return null;
                } else {
                    // body is stream
                    return null;
                }
            }

            /**
             * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
             *
             * @param   Body    instance   Instance of Body
             * @return  Void
             */
            function writeToStream(dest, instance) {
                const body = instance.body;

                if (body === null) {
                    // body is null
                    dest.end();
                } else if (isBlob(body)) {
                    body.stream().pipe(dest);
                } else if (Buffer.isBuffer(body)) {
                    // body is buffer
                    dest.write(body);
                    dest.end();
                } else {
                    // body is stream
                    body.pipe(dest);
                }
            }

            // expose Promise
            Body.Promise = global.Promise;

            /**
             * headers.js
             *
             * Headers class offers convenient helpers
             */

            const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
            const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

            function validateName(name) {
                name = `${name}`;
                if (invalidTokenRegex.test(name) || name === "") {
                    throw new TypeError(
                        `${name} is not a legal HTTP header name`
                    );
                }
            }

            function validateValue(value) {
                value = `${value}`;
                if (invalidHeaderCharRegex.test(value)) {
                    throw new TypeError(
                        `${value} is not a legal HTTP header value`
                    );
                }
            }

            /**
             * Find the key in the map object given a header name.
             *
             * Returns undefined if not found.
             *
             * @param   String  name  Header name
             * @return  String|Undefined
             */
            function find(map, name) {
                name = name.toLowerCase();
                for (const key in map) {
                    if (key.toLowerCase() === name) {
                        return key;
                    }
                }
                return undefined;
            }

            const MAP = Symbol("map");
            class Headers {
                /**
                 * Headers class
                 *
                 * @param   Object  headers  Response headers
                 * @return  Void
                 */
                constructor() {
                    let init =
                        arguments.length > 0 && arguments[0] !== undefined
                            ? arguments[0]
                            : undefined;

                    this[MAP] = Object.create(null);

                    if (init instanceof Headers) {
                        const rawHeaders = init.raw();
                        const headerNames = Object.keys(rawHeaders);

                        for (const headerName of headerNames) {
                            for (const value of rawHeaders[headerName]) {
                                this.append(headerName, value);
                            }
                        }

                        return;
                    }

                    // We don't worry about converting prop to ByteString here as append()
                    // will handle it.
                    if (init == null);
                    else if (typeof init === "object") {
                        const method = init[Symbol.iterator];
                        if (method != null) {
                            if (typeof method !== "function") {
                                throw new TypeError(
                                    "Header pairs must be iterable"
                                );
                            }

                            // sequence<sequence<ByteString>>
                            // Note: per spec we have to first exhaust the lists then process them
                            const pairs = [];
                            for (const pair of init) {
                                if (
                                    typeof pair !== "object" ||
                                    typeof pair[Symbol.iterator] !== "function"
                                ) {
                                    throw new TypeError(
                                        "Each header pair must be iterable"
                                    );
                                }
                                pairs.push(Array.from(pair));
                            }

                            for (const pair of pairs) {
                                if (pair.length !== 2) {
                                    throw new TypeError(
                                        "Each header pair must be a name/value tuple"
                                    );
                                }
                                this.append(pair[0], pair[1]);
                            }
                        } else {
                            // record<ByteString, ByteString>
                            for (const key of Object.keys(init)) {
                                const value = init[key];
                                this.append(key, value);
                            }
                        }
                    } else {
                        throw new TypeError(
                            "Provided initializer must be an object"
                        );
                    }
                }

                /**
                 * Return combined header value given name
                 *
                 * @param   String  name  Header name
                 * @return  Mixed
                 */
                get(name) {
                    name = `${name}`;
                    validateName(name);
                    const key = find(this[MAP], name);
                    if (key === undefined) {
                        return null;
                    }

                    return this[MAP][key].join(", ");
                }

                /**
                 * Iterate over all headers
                 *
                 * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
                 * @param   Boolean   thisArg   `this` context for callback function
                 * @return  Void
                 */
                forEach(callback) {
                    let thisArg =
                        arguments.length > 1 && arguments[1] !== undefined
                            ? arguments[1]
                            : undefined;

                    let pairs = getHeaders(this);
                    let i = 0;
                    while (i < pairs.length) {
                        var _pairs$i = pairs[i];
                        const name = _pairs$i[0],
                            value = _pairs$i[1];

                        callback.call(thisArg, value, name, this);
                        pairs = getHeaders(this);
                        i++;
                    }
                }

                /**
                 * Overwrite header values given name
                 *
                 * @param   String  name   Header name
                 * @param   String  value  Header value
                 * @return  Void
                 */
                set(name, value) {
                    name = `${name}`;
                    value = `${value}`;
                    validateName(name);
                    validateValue(value);
                    const key = find(this[MAP], name);
                    this[MAP][key !== undefined ? key : name] = [value];
                }

                /**
                 * Append a value onto existing header
                 *
                 * @param   String  name   Header name
                 * @param   String  value  Header value
                 * @return  Void
                 */
                append(name, value) {
                    name = `${name}`;
                    value = `${value}`;
                    validateName(name);
                    validateValue(value);
                    const key = find(this[MAP], name);
                    if (key !== undefined) {
                        this[MAP][key].push(value);
                    } else {
                        this[MAP][name] = [value];
                    }
                }

                /**
                 * Check for header name existence
                 *
                 * @param   String   name  Header name
                 * @return  Boolean
                 */
                has(name) {
                    name = `${name}`;
                    validateName(name);
                    return find(this[MAP], name) !== undefined;
                }

                /**
                 * Delete all header values given name
                 *
                 * @param   String  name  Header name
                 * @return  Void
                 */
                delete(name) {
                    name = `${name}`;
                    validateName(name);
                    const key = find(this[MAP], name);
                    if (key !== undefined) {
                        delete this[MAP][key];
                    }
                }

                /**
                 * Return raw headers (non-spec api)
                 *
                 * @return  Object
                 */
                raw() {
                    return this[MAP];
                }

                /**
                 * Get an iterator on keys.
                 *
                 * @return  Iterator
                 */
                keys() {
                    return createHeadersIterator(this, "key");
                }

                /**
                 * Get an iterator on values.
                 *
                 * @return  Iterator
                 */
                values() {
                    return createHeadersIterator(this, "value");
                }

                /**
                 * Get an iterator on entries.
                 *
                 * This is the default iterator of the Headers object.
                 *
                 * @return  Iterator
                 */
                [Symbol.iterator]() {
                    return createHeadersIterator(this, "key+value");
                }
            }
            Headers.prototype.entries = Headers.prototype[Symbol.iterator];

            Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
                value: "Headers",
                writable: false,
                enumerable: false,
                configurable: true,
            });

            Object.defineProperties(Headers.prototype, {
                get: { enumerable: true },
                forEach: { enumerable: true },
                set: { enumerable: true },
                append: { enumerable: true },
                has: { enumerable: true },
                delete: { enumerable: true },
                keys: { enumerable: true },
                values: { enumerable: true },
                entries: { enumerable: true },
            });

            function getHeaders(headers) {
                let kind =
                    arguments.length > 1 && arguments[1] !== undefined
                        ? arguments[1]
                        : "key+value";

                const keys = Object.keys(headers[MAP]).sort();
                return keys.map(
                    kind === "key"
                        ? function (k) {
                              return k.toLowerCase();
                          }
                        : kind === "value"
                        ? function (k) {
                              return headers[MAP][k].join(", ");
                          }
                        : function (k) {
                              return [
                                  k.toLowerCase(),
                                  headers[MAP][k].join(", "),
                              ];
                          }
                );
            }

            const INTERNAL = Symbol("internal");

            function createHeadersIterator(target, kind) {
                const iterator = Object.create(HeadersIteratorPrototype);
                iterator[INTERNAL] = {
                    target,
                    kind,
                    index: 0,
                };
                return iterator;
            }

            const HeadersIteratorPrototype = Object.setPrototypeOf(
                {
                    next() {
                        // istanbul ignore if
                        if (
                            !this ||
                            Object.getPrototypeOf(this) !==
                                HeadersIteratorPrototype
                        ) {
                            throw new TypeError(
                                "Value of `this` is not a HeadersIterator"
                            );
                        }

                        var _INTERNAL = this[INTERNAL];
                        const target = _INTERNAL.target,
                            kind = _INTERNAL.kind,
                            index = _INTERNAL.index;

                        const values = getHeaders(target, kind);
                        const len = values.length;
                        if (index >= len) {
                            return {
                                value: undefined,
                                done: true,
                            };
                        }

                        this[INTERNAL].index = index + 1;

                        return {
                            value: values[index],
                            done: false,
                        };
                    },
                },
                Object.getPrototypeOf(
                    Object.getPrototypeOf([][Symbol.iterator]())
                )
            );

            Object.defineProperty(
                HeadersIteratorPrototype,
                Symbol.toStringTag,
                {
                    value: "HeadersIterator",
                    writable: false,
                    enumerable: false,
                    configurable: true,
                }
            );

            /**
             * Export the Headers object in a form that Node.js can consume.
             *
             * @param   Headers  headers
             * @return  Object
             */
            function exportNodeCompatibleHeaders(headers) {
                const obj = Object.assign({ __proto__: null }, headers[MAP]);

                // http.request() only supports string as Host header. This hack makes
                // specifying custom Host header possible.
                const hostHeaderKey = find(headers[MAP], "Host");
                if (hostHeaderKey !== undefined) {
                    obj[hostHeaderKey] = obj[hostHeaderKey][0];
                }

                return obj;
            }

            /**
             * Create a Headers object from an object of headers, ignoring those that do
             * not conform to HTTP grammar productions.
             *
             * @param   Object  obj  Object of headers
             * @return  Headers
             */
            function createHeadersLenient(obj) {
                const headers = new Headers();
                for (const name of Object.keys(obj)) {
                    if (invalidTokenRegex.test(name)) {
                        continue;
                    }
                    if (Array.isArray(obj[name])) {
                        for (const val of obj[name]) {
                            if (invalidHeaderCharRegex.test(val)) {
                                continue;
                            }
                            if (headers[MAP][name] === undefined) {
                                headers[MAP][name] = [val];
                            } else {
                                headers[MAP][name].push(val);
                            }
                        }
                    } else if (!invalidHeaderCharRegex.test(obj[name])) {
                        headers[MAP][name] = [obj[name]];
                    }
                }
                return headers;
            }

            const INTERNALS$1 = Symbol("Response internals");

            // fix an issue where "STATUS_CODES" aren't a named export for node <10
            const STATUS_CODES = http.STATUS_CODES;

            /**
             * Response class
             *
             * @param   Stream  body  Readable stream
             * @param   Object  opts  Response options
             * @return  Void
             */
            class Response {
                constructor() {
                    let body =
                        arguments.length > 0 && arguments[0] !== undefined
                            ? arguments[0]
                            : null;
                    let opts =
                        arguments.length > 1 && arguments[1] !== undefined
                            ? arguments[1]
                            : {};

                    Body.call(this, body, opts);

                    const status = opts.status || 200;
                    const headers = new Headers(opts.headers);

                    if (body != null && !headers.has("Content-Type")) {
                        const contentType = extractContentType(body);
                        if (contentType) {
                            headers.append("Content-Type", contentType);
                        }
                    }

                    this[INTERNALS$1] = {
                        url: opts.url,
                        status,
                        statusText: opts.statusText || STATUS_CODES[status],
                        headers,
                        counter: opts.counter,
                    };
                }

                get url() {
                    return this[INTERNALS$1].url || "";
                }

                get status() {
                    return this[INTERNALS$1].status;
                }

                /**
                 * Convenience property representing if the request ended normally
                 */
                get ok() {
                    return (
                        this[INTERNALS$1].status >= 200 &&
                        this[INTERNALS$1].status < 300
                    );
                }

                get redirected() {
                    return this[INTERNALS$1].counter > 0;
                }

                get statusText() {
                    return this[INTERNALS$1].statusText;
                }

                get headers() {
                    return this[INTERNALS$1].headers;
                }

                /**
                 * Clone this response
                 *
                 * @return  Response
                 */
                clone() {
                    return new Response(clone(this), {
                        url: this.url,
                        status: this.status,
                        statusText: this.statusText,
                        headers: this.headers,
                        ok: this.ok,
                        redirected: this.redirected,
                    });
                }
            }

            Body.mixIn(Response.prototype);

            Object.defineProperties(Response.prototype, {
                url: { enumerable: true },
                status: { enumerable: true },
                ok: { enumerable: true },
                redirected: { enumerable: true },
                statusText: { enumerable: true },
                headers: { enumerable: true },
                clone: { enumerable: true },
            });

            Object.defineProperty(Response.prototype, Symbol.toStringTag, {
                value: "Response",
                writable: false,
                enumerable: false,
                configurable: true,
            });

            const INTERNALS$2 = Symbol("Request internals");

            // fix an issue where "format", "parse" aren't a named export for node <10
            const parse_url = Url.parse;
            const format_url = Url.format;

            const streamDestructionSupported =
                "destroy" in Stream.Readable.prototype;

            /**
             * Check if a value is an instance of Request.
             *
             * @param   Mixed   input
             * @return  Boolean
             */
            function isRequest(input) {
                return (
                    typeof input === "object" &&
                    typeof input[INTERNALS$2] === "object"
                );
            }

            function isAbortSignal(signal) {
                const proto =
                    signal &&
                    typeof signal === "object" &&
                    Object.getPrototypeOf(signal);
                return !!(proto && proto.constructor.name === "AbortSignal");
            }

            /**
             * Request class
             *
             * @param   Mixed   input  Url or Request instance
             * @param   Object  init   Custom options
             * @return  Void
             */
            class Request {
                constructor(input) {
                    let init =
                        arguments.length > 1 && arguments[1] !== undefined
                            ? arguments[1]
                            : {};

                    let parsedURL;

                    // normalize input
                    if (!isRequest(input)) {
                        if (input && input.href) {
                            // in order to support Node.js' Url objects; though WHATWG's URL objects
                            // will fall into this branch also (since their `toString()` will return
                            // `href` property anyway)
                            parsedURL = parse_url(input.href);
                        } else {
                            // coerce input to a string before attempting to parse
                            parsedURL = parse_url(`${input}`);
                        }
                        input = {};
                    } else {
                        parsedURL = parse_url(input.url);
                    }

                    let method = init.method || input.method || "GET";
                    method = method.toUpperCase();

                    if (
                        (init.body != null ||
                            (isRequest(input) && input.body !== null)) &&
                        (method === "GET" || method === "HEAD")
                    ) {
                        throw new TypeError(
                            "Request with GET/HEAD method cannot have body"
                        );
                    }

                    let inputBody =
                        init.body != null
                            ? init.body
                            : isRequest(input) && input.body !== null
                            ? clone(input)
                            : null;

                    Body.call(this, inputBody, {
                        timeout: init.timeout || input.timeout || 0,
                        size: init.size || input.size || 0,
                    });

                    const headers = new Headers(
                        init.headers || input.headers || {}
                    );

                    if (inputBody != null && !headers.has("Content-Type")) {
                        const contentType = extractContentType(inputBody);
                        if (contentType) {
                            headers.append("Content-Type", contentType);
                        }
                    }

                    let signal = isRequest(input) ? input.signal : null;
                    if ("signal" in init) signal = init.signal;

                    if (signal != null && !isAbortSignal(signal)) {
                        throw new TypeError(
                            "Expected signal to be an instanceof AbortSignal"
                        );
                    }

                    this[INTERNALS$2] = {
                        method,
                        redirect: init.redirect || input.redirect || "follow",
                        headers,
                        parsedURL,
                        signal,
                    };

                    // node-fetch-only options
                    this.follow =
                        init.follow !== undefined
                            ? init.follow
                            : input.follow !== undefined
                            ? input.follow
                            : 20;
                    this.compress =
                        init.compress !== undefined
                            ? init.compress
                            : input.compress !== undefined
                            ? input.compress
                            : true;
                    this.counter = init.counter || input.counter || 0;
                    this.agent = init.agent || input.agent;
                }

                get method() {
                    return this[INTERNALS$2].method;
                }

                get url() {
                    return format_url(this[INTERNALS$2].parsedURL);
                }

                get headers() {
                    return this[INTERNALS$2].headers;
                }

                get redirect() {
                    return this[INTERNALS$2].redirect;
                }

                get signal() {
                    return this[INTERNALS$2].signal;
                }

                /**
                 * Clone this request
                 *
                 * @return  Request
                 */
                clone() {
                    return new Request(this);
                }
            }

            Body.mixIn(Request.prototype);

            Object.defineProperty(Request.prototype, Symbol.toStringTag, {
                value: "Request",
                writable: false,
                enumerable: false,
                configurable: true,
            });

            Object.defineProperties(Request.prototype, {
                method: { enumerable: true },
                url: { enumerable: true },
                headers: { enumerable: true },
                redirect: { enumerable: true },
                clone: { enumerable: true },
                signal: { enumerable: true },
            });

            /**
             * Convert a Request to Node.js http request options.
             *
             * @param   Request  A Request instance
             * @return  Object   The options object to be passed to http.request
             */
            function getNodeRequestOptions(request) {
                const parsedURL = request[INTERNALS$2].parsedURL;
                const headers = new Headers(request[INTERNALS$2].headers);

                // fetch step 1.3
                if (!headers.has("Accept")) {
                    headers.set("Accept", "*/*");
                }

                // Basic fetch
                if (!parsedURL.protocol || !parsedURL.hostname) {
                    throw new TypeError("Only absolute URLs are supported");
                }

                if (!/^https?:$/.test(parsedURL.protocol)) {
                    throw new TypeError("Only HTTP(S) protocols are supported");
                }

                if (
                    request.signal &&
                    request.body instanceof Stream.Readable &&
                    !streamDestructionSupported
                ) {
                    throw new Error(
                        "Cancellation of streamed requests with AbortSignal is not supported in node < 8"
                    );
                }

                // HTTP-network-or-cache fetch steps 2.4-2.7
                let contentLengthValue = null;
                if (
                    request.body == null &&
                    /^(POST|PUT)$/i.test(request.method)
                ) {
                    contentLengthValue = "0";
                }
                if (request.body != null) {
                    const totalBytes = getTotalBytes(request);
                    if (typeof totalBytes === "number") {
                        contentLengthValue = String(totalBytes);
                    }
                }
                if (contentLengthValue) {
                    headers.set("Content-Length", contentLengthValue);
                }

                // HTTP-network-or-cache fetch step 2.11
                if (!headers.has("User-Agent")) {
                    headers.set(
                        "User-Agent",
                        "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)"
                    );
                }

                // HTTP-network-or-cache fetch step 2.15
                if (request.compress && !headers.has("Accept-Encoding")) {
                    headers.set("Accept-Encoding", "gzip,deflate");
                }

                let agent = request.agent;
                if (typeof agent === "function") {
                    agent = agent(parsedURL);
                }

                if (!headers.has("Connection") && !agent) {
                    headers.set("Connection", "close");
                }

                // HTTP-network fetch step 4.2
                // chunked encoding is handled by Node.js

                return Object.assign({}, parsedURL, {
                    method: request.method,
                    headers: exportNodeCompatibleHeaders(headers),
                    agent,
                });
            }

            /**
             * abort-error.js
             *
             * AbortError interface for cancelled requests
             */

            /**
             * Create AbortError instance
             *
             * @param   String      message      Error message for human
             * @return  AbortError
             */
            function AbortError(message) {
                Error.call(this, message);

                this.type = "aborted";
                this.message = message;

                // hide custom error implementation details from end-users
                Error.captureStackTrace(this, this.constructor);
            }

            AbortError.prototype = Object.create(Error.prototype);
            AbortError.prototype.constructor = AbortError;
            AbortError.prototype.name = "AbortError";

            // fix an issue where "PassThrough", "resolve" aren't a named export for node <10
            const PassThrough$1 = Stream.PassThrough;
            const resolve_url = Url.resolve;

            /**
             * Fetch function
             *
             * @param   Mixed    url   Absolute url or Request instance
             * @param   Object   opts  Fetch options
             * @return  Promise
             */
            function fetch(url, opts) {
                // allow custom promise
                if (!fetch.Promise) {
                    throw new Error(
                        "native promise missing, set fetch.Promise to your favorite alternative"
                    );
                }

                Body.Promise = fetch.Promise;

                // wrap http.request into fetch
                return new fetch.Promise(function (resolve, reject) {
                    // build request object
                    const request = new Request(url, opts);
                    const options = getNodeRequestOptions(request);

                    const send = (options.protocol === "https:" ? https : http)
                        .request;
                    const signal = request.signal;

                    let response = null;

                    const abort = function abort() {
                        let error = new AbortError(
                            "The user aborted a request."
                        );
                        reject(error);
                        if (
                            request.body &&
                            request.body instanceof Stream.Readable
                        ) {
                            request.body.destroy(error);
                        }
                        if (!response || !response.body) return;
                        response.body.emit("error", error);
                    };

                    if (signal && signal.aborted) {
                        abort();
                        return;
                    }

                    const abortAndFinalize = function abortAndFinalize() {
                        abort();
                        finalize();
                    };

                    // send request
                    const req = send(options);
                    let reqTimeout;

                    if (signal) {
                        signal.addEventListener("abort", abortAndFinalize);
                    }

                    function finalize() {
                        req.abort();
                        if (signal)
                            signal.removeEventListener(
                                "abort",
                                abortAndFinalize
                            );
                        clearTimeout(reqTimeout);
                    }

                    if (request.timeout) {
                        req.once("socket", function (socket) {
                            reqTimeout = setTimeout(function () {
                                reject(
                                    new FetchError(
                                        `network timeout at: ${request.url}`,
                                        "request-timeout"
                                    )
                                );
                                finalize();
                            }, request.timeout);
                        });
                    }

                    req.on("error", function (err) {
                        reject(
                            new FetchError(
                                `request to ${request.url} failed, reason: ${err.message}`,
                                "system",
                                err
                            )
                        );
                        finalize();
                    });

                    req.on("response", function (res) {
                        clearTimeout(reqTimeout);

                        const headers = createHeadersLenient(res.headers);

                        // HTTP fetch step 5
                        if (fetch.isRedirect(res.statusCode)) {
                            // HTTP fetch step 5.2
                            const location = headers.get("Location");

                            // HTTP fetch step 5.3
                            const locationURL =
                                location === null
                                    ? null
                                    : resolve_url(request.url, location);

                            // HTTP fetch step 5.5
                            switch (request.redirect) {
                                case "error":
                                    reject(
                                        new FetchError(
                                            `redirect mode is set to error: ${request.url}`,
                                            "no-redirect"
                                        )
                                    );
                                    finalize();
                                    return;
                                case "manual":
                                    // node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
                                    if (locationURL !== null) {
                                        // handle corrupted header
                                        try {
                                            headers.set(
                                                "Location",
                                                locationURL
                                            );
                                        } catch (err) {
                                            // istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
                                            reject(err);
                                        }
                                    }
                                    break;
                                case "follow":
                                    // HTTP-redirect fetch step 2
                                    if (locationURL === null) {
                                        break;
                                    }

                                    // HTTP-redirect fetch step 5
                                    if (request.counter >= request.follow) {
                                        reject(
                                            new FetchError(
                                                `maximum redirect reached at: ${request.url}`,
                                                "max-redirect"
                                            )
                                        );
                                        finalize();
                                        return;
                                    }

                                    // HTTP-redirect fetch step 6 (counter increment)
                                    // Create a new Request object.
                                    const requestOpts = {
                                        headers: new Headers(request.headers),
                                        follow: request.follow,
                                        counter: request.counter + 1,
                                        agent: request.agent,
                                        compress: request.compress,
                                        method: request.method,
                                        body: request.body,
                                        signal: request.signal,
                                        timeout: request.timeout,
                                    };

                                    // HTTP-redirect fetch step 9
                                    if (
                                        res.statusCode !== 303 &&
                                        request.body &&
                                        getTotalBytes(request) === null
                                    ) {
                                        reject(
                                            new FetchError(
                                                "Cannot follow redirect with body being a readable stream",
                                                "unsupported-redirect"
                                            )
                                        );
                                        finalize();
                                        return;
                                    }

                                    // HTTP-redirect fetch step 11
                                    if (
                                        res.statusCode === 303 ||
                                        ((res.statusCode === 301 ||
                                            res.statusCode === 302) &&
                                            request.method === "POST")
                                    ) {
                                        requestOpts.method = "GET";
                                        requestOpts.body = undefined;
                                        requestOpts.headers.delete(
                                            "content-length"
                                        );
                                    }

                                    // HTTP-redirect fetch step 15
                                    resolve(
                                        fetch(
                                            new Request(
                                                locationURL,
                                                requestOpts
                                            )
                                        )
                                    );
                                    finalize();
                                    return;
                            }
                        }

                        // prepare response
                        res.once("end", function () {
                            if (signal)
                                signal.removeEventListener(
                                    "abort",
                                    abortAndFinalize
                                );
                        });
                        let body = res.pipe(new PassThrough$1());

                        const response_options = {
                            url: request.url,
                            status: res.statusCode,
                            statusText: res.statusMessage,
                            headers: headers,
                            size: request.size,
                            timeout: request.timeout,
                            counter: request.counter,
                        };

                        // HTTP-network fetch step 12.1.1.3
                        const codings = headers.get("Content-Encoding");

                        // HTTP-network fetch step 12.1.1.4: handle content codings

                        // in following scenarios we ignore compression support
                        // 1. compression support is disabled
                        // 2. HEAD request
                        // 3. no Content-Encoding header
                        // 4. no content response (204)
                        // 5. content not modified response (304)
                        if (
                            !request.compress ||
                            request.method === "HEAD" ||
                            codings === null ||
                            res.statusCode === 204 ||
                            res.statusCode === 304
                        ) {
                            response = new Response(body, response_options);
                            resolve(response);
                            return;
                        }

                        // For Node v6+
                        // Be less strict when decoding compressed responses, since sometimes
                        // servers send slightly invalid responses that are still accepted
                        // by common browsers.
                        // Always using Z_SYNC_FLUSH is what cURL does.
                        const zlibOptions = {
                            flush: zlib.Z_SYNC_FLUSH,
                            finishFlush: zlib.Z_SYNC_FLUSH,
                        };

                        // for gzip
                        if (codings == "gzip" || codings == "x-gzip") {
                            body = body.pipe(zlib.createGunzip(zlibOptions));
                            response = new Response(body, response_options);
                            resolve(response);
                            return;
                        }

                        // for deflate
                        if (codings == "deflate" || codings == "x-deflate") {
                            // handle the infamous raw deflate response from old servers
                            // a hack for old IIS and Apache servers
                            const raw = res.pipe(new PassThrough$1());
                            raw.once("data", function (chunk) {
                                // see http://stackoverflow.com/questions/37519828
                                if ((chunk[0] & 0x0f) === 0x08) {
                                    body = body.pipe(zlib.createInflate());
                                } else {
                                    body = body.pipe(zlib.createInflateRaw());
                                }
                                response = new Response(body, response_options);
                                resolve(response);
                            });
                            return;
                        }

                        // for br
                        if (
                            codings == "br" &&
                            typeof zlib.createBrotliDecompress === "function"
                        ) {
                            body = body.pipe(zlib.createBrotliDecompress());
                            response = new Response(body, response_options);
                            resolve(response);
                            return;
                        }

                        // otherwise, use response as-is
                        response = new Response(body, response_options);
                        resolve(response);
                    });

                    writeToStream(req, request);
                });
            }
            /**
             * Redirect code matching
             *
             * @param   Number   code  Status code
             * @return  Boolean
             */
            fetch.isRedirect = function (code) {
                return (
                    code === 301 ||
                    code === 302 ||
                    code === 303 ||
                    code === 307 ||
                    code === 308
                );
            };

            // expose Promise
            fetch.Promise = global.Promise;

            module.exports = exports = fetch;
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.default = exports;
            exports.Headers = Headers;
            exports.Request = Request;
            exports.Response = Response;
            exports.FetchError = FetchError;

            /***/
        },

        /***/ 7952: /***/ (module) => {
            "use strict";

            // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
            const DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
            const DATA_URL_DEFAULT_CHARSET = "us-ascii";

            const testParameter = (name, filters) => {
                return filters.some((filter) =>
                    filter instanceof RegExp
                        ? filter.test(name)
                        : filter === name
                );
            };

            const normalizeDataURL = (urlString, { stripHash }) => {
                const match =
                    /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(
                        urlString
                    );

                if (!match) {
                    throw new Error(`Invalid URL: ${urlString}`);
                }

                let { type, data, hash } = match.groups;
                const mediaType = type.split(";");
                hash = stripHash ? "" : hash;

                let isBase64 = false;
                if (mediaType[mediaType.length - 1] === "base64") {
                    mediaType.pop();
                    isBase64 = true;
                }

                // Lowercase MIME type
                const mimeType = (mediaType.shift() || "").toLowerCase();
                const attributes = mediaType
                    .map((attribute) => {
                        let [key, value = ""] = attribute
                            .split("=")
                            .map((string) => string.trim());

                        // Lowercase `charset`
                        if (key === "charset") {
                            value = value.toLowerCase();

                            if (value === DATA_URL_DEFAULT_CHARSET) {
                                return "";
                            }
                        }

                        return `${key}${value ? `=${value}` : ""}`;
                    })
                    .filter(Boolean);

                const normalizedMediaType = [...attributes];

                if (isBase64) {
                    normalizedMediaType.push("base64");
                }

                if (
                    normalizedMediaType.length !== 0 ||
                    (mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE)
                ) {
                    normalizedMediaType.unshift(mimeType);
                }

                return `data:${normalizedMediaType.join(";")},${
                    isBase64 ? data.trim() : data
                }${hash ? `#${hash}` : ""}`;
            };

            const normalizeUrl = (urlString, options) => {
                options = {
                    defaultProtocol: "http:",
                    normalizeProtocol: true,
                    forceHttp: false,
                    forceHttps: false,
                    stripAuthentication: true,
                    stripHash: false,
                    stripTextFragment: true,
                    stripWWW: true,
                    removeQueryParameters: [/^utm_\w+/i],
                    removeTrailingSlash: true,
                    removeSingleSlash: true,
                    removeDirectoryIndex: false,
                    sortQueryParameters: true,
                    ...options,
                };

                urlString = urlString.trim();

                // Data URL
                if (/^data:/i.test(urlString)) {
                    return normalizeDataURL(urlString, options);
                }

                if (/^view-source:/i.test(urlString)) {
                    throw new Error(
                        "`view-source:` is not supported as it is a non-standard protocol"
                    );
                }

                const hasRelativeProtocol = urlString.startsWith("//");
                const isRelativeUrl =
                    !hasRelativeProtocol && /^\.*\//.test(urlString);

                // Prepend protocol
                if (!isRelativeUrl) {
                    urlString = urlString.replace(
                        /^(?!(?:\w+:)?\/\/)|^\/\//,
                        options.defaultProtocol
                    );
                }

                const urlObj = new URL(urlString);

                if (options.forceHttp && options.forceHttps) {
                    throw new Error(
                        "The `forceHttp` and `forceHttps` options cannot be used together"
                    );
                }

                if (options.forceHttp && urlObj.protocol === "https:") {
                    urlObj.protocol = "http:";
                }

                if (options.forceHttps && urlObj.protocol === "http:") {
                    urlObj.protocol = "https:";
                }

                // Remove auth
                if (options.stripAuthentication) {
                    urlObj.username = "";
                    urlObj.password = "";
                }

                // Remove hash
                if (options.stripHash) {
                    urlObj.hash = "";
                } else if (options.stripTextFragment) {
                    urlObj.hash = urlObj.hash.replace(/#?:~:text.*?$/i, "");
                }

                // Remove duplicate slashes if not preceded by a protocol
                if (urlObj.pathname) {
                    urlObj.pathname = urlObj.pathname.replace(
                        /(?<!\b(?:[a-z][a-z\d+\-.]{1,50}:))\/{2,}/g,
                        "/"
                    );
                }

                // Decode URI octets
                if (urlObj.pathname) {
                    try {
                        urlObj.pathname = decodeURI(urlObj.pathname);
                    } catch (_) {}
                }

                // Remove directory index
                if (options.removeDirectoryIndex === true) {
                    options.removeDirectoryIndex = [/^index\.[a-z]+$/];
                }

                if (
                    Array.isArray(options.removeDirectoryIndex) &&
                    options.removeDirectoryIndex.length > 0
                ) {
                    let pathComponents = urlObj.pathname.split("/");
                    const lastComponent =
                        pathComponents[pathComponents.length - 1];

                    if (
                        testParameter(
                            lastComponent,
                            options.removeDirectoryIndex
                        )
                    ) {
                        pathComponents = pathComponents.slice(
                            0,
                            pathComponents.length - 1
                        );
                        urlObj.pathname =
                            pathComponents.slice(1).join("/") + "/";
                    }
                }

                if (urlObj.hostname) {
                    // Remove trailing dot
                    urlObj.hostname = urlObj.hostname.replace(/\.$/, "");

                    // Remove `www.`
                    if (
                        options.stripWWW &&
                        /^www\.(?!www\.)(?:[a-z\-\d]{1,63})\.(?:[a-z.\-\d]{2,63})$/.test(
                            urlObj.hostname
                        )
                    ) {
                        // Each label should be max 63 at length (min: 1).
                        // Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
                        // Each TLD should be up to 63 characters long (min: 2).
                        // It is technically possible to have a single character TLD, but none currently exist.
                        urlObj.hostname = urlObj.hostname.replace(/^www\./, "");
                    }
                }

                // Remove query unwanted parameters
                if (Array.isArray(options.removeQueryParameters)) {
                    for (const key of [...urlObj.searchParams.keys()]) {
                        if (testParameter(key, options.removeQueryParameters)) {
                            urlObj.searchParams.delete(key);
                        }
                    }
                }

                if (options.removeQueryParameters === true) {
                    urlObj.search = "";
                }

                // Sort query parameters
                if (options.sortQueryParameters) {
                    urlObj.searchParams.sort();
                }

                if (options.removeTrailingSlash) {
                    urlObj.pathname = urlObj.pathname.replace(/\/$/, "");
                }

                const oldUrlString = urlString;

                // Take advantage of many of the Node `url` normalizations
                urlString = urlObj.toString();

                if (
                    !options.removeSingleSlash &&
                    urlObj.pathname === "/" &&
                    !oldUrlString.endsWith("/") &&
                    urlObj.hash === ""
                ) {
                    urlString = urlString.replace(/\/$/, "");
                }

                // Remove ending `/` unless removeSingleSlash is false
                if (
                    (options.removeTrailingSlash || urlObj.pathname === "/") &&
                    urlObj.hash === "" &&
                    options.removeSingleSlash
                ) {
                    urlString = urlString.replace(/\/$/, "");
                }

                // Restore relative protocol, if applicable
                if (hasRelativeProtocol && !options.normalizeProtocol) {
                    urlString = urlString.replace(/^http:\/\//, "//");
                }

                // Remove http/https
                if (options.stripProtocol) {
                    urlString = urlString.replace(/^(?:https?:)?\/\//, "");
                }

                return urlString;
            };

            module.exports = normalizeUrl;

            /***/
        },

        /***/ 1223: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            var wrappy = __nccwpck_require__(2940);
            module.exports = wrappy(once);
            module.exports.strict = wrappy(onceStrict);

            once.proto = once(function () {
                Object.defineProperty(Function.prototype, "once", {
                    value: function () {
                        return once(this);
                    },
                    configurable: true,
                });

                Object.defineProperty(Function.prototype, "onceStrict", {
                    value: function () {
                        return onceStrict(this);
                    },
                    configurable: true,
                });
            });

            function once(fn) {
                var f = function () {
                    if (f.called) return f.value;
                    f.called = true;
                    return (f.value = fn.apply(this, arguments));
                };
                f.called = false;
                return f;
            }

            function onceStrict(fn) {
                var f = function () {
                    if (f.called) throw new Error(f.onceError);
                    f.called = true;
                    return (f.value = fn.apply(this, arguments));
                };
                var name = fn.name || "Function wrapped with `once`";
                f.onceError = name + " shouldn't be called more than once";
                f.called = false;
                return f;
            }

            /***/
        },

        /***/ 9072: /***/ (module) => {
            "use strict";

            class CancelError extends Error {
                constructor(reason) {
                    super(reason || "Promise was canceled");
                    this.name = "CancelError";
                }

                get isCanceled() {
                    return true;
                }
            }

            class PCancelable {
                static fn(userFn) {
                    return (...arguments_) => {
                        return new PCancelable((resolve, reject, onCancel) => {
                            arguments_.push(onCancel);
                            // eslint-disable-next-line promise/prefer-await-to-then
                            userFn(...arguments_).then(resolve, reject);
                        });
                    };
                }

                constructor(executor) {
                    this._cancelHandlers = [];
                    this._isPending = true;
                    this._isCanceled = false;
                    this._rejectOnCancel = true;

                    this._promise = new Promise((resolve, reject) => {
                        this._reject = reject;

                        const onResolve = (value) => {
                            if (!this._isCanceled || !onCancel.shouldReject) {
                                this._isPending = false;
                                resolve(value);
                            }
                        };

                        const onReject = (error) => {
                            this._isPending = false;
                            reject(error);
                        };

                        const onCancel = (handler) => {
                            if (!this._isPending) {
                                throw new Error(
                                    "The `onCancel` handler was attached after the promise settled."
                                );
                            }

                            this._cancelHandlers.push(handler);
                        };

                        Object.defineProperties(onCancel, {
                            shouldReject: {
                                get: () => this._rejectOnCancel,
                                set: (boolean) => {
                                    this._rejectOnCancel = boolean;
                                },
                            },
                        });

                        return executor(onResolve, onReject, onCancel);
                    });
                }

                then(onFulfilled, onRejected) {
                    // eslint-disable-next-line promise/prefer-await-to-then
                    return this._promise.then(onFulfilled, onRejected);
                }

                catch(onRejected) {
                    return this._promise.catch(onRejected);
                }

                finally(onFinally) {
                    return this._promise.finally(onFinally);
                }

                cancel(reason) {
                    if (!this._isPending || this._isCanceled) {
                        return;
                    }

                    this._isCanceled = true;

                    if (this._cancelHandlers.length > 0) {
                        try {
                            for (const handler of this._cancelHandlers) {
                                handler();
                            }
                        } catch (error) {
                            this._reject(error);
                            return;
                        }
                    }

                    if (this._rejectOnCancel) {
                        this._reject(new CancelError(reason));
                    }
                }

                get isCanceled() {
                    return this._isCanceled;
                }
            }

            Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);

            module.exports = PCancelable;
            module.exports.CancelError = CancelError;

            /***/
        },

        /***/ 8341: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            var once = __nccwpck_require__(1223);
            var eos = __nccwpck_require__(1205);
            var fs = __nccwpck_require__(5747); // we only need fs to get the ReadStream and WriteStream prototypes

            var noop = function () {};
            var ancient = /^v?\.0/.test(process.version);

            var isFn = function (fn) {
                return typeof fn === "function";
            };

            var isFS = function (stream) {
                if (!ancient) return false; // newer node version do not need to care about fs is a special way
                if (!fs) return false; // browser
                return (
                    (stream instanceof (fs.ReadStream || noop) ||
                        stream instanceof (fs.WriteStream || noop)) &&
                    isFn(stream.close)
                );
            };

            var isRequest = function (stream) {
                return stream.setHeader && isFn(stream.abort);
            };

            var destroyer = function (stream, reading, writing, callback) {
                callback = once(callback);

                var closed = false;
                stream.on("close", function () {
                    closed = true;
                });

                eos(
                    stream,
                    { readable: reading, writable: writing },
                    function (err) {
                        if (err) return callback(err);
                        closed = true;
                        callback();
                    }
                );

                var destroyed = false;
                return function (err) {
                    if (closed) return;
                    if (destroyed) return;
                    destroyed = true;

                    if (isFS(stream)) return stream.close(noop); // use close for fs streams to avoid fd leaks
                    if (isRequest(stream)) return stream.abort(); // request.destroy just do .end - .abort is what we want

                    if (isFn(stream.destroy)) return stream.destroy();

                    callback(err || new Error("stream was destroyed"));
                };
            };

            var call = function (fn) {
                fn();
            };

            var pipe = function (from, to) {
                return from.pipe(to);
            };

            var pump = function () {
                var streams = Array.prototype.slice.call(arguments);
                var callback =
                    (isFn(streams[streams.length - 1] || noop) &&
                        streams.pop()) ||
                    noop;

                if (Array.isArray(streams[0])) streams = streams[0];
                if (streams.length < 2)
                    throw new Error("pump requires two streams per minimum");

                var error;
                var destroys = streams.map(function (stream, i) {
                    var reading = i < streams.length - 1;
                    var writing = i > 0;
                    return destroyer(stream, reading, writing, function (err) {
                        if (!error) error = err;
                        if (err) destroys.forEach(call);
                        if (reading) return;
                        destroys.forEach(call);
                        callback(error);
                    });
                });

                return streams.reduce(pipe);
            };

            module.exports = pump;

            /***/
        },

        /***/ 9273: /***/ (module) => {
            "use strict";

            class QuickLRU {
                constructor(options = {}) {
                    if (!(options.maxSize && options.maxSize > 0)) {
                        throw new TypeError(
                            "`maxSize` must be a number greater than 0"
                        );
                    }

                    this.maxSize = options.maxSize;
                    this.onEviction = options.onEviction;
                    this.cache = new Map();
                    this.oldCache = new Map();
                    this._size = 0;
                }

                _set(key, value) {
                    this.cache.set(key, value);
                    this._size++;

                    if (this._size >= this.maxSize) {
                        this._size = 0;

                        if (typeof this.onEviction === "function") {
                            for (const [
                                key,
                                value,
                            ] of this.oldCache.entries()) {
                                this.onEviction(key, value);
                            }
                        }

                        this.oldCache = this.cache;
                        this.cache = new Map();
                    }
                }

                get(key) {
                    if (this.cache.has(key)) {
                        return this.cache.get(key);
                    }

                    if (this.oldCache.has(key)) {
                        const value = this.oldCache.get(key);
                        this.oldCache.delete(key);
                        this._set(key, value);
                        return value;
                    }
                }

                set(key, value) {
                    if (this.cache.has(key)) {
                        this.cache.set(key, value);
                    } else {
                        this._set(key, value);
                    }

                    return this;
                }

                has(key) {
                    return this.cache.has(key) || this.oldCache.has(key);
                }

                peek(key) {
                    if (this.cache.has(key)) {
                        return this.cache.get(key);
                    }

                    if (this.oldCache.has(key)) {
                        return this.oldCache.get(key);
                    }
                }

                delete(key) {
                    const deleted = this.cache.delete(key);
                    if (deleted) {
                        this._size--;
                    }

                    return this.oldCache.delete(key) || deleted;
                }

                clear() {
                    this.cache.clear();
                    this.oldCache.clear();
                    this._size = 0;
                }

                *keys() {
                    for (const [key] of this) {
                        yield key;
                    }
                }

                *values() {
                    for (const [, value] of this) {
                        yield value;
                    }
                }

                *[Symbol.iterator]() {
                    for (const item of this.cache) {
                        yield item;
                    }

                    for (const item of this.oldCache) {
                        const [key] = item;
                        if (!this.cache.has(key)) {
                            yield item;
                        }
                    }
                }

                get size() {
                    let oldCacheSize = 0;
                    for (const key of this.oldCache.keys()) {
                        if (!this.cache.has(key)) {
                            oldCacheSize++;
                        }
                    }

                    return Math.min(this._size + oldCacheSize, this.maxSize);
                }
            }

            module.exports = QuickLRU;

            /***/
        },

        /***/ 6624: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            "use strict";

            const tls = __nccwpck_require__(4016);

            module.exports = (options = {}, connect = tls.connect) =>
                new Promise((resolve, reject) => {
                    let timeout = false;

                    let socket;

                    const callback = async () => {
                        socket.off("timeout", onTimeout);
                        socket.off("error", reject);

                        if (options.resolveSocket) {
                            resolve({
                                alpnProtocol: socket.alpnProtocol,
                                socket,
                                timeout,
                            });

                            if (timeout) {
                                await Promise.resolve();
                                socket.emit("timeout");
                            }
                        } else {
                            socket.destroy();
                            resolve({
                                alpnProtocol: socket.alpnProtocol,
                                timeout,
                            });
                        }
                    };

                    const onTimeout = async () => {
                        timeout = true;
                        callback();
                    };

                    (async () => {
                        try {
                            socket = await connect(options, callback);

                            socket.on("error", reject);
                            socket.once("timeout", onTimeout);
                        } catch (error) {
                            reject(error);
                        }
                    })();
                });

            /***/
        },

        /***/ 9004: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            "use strict";

            const Readable = __nccwpck_require__(2413).Readable;
            const lowercaseKeys = __nccwpck_require__(9662);

            class Response extends Readable {
                constructor(statusCode, headers, body, url) {
                    if (typeof statusCode !== "number") {
                        throw new TypeError(
                            "Argument `statusCode` should be a number"
                        );
                    }
                    if (typeof headers !== "object") {
                        throw new TypeError(
                            "Argument `headers` should be an object"
                        );
                    }
                    if (!(body instanceof Buffer)) {
                        throw new TypeError(
                            "Argument `body` should be a buffer"
                        );
                    }
                    if (typeof url !== "string") {
                        throw new TypeError(
                            "Argument `url` should be a string"
                        );
                    }

                    super();
                    this.statusCode = statusCode;
                    this.headers = lowercaseKeys(headers);
                    this.body = body;
                    this.url = url;
                }

                _read() {
                    this.push(this.body);
                    this.push(null);
                }
            }

            module.exports = Response;

            /***/
        },

        /***/ 4294: /***/ (
            module,
            __unused_webpack_exports,
            __nccwpck_require__
        ) => {
            module.exports = __nccwpck_require__(4219);

            /***/
        },

        /***/ 4219: /***/ (
            __unused_webpack_module,
            exports,
            __nccwpck_require__
        ) => {
            "use strict";

            var net = __nccwpck_require__(1631);
            var tls = __nccwpck_require__(4016);
            var http = __nccwpck_require__(8605);
            var https = __nccwpck_require__(7211);
            var events = __nccwpck_require__(8614);
            var assert = __nccwpck_require__(2357);
            var util = __nccwpck_require__(1669);

            exports.httpOverHttp = httpOverHttp;
            exports.httpsOverHttp = httpsOverHttp;
            exports.httpOverHttps = httpOverHttps;
            exports.httpsOverHttps = httpsOverHttps;

            function httpOverHttp(options) {
                var agent = new TunnelingAgent(options);
                agent.request = http.request;
                return agent;
            }

            function httpsOverHttp(options) {
                var agent = new TunnelingAgent(options);
                agent.request = http.request;
                agent.createSocket = createSecureSocket;
                agent.defaultPort = 443;
                return agent;
            }

            function httpOverHttps(options) {
                var agent = new TunnelingAgent(options);
                agent.request = https.request;
                return agent;
            }

            function httpsOverHttps(options) {
                var agent = new TunnelingAgent(options);
                agent.request = https.request;
                agent.createSocket = createSecureSocket;
                agent.defaultPort = 443;
                return agent;
            }

            function TunnelingAgent(options) {
                var self = this;
                self.options = options || {};
                self.proxyOptions = self.options.proxy || {};
                self.maxSockets =
                    self.options.maxSockets || http.Agent.defaultMaxSockets;
                self.requests = [];
                self.sockets = [];

                self.on(
                    "free",
                    function onFree(socket, host, port, localAddress) {
                        var options = toOptions(host, port, localAddress);
                        for (
                            var i = 0, len = self.requests.length;
                            i < len;
                            ++i
                        ) {
                            var pending = self.requests[i];
                            if (
                                pending.host === options.host &&
                                pending.port === options.port
                            ) {
                                // Detect the request to connect same origin server,
                                // reuse the connection.
                                self.requests.splice(i, 1);
                                pending.request.onSocket(socket);
                                return;
                            }
                        }
                        socket.destroy();
                        self.removeSocket(socket);
                    }
                );
            }
            util.inherits(TunnelingAgent, events.EventEmitter);

            TunnelingAgent.prototype.addRequest = function addRequest(
                req,
                host,
                port,
                localAddress
            ) {
                var self = this;
                var options = mergeOptions(
                    { request: req },
                    self.options,
                    toOptions(host, port, localAddress)
                );

                if (self.sockets.length >= this.maxSockets) {
                    // We are over limit so we'll add it to the queue.
                    self.requests.push(options);
                    return;
                }

                // If we are under maxSockets create a new one.
                self.createSocket(options, function (socket) {
                    socket.on("free", onFree);
                    socket.on("close", onCloseOrRemove);
                    socket.on("agentRemove", onCloseOrRemove);
                    req.onSocket(socket);

                    function onFree() {
                        self.emit("free", socket, options);
                    }

                    function onCloseOrRemove(err) {
                        self.removeSocket(socket);
                        socket.removeListener("free", onFree);
                        socket.removeListener("close", onCloseOrRemove);
                        socket.removeListener("agentRemove", onCloseOrRemove);
                    }
                });
            };

            TunnelingAgent.prototype.createSocket = function createSocket(
                options,
                cb
            ) {
                var self = this;
                var placeholder = {};
                self.sockets.push(placeholder);

                var connectOptions = mergeOptions({}, self.proxyOptions, {
                    method: "CONNECT",
                    path: options.host + ":" + options.port,
                    agent: false,
                    headers: {
                        host: options.host + ":" + options.port,
                    },
                });
                if (options.localAddress) {
                    connectOptions.localAddress = options.localAddress;
                }
                if (connectOptions.proxyAuth) {
                    connectOptions.headers = connectOptions.headers || {};
                    connectOptions.headers["Proxy-Authorization"] =
                        "Basic " +
                        new Buffer(connectOptions.proxyAuth).toString("base64");
                }

                debug("making CONNECT request");
                var connectReq = self.request(connectOptions);
                connectReq.useChunkedEncodingByDefault = false; // for v0.6
                connectReq.once("response", onResponse); // for v0.6
                connectReq.once("upgrade", onUpgrade); // for v0.6
                connectReq.once("connect", onConnect); // for v0.7 or later
                connectReq.once("error", onError);
                connectReq.end();

                function onResponse(res) {
                    // Very hacky. This is necessary to avoid http-parser leaks.
                    res.upgrade = true;
                }

                function onUpgrade(res, socket, head) {
                    // Hacky.
                    process.nextTick(function () {
                        onConnect(res, socket, head);
                    });
                }

                function onConnect(res, socket, head) {
                    connectReq.removeAllListeners();
                    socket.removeAllListeners();

                    if (res.statusCode !== 200) {
                        debug(
                            "tunneling socket could not be established, statusCode=%d",
                            res.statusCode
                        );
                        socket.destroy();
                        var error = new Error(
                            "tunneling socket could not be established, " +
                                "statusCode=" +
                                res.statusCode
                        );
                        error.code = "ECONNRESET";
                        options.request.emit("error", error);
                        self.removeSocket(placeholder);
                        return;
                    }
                    if (head.length > 0) {
                        debug("got illegal response body from proxy");
                        socket.destroy();
                        var error = new Error(
                            "got illegal response body from proxy"
                        );
                        error.code = "ECONNRESET";
                        options.request.emit("error", error);
                        self.removeSocket(placeholder);
                        return;
                    }
                    debug("tunneling connection has established");
                    self.sockets[self.sockets.indexOf(placeholder)] = socket;
                    return cb(socket);
                }

                function onError(cause) {
                    connectReq.removeAllListeners();

                    debug(
                        "tunneling socket could not be established, cause=%s\n",
                        cause.message,
                        cause.stack
                    );
                    var error = new Error(
                        "tunneling socket could not be established, " +
                            "cause=" +
                            cause.message
                    );
                    error.code = "ECONNRESET";
                    options.request.emit("error", error);
                    self.removeSocket(placeholder);
                }
            };

            TunnelingAgent.prototype.removeSocket = function removeSocket(
                socket
            ) {
                var pos = this.sockets.indexOf(socket);
                if (pos === -1) {
                    return;
                }
                this.sockets.splice(pos, 1);

                var pending = this.requests.shift();
                if (pending) {
                    // If we have pending requests and a socket gets closed a new one
                    // needs to be created to take over in the pool for the one that closed.
                    this.createSocket(pending, function (socket) {
                        pending.request.onSocket(socket);
                    });
                }
            };

            function createSecureSocket(options, cb) {
                var self = this;
                TunnelingAgent.prototype.createSocket.call(
                    self,
                    options,
                    function (socket) {
                        var hostHeader = options.request.getHeader("host");
                        var tlsOptions = mergeOptions({}, self.options, {
                            socket: socket,
                            servername: hostHeader
                                ? hostHeader.replace(/:.*$/, "")
                                : options.host,
                        });

                        // 0 is dummy port for v0.6
                        var secureSocket = tls.connect(0, tlsOptions);
                        self.sockets[self.sockets.indexOf(socket)] =
                            secureSocket;
                        cb(secureSocket);
                    }
                );
            }

            function toOptions(host, port, localAddress) {
                if (typeof host === "string") {
                    // since v0.10
                    return {
                        host: host,
                        port: port,
                        localAddress: localAddress,
                    };
                }
                return host; // for v0.11 or later
            }

            function mergeOptions(target) {
                for (var i = 1, len = arguments.length; i < len; ++i) {
                    var overrides = arguments[i];
                    if (typeof overrides === "object") {
                        var keys = Object.keys(overrides);
                        for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
                            var k = keys[j];
                            if (overrides[k] !== undefined) {
                                target[k] = overrides[k];
                            }
                        }
                    }
                }
                return target;
            }

            var debug;
            if (
                process.env.NODE_DEBUG &&
                /\btunnel\b/.test(process.env.NODE_DEBUG)
            ) {
                debug = function () {
                    var args = Array.prototype.slice.call(arguments);
                    if (typeof args[0] === "string") {
                        args[0] = "TUNNEL: " + args[0];
                    } else {
                        args.unshift("TUNNEL:");
                    }
                    console.error.apply(console, args);
                };
            } else {
                debug = function () {};
            }
            exports.debug = debug; // for test

            /***/
        },

        /***/ 5030: /***/ (__unused_webpack_module, exports) => {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });

            function getUserAgent() {
                if (typeof navigator === "object" && "userAgent" in navigator) {
                    return navigator.userAgent;
                }

                if (typeof process === "object" && "version" in process) {
                    return `Node.js/${process.version.substr(1)} (${
                        process.platform
                    }; ${process.arch})`;
                }

                return "<environment undetectable>";
            }

            exports.getUserAgent = getUserAgent;
            //# sourceMappingURL=index.js.map

            /***/
        },

        /***/ 2940: /***/ (module) => {
            // Returns a wrapper function that returns a wrapped callback
            // The wrapper function should do some stuff, and return a
            // presumably different callback function.
            // This makes sure that own properties are retained, so that
            // decorations and such are not lost along the way.
            module.exports = wrappy;
            function wrappy(fn, cb) {
                if (fn && cb) return wrappy(fn)(cb);

                if (typeof fn !== "function")
                    throw new TypeError("need wrapper function");

                Object.keys(fn).forEach(function (k) {
                    wrapper[k] = fn[k];
                });

                return wrapper;

                function wrapper() {
                    var args = new Array(arguments.length);
                    for (var i = 0; i < args.length; i++) {
                        args[i] = arguments[i];
                    }
                    var ret = fn.apply(this, args);
                    var cb = args[args.length - 1];
                    if (typeof ret === "function" && ret !== cb) {
                        Object.keys(cb).forEach(function (k) {
                            ret[k] = cb[k];
                        });
                    }
                    return ret;
                }
            }

            /***/
        },

        /***/ 2877: /***/ (module) => {
            module.exports = eval("require")("encoding");

            /***/
        },

        /***/ 8600: /***/ (module) => {
            "use strict";
            module.exports = JSON.parse(
                '{"_from":"chart.js-image","_id":"chart.js-image@5.6.0","_inBundle":false,"_integrity":"sha512-v7P1DVXMRMR/P+yEWUsOg7B2hZM3CxeIyiAy7hx/4EY8rkhu2voCe4hJmzwBem4Q7T9XJo2DMpL3gPm1Af9srQ==","_location":"/chart.js-image","_phantomChildren":{},"_requested":{"type":"tag","registry":true,"raw":"chart.js-image","name":"chart.js-image","escapedName":"chart.js-image","rawSpec":"","saveSpec":null,"fetchSpec":"latest"},"_requiredBy":["#USER","/"],"_resolved":"https://registry.npmjs.org/chart.js-image/-/chart.js-image-5.6.0.tgz","_shasum":"83adfcf5cb87b63ee3e27d3a468625f8ada2de5c","_spec":"chart.js-image","_where":"/Users/szeying/Desktop/projects/others/notion","author":{"name":"Francois-Guillaume Ribreau","email":"npm@fgribreau.com","url":"http://fgribreau.com/"},"bugs":{"url":"https://github.com/image-charts//issues"},"bundleDependencies":false,"contributors":[],"dependencies":{"javascript-stringify":"2.0.1","node-fetch":"2.6.0"},"deprecated":false,"description":"Render Chart.JS as Image (or URL of Image)","devDependencies":{"@babel/preset-env":"7.9.6","babel-jest":"26.0.1","jest":"26.0.1","jest-junit":"10.0.0","npm-release":"^1.0.0","updtr":"3.1.0"},"engines":{"node":">12"},"homepage":"https://github.com/image-charts/#readme","jest":{"verbose":true,"cacheDirectory":".jest_cache","testEnvironment":"node","testTimeout":5000,"coverageDirectory":"coverage","moduleFileExtensions":["js","json"],"modulePaths":["<rootDir>/src/"],"reporters":["default",["jest-junit",{"outputDirectory":"coverage","outputName":"junit.xml"}]],"coverageThreshold":{"global":{"branches":89,"functions":95,"lines":100,"statements":98}}},"keywords":["chart.js","charts","chart url","image","imagecharts","png","jpg","jpeg","gif","animated","api","pie","bar","horizontal-bar","bubble","doughnut","line","polar"],"license":"MIT","main":"lib.js","name":"chart.js-image","repository":{"type":"git","url":"git+ssh://git@github.com/image-charts/.git.git"},"scripts":{"@comment updr":"-r basic : Uses console.log for output, no need for a TTY (e.g when running on CI) => https://www.npmjs.com/package/updtr#--reporter--r","test":"jest --coverage ./test.js","updtr":"updtr -r basic"},"types":"types.d.ts","version":"5.6.0"}'
            );

            /***/
        },

        /***/ 2357: /***/ (module) => {
            "use strict";
            module.exports = require("assert");

            /***/
        },

        /***/ 4293: /***/ (module) => {
            "use strict";
            module.exports = require("buffer");

            /***/
        },

        /***/ 6417: /***/ (module) => {
            "use strict";
            module.exports = require("crypto");

            /***/
        },

        /***/ 881: /***/ (module) => {
            "use strict";
            module.exports = require("dns");

            /***/
        },

        /***/ 8614: /***/ (module) => {
            "use strict";
            module.exports = require("events");

            /***/
        },

        /***/ 5747: /***/ (module) => {
            "use strict";
            module.exports = require("fs");

            /***/
        },

        /***/ 8605: /***/ (module) => {
            "use strict";
            module.exports = require("http");

            /***/
        },

        /***/ 7565: /***/ (module) => {
            "use strict";
            module.exports = require("http2");

            /***/
        },

        /***/ 7211: /***/ (module) => {
            "use strict";
            module.exports = require("https");

            /***/
        },

        /***/ 1631: /***/ (module) => {
            "use strict";
            module.exports = require("net");

            /***/
        },

        /***/ 2087: /***/ (module) => {
            "use strict";
            module.exports = require("os");

            /***/
        },

        /***/ 5622: /***/ (module) => {
            "use strict";
            module.exports = require("path");

            /***/
        },

        /***/ 1191: /***/ (module) => {
            "use strict";
            module.exports = require("querystring");

            /***/
        },

        /***/ 2413: /***/ (module) => {
            "use strict";
            module.exports = require("stream");

            /***/
        },

        /***/ 4016: /***/ (module) => {
            "use strict";
            module.exports = require("tls");

            /***/
        },

        /***/ 8835: /***/ (module) => {
            "use strict";
            module.exports = require("url");

            /***/
        },

        /***/ 1669: /***/ (module) => {
            "use strict";
            module.exports = require("util");

            /***/
        },

        /***/ 8761: /***/ (module) => {
            "use strict";
            module.exports = require("zlib");

            /***/
        },

        /******/
    };
    /************************************************************************/
    /******/ // The module cache
    /******/ var __webpack_module_cache__ = {};
    /******/
    /******/ // The require function
    /******/ function __nccwpck_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/ var cachedModule = __webpack_module_cache__[moduleId];
        /******/ if (cachedModule !== undefined) {
            /******/ return cachedModule.exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/ var module = (__webpack_module_cache__[moduleId] = {
            /******/ id: moduleId,
            /******/ loaded: false,
            /******/ exports: {},
            /******/
        });
        /******/
        /******/ // Execute the module function
        /******/ var threw = true;
        /******/ try {
            /******/ __webpack_modules__[moduleId].call(
                module.exports,
                module,
                module.exports,
                __nccwpck_require__
            );
            /******/ threw = false;
            /******/
        } finally {
            /******/ if (threw) delete __webpack_module_cache__[moduleId];
            /******/
        }
        /******/
        /******/ // Flag the module as loaded
        /******/ module.loaded = true;
        /******/
        /******/ // Return the exports of the module
        /******/ return module.exports;
        /******/
    }
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/node module decorator */
    /******/ (() => {
        /******/ __nccwpck_require__.nmd = (module) => {
            /******/ module.paths = [];
            /******/ if (!module.children) module.children = [];
            /******/ return module;
            /******/
        };
        /******/
    })();
    /******/
    /******/ /* webpack/runtime/compat */
    /******/
    /******/ if (typeof __nccwpck_require__ !== "undefined")
        __nccwpck_require__.ab = __dirname + "/";
    /******/
    /************************************************************************/
    var __webpack_exports__ = {};
    // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
    (() => {
        const { Client } = __nccwpck_require__(324);
        const moment = __nccwpck_require__(9623);
        const ChartJSImage = __nccwpck_require__(2725);
        const log = __nccwpck_require__(8063);
        const fs = __nccwpck_require__(5747);
        const core = __nccwpck_require__(2186);
        const github = __nccwpck_require__(5438);

        log.setLevel("info");
        __nccwpck_require__(2437).config();

        const parseConfig = () => {
            if (process.env.NODE_ENV === "offline") {
                return {
                    notion: {
                        client: new Client({ auth: process.env.NOTION_KEY }),
                        databases: {
                            backlog: process.env.NOTION_DB_BACKLOG,
                            sprintSummary: process.env.NOTION_DB_SPRINT_SUMMARY,
                            dailySummary: process.env.NOTION_DB_DAILY_SUMMARY,
                        },
                        options: {
                            sprintProp: process.env.NOTION_PROPERTY_SPRINT,
                            estimateProp: process.env.NOTION_PROPERTY_ESTIMATE,
                            statusExclude:
                                process.env
                                    .NOTION_PROPERTY_PATTERN_STATUS_EXCLUDE,
                        },
                    },
                    chartOptions: {
                        isIncludeWeekends:
                            process.env.INCLUDE_WEEKENDS !== "false",
                    },
                };
            }
            return {
                notion: {
                    client: new Client({ auth: core.getInput("NOTION_KEY") }),
                    databases: {
                        backlog: core.getInput("NOTION_DB_BACKLOG"),
                        sprintSummary: core.getInput(
                            "NOTION_DB_SPRINT_SUMMARY"
                        ),
                        dailySummary: core.getInput("NOTION_DB_DAILY_SUMMARY"),
                    },
                    options: {
                        sprintProp: core.getInput("NOTION_PROPERTY_SPRINT"),
                        estimateProp: core.getInput("NOTION_PROPERTY_ESTIMATE"),
                        statusExclude: core.getInput(
                            "NOTION_PROPERTY_PATTERN_STATUS_EXCLUDE"
                        ),
                    },
                },
                chartOptions: {
                    isIncludeWeekends:
                        core.getInput("INCLUDE_WEEKENDS") !== "false",
                },
            };
        };

        const getLatestSprintSummary = async (
            notion,
            sprintSummaryDb,
            { sprintProp }
        ) => {
            const response = await notion.databases.query({
                database_id: sprintSummaryDb,
                sorts: [
                    {
                        property: sprintProp,
                        direction: "descending",
                    },
                ],
            });
            const { properties } = response.results[0];
            const { Sprint, Start, End } = properties;
            return {
                sprint: Sprint.number,
                start: moment(Start.date.start),
                end: moment(End.date.start),
            };
        };

        const countPointsLeftInSprint = async (
            notion,
            backlogDb,
            sprint,
            { sprintProp, estimateProp, statusExclude }
        ) => {
            const response = await notion.databases.query({
                database_id: backlogDb,
                filter: {
                    property: sprintProp,
                    select: {
                        equals: `Sprint ${sprint}`,
                    },
                },
            });
            const sprintStories = response.results;
            const ongoingStories = sprintStories.filter(
                (item) =>
                    !new RegExp(statusExclude).test(
                        item.properties.Status.select.name
                    )
            );
            return ongoingStories.reduce((accum, item) => {
                if (item.properties[estimateProp]) {
                    const points = item.properties[estimateProp].number;
                    return accum + points;
                }
                return accum;
            }, 0);
        };

        const updateDailySummaryTable = async (
            notion,
            dailySummaryDb,
            sprint,
            pointsLeft
        ) => {
            const today = moment().startOf("day").format("YYYY-MM-DD");
            await notion.pages.create({
                parent: {
                    database_id: dailySummaryDb,
                },
                properties: {
                    Name: {
                        title: [
                            {
                                text: {
                                    content: `Sprint ${sprint} - ${today}`,
                                },
                            },
                        ],
                    },
                    Sprint: {
                        number: sprint,
                    },
                    Points: {
                        number: pointsLeft,
                    },
                    Date: {
                        date: { start: today, end: null },
                    },
                },
            });
        };

        const isWeekend = (date) => {
            const dayOfWeek = moment(date).format("ddd");
            return dayOfWeek === "Sat" || dayOfWeek === "Sun";
        };

        /**
         * Calculates the number of weekdays from {@link start} to {@link end}
         * @param {moment.Moment} start First day of sprint (inclusive)
         * @param {moment.Moment} end Last day of sprint (inclusive)
         * @returns number of weekdays between both dates
         */
        const getNumberOfWeekdays = (start, end) => {
            let weekdays = 0;
            for (
                const cur = moment(start);
                !cur.isAfter(end);
                cur.add(1, "days")
            ) {
                if (!isWeekend(cur)) {
                    weekdays += 1;
                }
            }
            return weekdays;
        };

        /**
         * Calculates the points left for each day of the sprint so far
         * @param {number} sprint Sprint number of current sprint
         * @param {moment.Moment} start First day of sprint (inclusive)
         * @returns {number[]} Array of points left each day from {@link start} till today (inclusive)
         * */
        const getPointsLeftByDay = async (
            notion,
            dailySummaryDb,
            sprint,
            start,
            isIncludeWeekends
        ) => {
            const response = await notion.databases.query({
                database_id: dailySummaryDb,
                filter: {
                    property: "Sprint",
                    number: {
                        equals: sprint,
                    },
                },
                sorts: [
                    {
                        property: "Date",
                        direction: "ascending",
                    },
                ],
            });
            const pointsLeftByDay = [];
            response.results.forEach((result) => {
                const { properties } = result;
                const { Date, Points } = properties;
                const day = moment(Date.date.start).diff(start, "days");
                if (pointsLeftByDay[day]) {
                    log.warn(
                        JSON.stringify({
                            message: "Found duplicate entry",
                            date: Date.date.start,
                            points: Points.number,
                        })
                    );
                }
                pointsLeftByDay[day] = Points.number;
            });
            const numDaysSinceSprintStart = moment()
                .startOf("day")
                .diff(start, "days");
            for (let i = 0; i < numDaysSinceSprintStart; i += 1) {
                if (!pointsLeftByDay[i]) {
                    pointsLeftByDay[i] = 0;
                }
            }
            log.info(JSON.stringify({ numDaysSinceSprintStart }));

            if (!isIncludeWeekends) {
                // remove weekend entries
                let index = 0;
                for (
                    const cur = moment(start);
                    index < pointsLeftByDay.length;
                    cur.add(1, "days")
                ) {
                    if (isWeekend(cur)) {
                        pointsLeftByDay.splice(index, 1);
                    } else {
                        index += 1;
                    }
                }
            }

            return pointsLeftByDay;
        };
        /**
         * Generates the ideal burndown line for the sprint. Work is assumed to be done on
         * each weekday from {@link start} until the day before {@link end}. A data point is
         * generated for {@link end} to show the final remaining points.
         *
         * A flat line is shown across weekends if {@link isWeekendsIncluded} is set to true,
         * else, the weekends are not shown.
         * @param {moment.Moment} start The start of the sprint (inclusive)
         * @param {moment.Moment} end The end of the sprint (inclusive)
         * @param {number} initialPoints Points the sprint started with
         * @param {number} numWeekdays Number of working days in the sprint
         * @returns {number[]} Array of the ideal points left per day
         */
        const getIdealBurndown = (
            start,
            end,
            initialPoints,
            numWeekdays,
            isIncludeWeekends
        ) => {
            const pointsPerDay = initialPoints / numWeekdays;

            log.info(
                JSON.stringify({
                    initialPoints,
                    numWeekdays,
                    pointsPerDay,
                })
            );

            const idealBurndown = [];
            const cur = moment(start);
            const afterEnd = moment(end).add(1, "days"); // to include the end day data point
            let isPrevDayWeekday = false;
            for (
                let index = 0;
                cur.isBefore(afterEnd);
                index += 1, cur.add(1, "days")
            ) {
                // if not including the weekends, just skip over the weekend days
                if (!isIncludeWeekends) {
                    while (isWeekend(cur)) {
                        cur.add(1, "days");
                    }
                }

                if (index === 0) {
                    idealBurndown[index] = initialPoints;
                } else {
                    idealBurndown[index] =
                        idealBurndown[index - 1] -
                        (isPrevDayWeekday ? pointsPerDay : 0);
                }

                isPrevDayWeekday = !isWeekend(cur);
            }

            // rounds to 2 decimal places, which prevents the graph from getting jagged
            // from overtruncation when there's less than 30 points
            return idealBurndown.map((points) => +points.toFixed(2));
        };

        /**
         * Generates the labels for the chart from 1 to {@link numberOfDays} + 1
         * to have a data point for after the last day.
         * @param {number} numberOfDays Number of workdays in the sprint
         * @returns {number[]} Labels for the chart
         */
        const getChartLabels = (numberOfDays) =>
            // cool way to generate numbers from 1 to n
            [...Array(numberOfDays).keys()].map((i) => i + 1);
        /**
         * Generates the data to be displayed on the chart. Work is assumed to be
         * done on each day from the start until the day before {@link end}.
         * @param {number} sprint Current sprint number
         * @param {moment.Moment} start Start date of sprint (included)
         * @param {moment.Moment} end End date of sprint (excluded)
         * @returns The chart labels, data line, and ideal burndown line
         */
        const getChartDatasets = async (
            notion,
            dailySummaryDb,
            sprint,
            start,
            end,
            { isIncludeWeekends }
        ) => {
            const numDaysInSprint = moment(end).diff(start, "days") + 1;
            const lastFullDay = moment(end).add(-1, "days");
            const numWeekdays = getNumberOfWeekdays(start, lastFullDay);

            const pointsLeftByDay = await getPointsLeftByDay(
                notion,
                dailySummaryDb,
                sprint,
                start,
                isIncludeWeekends
            );
            const idealBurndown = getIdealBurndown(
                start,
                end,
                pointsLeftByDay[0],
                numWeekdays,
                isIncludeWeekends
            );
            const labels = getChartLabels(
                isIncludeWeekends ? numDaysInSprint : numWeekdays + 1
            );

            return { labels, pointsLeftByDay, idealBurndown };
        };

        const generateChart = (data, idealBurndown, labels) => {
            const chart = ChartJSImage()
                .chart({
                    type: "line",
                    data: {
                        labels,
                        datasets: [
                            {
                                label: "Burndown",
                                borderColor: "#ef4444",
                                backgroundColor: "rgba(255,+99,+132,+.5)",
                                data,
                            },
                            {
                                label: "Constant",
                                borderColor: "#cad0d6",
                                backgroundColor: "rgba(54,+162,+235,+.5)",
                                data: idealBurndown,
                            },
                        ],
                    },
                    options: {
                        title: {
                            display: true,
                            text: "Sprint Burndown",
                        },
                        legend: { display: false },
                        scales: {
                            xAxes: [
                                {
                                    scaleLabel: {
                                        display: true,
                                        labelString: "Day",
                                    },
                                },
                            ],
                            yAxes: [
                                {
                                    stacked: false,
                                    scaleLabel: {
                                        display: true,
                                        labelString: "Points Left",
                                    },
                                    ticks: {
                                        beginAtZero: true,
                                        max: Math.max(...data),
                                    },
                                },
                            ],
                        },
                    },
                }) // Line chart
                .backgroundColor("white")
                .width(500) // 500px
                .height(300); // 300px
            return chart;
        };

        const writeChartToFile = async (chart, dir, filenamePrefix) => {
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir);
            }
            await chart.toFile(`${dir}/${filenamePrefix}-burndown.png`);
        };

        const run = async () => {
            const { notion, chartOptions } = parseConfig();

            const { sprint, start, end } = await getLatestSprintSummary(
                notion.client,
                notion.databases.sprintSummary,
                { sprintProp: notion.options.sprintProp }
            );
            log.info(
                JSON.stringify({
                    message: "Found latest sprint",
                    sprint,
                    start,
                    end,
                })
            );

            const pointsLeftInSprint = await countPointsLeftInSprint(
                notion.client,
                notion.databases.backlog,
                sprint,
                {
                    sprintProp: notion.options.sprintProp,
                    estimateProp: notion.options.estimateProp,
                    statusExclude: notion.options.statusExclude,
                }
            );
            log.info(
                JSON.stringify({
                    message: "Counted points left in sprint",
                    sprint,
                    pointsLeftInSprint,
                })
            );

            await updateDailySummaryTable(
                notion.client,
                notion.databases.dailySummary,
                sprint,
                pointsLeftInSprint
            );
            log.info(
                JSON.stringify({
                    message: "Updated daily summary table",
                    sprint,
                    pointsLeftInSprint,
                })
            );

            const {
                labels,
                pointsLeftByDay: data,
                idealBurndown,
            } = await getChartDatasets(
                notion.client,
                notion.databases.dailySummary,
                sprint,
                start,
                end,
                {
                    isIncludeWeekends: chartOptions.isIncludeWeekends,
                }
            );
            log.info(JSON.stringify({ labels, data, idealBurndown }));
            const chart = generateChart(data, idealBurndown, labels);

            await writeChartToFile(
                chart,
                "./out",
                `sprint${sprint}-${Date.now()}`
            );
            await writeChartToFile(chart, "./out", `sprint${sprint}-latest`);
            log.info(
                JSON.stringify({
                    message: "Generated burndown chart",
                    sprint,
                    data,
                })
            );
        };

        run();
    })();

    module.exports = __webpack_exports__;
    /******/
})();
